2015-12-10 16:25:38,260 - pgpm.app - INFO - Installing... host=localhost port=5432 dbname=pgpm_test_1 user=apanchoyan
2015-12-10 16:25:38,274 - pgpm.app - INFO - Running functions definitions scripts
2015-12-10 16:25:38,290 - pgpm.app - ERROR - Can't install pgpm as schema _pgpm already exists
2015-12-10 16:41:20,261 - pgpm.app - INFO - Installing... host=localhost port=5432 dbname=pgpm_test_1 user=apanchoyan
2015-12-10 16:41:20,269 - pgpm.app - DEBUG - lib/db_scripts/functions/_add_migration_info.sql
2015-12-10 16:41:20,270 - pgpm.app - DEBUG - lib/db_scripts/functions/_alter_schema_owner.sql
2015-12-10 16:41:20,270 - pgpm.app - DEBUG - lib/db_scripts/functions/_find_schema.sql
2015-12-10 16:41:20,271 - pgpm.app - DEBUG - lib/db_scripts/functions/_is_table_ddl_executed.sql
2015-12-10 16:41:20,271 - pgpm.app - DEBUG - lib/db_scripts/functions/_log_ddl_change.sql
2015-12-10 16:41:20,272 - pgpm.app - DEBUG - lib/db_scripts/functions/_log_table_evolution.sql
2015-12-10 16:41:20,272 - pgpm.app - DEBUG - lib/db_scripts/functions/_set_revision_package.sql
2015-12-10 16:41:20,272 - pgpm.app - DEBUG - lib/db_scripts/functions/_upsert_package_info.sql
2015-12-10 16:41:20,273 - pgpm.app - DEBUG - lib/db_scripts/functions/set_search_path.sql
2015-12-10 16:41:20,274 - pgpm.app - DEBUG - Executing query: select * from CURRENT_USER;
2015-12-10 16:41:20,275 - pgpm.app - DEBUG - Executing query: select usesuper from pg_user where usename = CURRENT_USER;
2015-12-10 16:41:20,277 - pgpm.app - DEBUG - Executing query: SELECT EXISTS (SELECT schema_name FROM information_schema.schemata WHERE schema_name = '_pgpm');
2015-12-10 16:41:20,277 - pgpm.app - INFO - Running functions definitions scripts
2015-12-10 16:41:20,277 - pgpm.app - DEBUG - {'_log_ddl_change.sql': u'CREATE OR REPLACE FUNCTION _log_ddl_change()\n    RETURNS EVENT_TRIGGER AS\n$BODY$\n---\n-- @description\n-- Logs any DDL changes to the DB\n--\n---\nDECLARE\n    l_current_query TEXT;\n    l_txid BIGINT;\nBEGIN\n\n    SELECT current_query() INTO l_current_query;\n    SELECT txid_current() INTO l_txid;\n    INSERT INTO _pgpm.ddl_changes_log (ddl_change)\n    SELECT l_current_query\n    WHERE\n        NOT EXISTS (\n            SELECT ddl_change_txid, ddl_change FROM _pgpm.ddl_changes_log\n            WHERE ddl_change_txid = l_txid AND ddl_change = l_current_query\n        );\n\n    -- Notify external channels of ddl change\n    PERFORM pg_notify(\'ddl_change\', "session_user"());\n\nEND;\n$BODY$\nLANGUAGE \'plpgsql\' VOLATILE SECURITY DEFINER;', '_add_migration_info.sql': u"CREATE OR REPLACE FUNCTION _add_migration_info(p_m_low_v TEXT, p_m_high_v TEXT)\n    RETURNS VOID AS\n$BODY$\n---\n-- @description\n-- Adds migration info migrations log table\n--\n-- @param p_m_low_v\n-- lower border of version that is applicaple for this migration\n--\n-- @param p_m_high_v\n-- package type: either version (with version suffix at the end of the name) or basic (without)\n--\n-- @param p_pkg_old_rev\n-- higher border of version that is applicaple for this migration\n--\n---\nBEGIN\n\n    BEGIN\n        INSERT INTO migrations_log (m_low_v, m_high_v)\n            VALUES (p_m_low_v, p_m_high_v);\n    EXCEPTION\n        WHEN SQLSTATE '42P01' THEN\n            RAISE WARNING 'Can''t log migration from % to % as migrations_log is not defined yet', p_m_low_v, p_m_high_v;\n    END;\nEND;\n$BODY$\nLANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", 'set_search_path.sql': u"CREATE OR REPLACE FUNCTION set_search_path(p_schema_name TEXT, p_v_req TEXT)\n    RETURNS json AS\n$BODY$\n---\n-- @description\n-- Sets search path that includes also all depending\n--\n-- @param p_schema_name\n-- Package (schema) name\n--\n-- @param p_v_req\n-- Package version requirement. Version notation supports:\n-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)\n-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x\n-- - comparison operators like >01_02_03 or <2\n-- - x for any latest version of package\n-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency\n--\n-- @returns\n-- JSON with schema names and exact versions or exception if not found\n---\nDECLARE\n    l_search_path TEXT;\n    l_search_path_deps TEXT;\n    l_listen_text TEXT;\n\n    l_pkg_version_wrapped RECORD;\n    l_pkg_version RECORD;\n\n    return_value json;\nBEGIN\n\n    SET search_path TO _pgpm;\n    SELECT _find_schema(p_schema_name, p_v_req) AS version INTO l_pkg_version_wrapped;\n    l_pkg_version := l_pkg_version_wrapped.version;\n\n    l_search_path := l_pkg_version.pkg_name || '_' ||\n                     l_pkg_version.pkg_v_major::text || '_' ||\n                     l_pkg_version.pkg_v_minor::text || '_' ||\n                     l_pkg_version.pkg_v_patch::text;\n\n    SELECT string_agg(pkg_name || '_' || pkg_v_major || '_' || pkg_v_minor || '_' || pkg_v_patch, ', ')\n    FROM packages\n    WHERE pkg_id IN (\n        SELECT pkg_link_dep_id from package_dependencies\n        JOIN packages ON pkg_id = l_pkg_version.pkg_id\n        WHERE pkg_link_core_id = pkg_id\n    )\n    INTO l_search_path_deps;\n\n    l_search_path := l_search_path || ', ' || l_search_path_deps;\n\n    l_listen_text := 'deployment_events' || '$$' || l_pkg_version.pkg_name;\n    EXECUTE 'LISTEN ' || l_listen_text;\n\n    RAISE INFO '%', l_search_path;\n    PERFORM set_config('search_path', l_search_path || ', public', false);\n\n    return_value := row_to_json(l_pkg_version);\n    RETURN return_value;\n\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_find_schema.sql': u"CREATE OR REPLACE FUNCTION _find_schema(p_schema_name TEXT, p_v_req TEXT)\n    RETURNS RECORD AS\n$BODY$\n---\n-- @description\n-- Searches for existing schema (package) within registered packages in _pgpm schema\n--\n-- @param p_schema_name\n-- Package (schema) name\n--\n-- @param p_v_req\n-- Package version requirement. Version notation supports:\n-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)\n-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x\n-- - comparison operators like >01_02_03 or <2\n-- - x for any latest version of package\n-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency\n--\n-- @returns\n-- Record containing schema name and exact version or exception if not found in the following format:\n-- pkg_name TEXT, pkg_v_major INTEGER, pkg_v_minor INTEGER, pkg_v_patch INTEGER\n---\nDECLARE\n    c_re_version TEXT = '^(<=|>=|<|>{0,2})(\\d*|x*)_?(\\d*|x*)_?(\\d*|x*)';\n    l_v_matches TEXT[];\n\n    l_v_major INTEGER;\n    l_v_minor INTEGER;\n    l_v_patch INTEGER;\n\n    return_value RECORD;\nBEGIN\n\n    SELECT regexp_matches(p_v_req, c_re_version, 'gi') INTO l_v_matches;\n\n    IF l_v_matches[2] ~* '^x+|^$' THEN\n        SELECT max(pkg_v_major)\n        FROM packages\n        WHERE pkg_name = p_schema_name\n        INTO l_v_major;\n    ELSE\n        l_v_major := l_v_matches[2]::integer;\n    END IF;\n\n    IF l_v_matches[3] ~* '^x+|^$' THEN\n        SELECT max(pkg_v_minor)\n        FROM packages\n        WHERE pkg_name = p_schema_name\n              AND pkg_v_major = l_v_major\n        INTO l_v_minor;\n    ELSE\n        l_v_minor := l_v_matches[3]::integer;\n    END IF;\n\n    IF l_v_matches[4] ~* '^x+|^$' THEN\n        SELECT max(pkg_v_patch)\n        FROM packages\n        WHERE pkg_name = p_schema_name\n              AND pkg_v_major = l_v_major\n              AND pkg_v_minor = l_v_minor\n        INTO l_v_patch;\n    ELSE\n        l_v_patch := l_v_matches[4]::integer;\n    END IF;\n\n    CASE l_v_matches[1]\n        WHEN '=', '' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND pkg_v_major = l_v_major\n                  AND pkg_v_minor = l_v_minor\n                  AND pkg_v_patch = l_v_patch\n            INTO return_value;\n        WHEN '<' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major < l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor < l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch < l_v_patch))\n            INTO return_value;\n        WHEN '>' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major > l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor > l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch > l_v_patch))\n            INTO return_value;\n        WHEN '<=' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major <= l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor <= l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch <= l_v_patch))\n            INTO return_value;\n        WHEN '>=' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major >= l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor >= l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch >= l_v_patch))\n            INTO return_value;\n        ELSE\n            RAISE EXCEPTION 'Invalid logical operand. Only <, >, =, <=, >=, = or no operand are allowed.' USING ERRCODE = '20000';\n    END CASE;\n\n    RETURN return_value;\n\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_upsert_package_info.sql': u"CREATE OR REPLACE FUNCTION _upsert_package_info(p_pkg_name TEXT,\n                                             p_pkg_subclass_name TEXT,\n                                             p_pkg_v_major INTEGER,\n                                             p_pkg_v_minor INTEGER DEFAULT 0,\n                                             p_pkg_v_patch INTEGER DEFAULT 0,\n                                             p_pkg_v_pre TEXT DEFAULT NULL,\n                                             p_pkg_v_metadata TEXT DEFAULT NULL,\n                                             p_pkg_description TEXT DEFAULT '',\n                                             p_pkg_license TEXT DEFAULT NULL,\n                                             p_pkg_deps_ids INTEGER[] DEFAULT '{}',\n                                             p_pkg_vcs_ref TEXT DEFAULT NULL,\n                                             p_pkg_vcs_link TEXT DEFAULT NULL,\n                                             p_pkg_issue_ref TEXT DEFAULT NULL,\n                                             p_pkg_issue_link TEXT DEFAULT NULL)\n    RETURNS INTEGER AS\n$BODY$\n---\n-- @description\n-- Adds package info to pgpm package info table, deployment events table and notifies channels of deployment\n--\n-- @param p_pkg_name\n-- package name\n--\n-- @param p_pkg_subclass_name\n-- package type: either version (with version suffix at the end of the name) or basic (without)\n--\n-- @param p_pkg_description\n-- package description\n--\n-- @param p_pkg_v_major\n-- package major part of version (according to semver)\n--\n-- @param p_pkg_v_minor\n-- package minor part of version (according to semver)\n--\n-- @param p_pkg_v_patch\n-- package patch part of version (according to semver)\n--\n-- @param p_pkg_v_pre\n-- package pre part of version (according to semver)\n--\n-- @param p_pkg_v_metadata\n-- package metadata part of version (according to semver)\n--\n-- @param p_pkg_license\n-- package license name/text\n--\n-- @param p_pkg_deps_ids\n-- IDs of dependent schemas\n--\n-- @param p_pkg_vcs_ref\n-- vcs reference to track the code\n--\n-- @param p_pkg_vcs_link\n-- repository link to track the code\n--\n-- @param p_pkg_issue_ref\n-- issue reference to track the code\n--\n-- @param p_pkg_issue_link\n-- issue tracking system link\n---\nDECLARE\n    l_existing_pkg_id INTEGER;\n    l_pkg_dep_id INTEGER;\n\n\treturn_value INTEGER;\nBEGIN\n\n    -- Case 1: unsafe mode, rewrite of the whole schema with the same version or some of the files in it\n    -- Case 2: new schema with new version (safe or moderate modes)\n\n    IF p_pkg_subclass_name = 'basic' THEN\n        SELECT pkg_id INTO l_existing_pkg_id\n        FROM packages\n        WHERE pkg_name = p_pkg_name\n            AND pkg_subclass IN (SELECT pkg_sc_id\n                                 FROM package_subclasses\n                                 WHERE pkg_sc_name = p_pkg_subclass_name);\n    ELSE\n        SELECT pkg_id INTO l_existing_pkg_id\n        FROM packages\n        WHERE pkg_name = p_pkg_name\n            AND pkg_subclass IN (SELECT pkg_sc_id\n                                 FROM package_subclasses\n                                 WHERE pkg_sc_name = p_pkg_subclass_name)\n            AND pkg_v_major = p_pkg_v_major\n            AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)\n            AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)\n            AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre)\n            AND pkg_old_rev IS NULL;\n    END IF;\n\n    IF FOUND THEN -- Case 1:\n        DELETE FROM package_dependencies\n            WHERE pkg_link_core_id = l_existing_pkg_id;\n\n        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids\n        LOOP\n            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (l_existing_pkg_id, l_pkg_dep_id);\n        END LOOP;\n\n        UPDATE packages\n        SET pkg_name=subquery.p_pkg_name,\n            pkg_subclass=subquery.pkg_sc_id,\n            pkg_v_major=subquery.p_pkg_v_major,\n            pkg_v_minor=subquery.p_pkg_v_minor,\n            pkg_v_patch=subquery.p_pkg_v_patch,\n            pkg_v_pre=subquery.p_pkg_v_pre,\n            pkg_v_metadata=subquery.p_pkg_v_metadata,\n            pkg_description=subquery.p_pkg_description,\n            pkg_license=subquery.p_pkg_license\n        FROM (SELECT\n                  p_pkg_name,\n                  pkg_sc_id,\n                  p_pkg_v_major,\n                  p_pkg_v_minor,\n                  p_pkg_v_patch,\n                  p_pkg_v_pre,\n                  p_pkg_v_metadata,\n                  p_pkg_description,\n                  p_pkg_license\n              FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name\n        ) as subquery\n        WHERE packages.pkg_name=subquery.p_pkg_name;\n\n        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)\n            VALUES (l_existing_pkg_id, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);\n\n        return_value := l_existing_pkg_id;\n    ELSE -- Case 2:\n        INSERT INTO packages (\n            pkg_name,\n            pkg_description,\n            pkg_v_major,\n            pkg_v_minor,\n            pkg_v_patch,\n            pkg_v_pre,\n            pkg_v_metadata,\n            pkg_subclass,\n            pkg_license\n        )\n        SELECT\n            p_pkg_name,\n            p_pkg_description,\n            p_pkg_v_major,\n            p_pkg_v_minor,\n            p_pkg_v_patch,\n            p_pkg_v_pre,\n            p_pkg_v_metadata,\n            pkg_sc_id,\n            p_pkg_license\n        FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name\n        RETURNING\n            pkg_id\n        INTO return_value;\n\n        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids\n        LOOP\n            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (return_value, l_pkg_dep_id);\n        END LOOP;\n\n        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)\n            VALUES (return_value, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);\n\n    END IF;\n\n    -- Notify external channels of successful deployment event\n    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);\n\n    RETURN return_value;\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_alter_schema_owner.sql': u"CREATE OR REPLACE FUNCTION _alter_schema_owner(p_schema TEXT, p_owner TEXT)\n    RETURNS VOID AS\n$BODY$\n---\n-- @description\n-- Alters ownership of schema and all its objects to a specified user.\n--\n-- @param p_schema\n-- Schema name\n--\n-- @param p_owner\n-- New owner user name\n--\n---\nDECLARE\n    l_schema TEXT;\n    l_functions TEXT;\n    l_tables TEXT;\n    l_sequences TEXT;\n    l_views TEXT;\n    l_domains TEXT;\n    l_triggers TEXT;\n    l_types TEXT;\n\nBEGIN\n\n    l_schema := 'ALTER SCHEMA '\n                || quote_ident(p_schema)\n                || ' OWNER TO '\n                || quote_ident(p_owner)\n                || ';';\n\n    SELECT string_agg('ALTER FUNCTION '\n                || quote_ident(n.nspname) || '.'\n                || quote_ident(p.proname) || '('\n                || pg_catalog.pg_get_function_identity_arguments(p.oid)\n                || ') OWNER TO ' || p_owner || ';'\n              , E'\\n') AS _sql\n    FROM   pg_catalog.pg_proc p\n    JOIN   pg_catalog.pg_namespace n ON n.oid = p.pronamespace\n    WHERE  n.nspname = p_schema\n    INTO l_functions;\n    IF l_functions IS NULL THEN\n        l_functions := '';\n    END IF;\n\n    SELECT string_agg('ALTER TABLE ' || quote_ident(schemaname) || '.' || quote_ident(tablename) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM pg_tables WHERE schemaname = p_schema\n    INTO l_tables;\n    IF l_tables IS NULL THEN\n        l_tables := '';\n    END IF;\n\n    SELECT string_agg('ALTER SEQUENCE ' || quote_ident(sequence_schema) || '.' || quote_ident(sequence_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.sequences WHERE sequence_schema = p_schema\n    INTO l_sequences;\n    IF l_sequences IS NULL THEN\n        l_sequences := '';\n    END IF;\n\n    SELECT string_agg('ALTER VIEW ' || quote_ident(table_schema) || '.' || quote_ident(table_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.views WHERE table_schema = p_schema\n    INTO l_views;\n    IF l_views IS NULL THEN\n        l_views := '';\n    END IF;\n\n    SELECT string_agg('ALTER DOMAIN ' || quote_ident(domain_schema) || '.' || quote_ident(domain_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.domains WHERE domain_schema = p_schema\n    INTO l_domains;\n    IF l_domains IS NULL THEN\n        l_domains := '';\n    END IF;\n\n    SELECT string_agg('ALTER TRIGGER ' || quote_ident(trigger_schema) || '.' || quote_ident(trigger_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.triggers WHERE trigger_schema = p_schema\n    INTO l_triggers;\n    IF l_triggers IS NULL THEN\n        l_triggers := '';\n    END IF;\n\n    SELECT string_agg('ALTER TYPE ' || quote_ident(user_defined_type_schema) || '.' || quote_ident(user_defined_type_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.user_defined_types WHERE user_defined_type_schema = p_schema\n    INTO l_types;\n    IF l_types IS NULL THEN\n        l_types := '';\n    END IF;\n\n    EXECUTE l_schema || l_functions || l_tables || l_sequences || l_views || l_domains || l_triggers || l_types;\n\nEND;\n$BODY$\nLANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;", '_log_table_evolution.sql': u"CREATE OR REPLACE FUNCTION _log_table_evolution(p_t_evo_file_name TEXT, p_t_evo_package INTEGER)\n    RETURNS VOID AS\n$BODY$\n---\n-- @description\n-- Adds information about executed table evolution script to log table\n--\n-- @param p_t_evo_file_name\n-- File name with executed statements.\n--\n-- @param p_t_evo_package\n-- Related package id\n--\n-- @param p_pkg_old_rev\n-- higher border of version that is applicaple for this migration\n--\n---\nBEGIN\n\n    INSERT INTO table_evolutions_log (t_evo_file_name, t_evo_package)\n        VALUES (p_t_evo_file_name, p_t_evo_package);\nEND;\n$BODY$\nLANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;", '_is_table_ddl_executed.sql': u"CREATE OR REPLACE FUNCTION _is_table_ddl_executed(p_file_name TEXT)\n    RETURNS BOOLEAN AS\n$BODY$\n---\n-- @description\n-- Checks whether file with table ddl has already been executed\n--\n-- @param p_file_name\n-- File name used to check whether statements were executed\n--\n-- @returns\n-- True if executed, False otherwise\n---\nDECLARE\n    return_value BOOLEAN;\nBEGIN\n\n    SELECT EXISTS (SELECT t_evo_id FROM table_evolutions_log WHERE t_evo_file_name=p_file_name) INTO return_value;\n\n    RETURN return_value;\n\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_set_revision_package.sql': u"CREATE OR REPLACE FUNCTION _set_revision_package(p_pkg_name TEXT,\n                                             p_pkg_subclass_name TEXT,\n                                             p_pkg_old_rev INTEGER,\n                                             p_pkg_v_major INTEGER,\n                                             p_pkg_v_minor INTEGER DEFAULT 0,\n                                             p_pkg_v_patch INTEGER DEFAULT 0,\n                                             p_pkg_v_pre TEXT DEFAULT NULL)\n    RETURNS INTEGER AS\n$BODY$\n---\n-- @description\n-- Set package as old revision, info logged in deployment events table\n--\n-- @param p_pkg_name\n-- package name\n--\n-- @param p_pkg_subclass_name\n-- package type: either version (with version suffix at the end of the name) or basic (without)\n--\n-- @param p_pkg_old_rev\n-- Revision name of package. Used in moderate form. When schema is renamed it is given a revision suffix from here\n--\n-- @param p_pkg_v_major\n-- package major part of version (according to semver)\n--\n-- @param p_pkg_v_minor\n-- package minor part of version (according to semver)\n--\n-- @param p_pkg_v_patch\n-- package patch part of version (according to semver)\n--\n-- @param p_pkg_v_pre\n-- package pre part of version (according to semver)\n--\n-- @param p_pkg_v_metadata\n-- package metadata part of version (according to semver)\n--\n-- @param p_pkg_vcs_ref\n-- vcs reference to track the code\n---\nDECLARE\n    l_existing_pkg_id INTEGER;\n    l_pkg_dep_id INTEGER;\n\n\treturn_value INTEGER;\nBEGIN\n\n    SELECT pkg_id INTO l_existing_pkg_id\n    FROM packages\n    WHERE pkg_name = p_pkg_name\n        AND pkg_subclass IN (SELECT pkg_sc_id\n                             FROM package_subclasses\n                             WHERE pkg_sc_name = p_pkg_subclass_name)\n        AND pkg_v_major = p_pkg_v_major\n        AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)\n        AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)\n        AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre);\n\n    IF FOUND THEN\n        UPDATE packages\n        SET pkg_old_rev=p_pkg_old_rev\n        WHERE packages.pkg_id=l_existing_pkg_id;\n\n        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)\n            SELECT pkg_id, txid_current(), dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link\n            FROM packages\n            JOIN deployment_events ON dpl_ev_pkg_id=pkg_id\n            WHERE pkg_id=l_existing_pkg_id AND dpl_ev_time IN (\n                SELECT max(dpl_ev_time) FROM deployment_events WHERE dpl_ev_pkg_id=packages.pkg_id\n            );\n    ELSE\n        RAISE EXCEPTION 'Package % not found in the list of packages. It could happen if schema exists but wasn''t properly deployed with pgpm', p_pkg_name || '_' || p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch;\n    END IF;\n\n    -- Notify external channels of successful deployment event\n    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);\n\n    RETURN return_value;\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n"}
2015-12-10 16:41:20,277 - pgpm.app - DEBUG - Executing query: set search_path TO _pgpm, public;
2015-12-10 16:41:20,281 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _log_ddl_change()
    RETURNS EVENT_TRIGGER AS
$BODY$
---
-- @description
-- Logs any DDL changes to the DB
--
---
DECLARE
    l_current_query TEXT;
    l_txid BIGINT;
BEGIN

    SELECT current_query() INTO l_current_query;
    SELECT txid_current() INTO l_txid;
    INSERT INTO _pgpm.ddl_changes_log (ddl_change)
    SELECT l_current_query
    WHERE
        NOT EXISTS (
            SELECT ddl_change_txid, ddl_change FROM _pgpm.ddl_changes_log
            WHERE ddl_change_txid = l_txid AND ddl_change = l_current_query
        );

    -- Notify external channels of ddl change
    PERFORM pg_notify('ddl_change', "session_user"());

END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;
2015-12-10 16:41:20,281 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _add_migration_info(p_m_low_v TEXT, p_m_high_v TEXT)
    RETURNS VOID AS
$BODY$
---
-- @description
-- Adds migration info migrations log table
--
-- @param p_m_low_v
-- lower border of version that is applicaple for this migration
--
-- @param p_m_high_v
-- package type: either version (with version suffix at the end of the name) or basic (without)
--
-- @param p_pkg_old_rev
-- higher border of version that is applicaple for this migration
--
---
BEGIN

    BEGIN
        INSERT INTO migrations_log (m_low_v, m_high_v)
            VALUES (p_m_low_v, p_m_high_v);
    EXCEPTION
        WHEN SQLSTATE '42P01' THEN
            RAISE WARNING 'Can''t log migration from % to % as migrations_log is not defined yet', p_m_low_v, p_m_high_v;
    END;
END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 16:41:20,282 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION set_search_path(p_schema_name TEXT, p_v_req TEXT)
    RETURNS json AS
$BODY$
---
-- @description
-- Sets search path that includes also all depending
--
-- @param p_schema_name
-- Package (schema) name
--
-- @param p_v_req
-- Package version requirement. Version notation supports:
-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)
-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x
-- - comparison operators like >01_02_03 or <2
-- - x for any latest version of package
-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency
--
-- @returns
-- JSON with schema names and exact versions or exception if not found
---
DECLARE
    l_search_path TEXT;
    l_search_path_deps TEXT;
    l_listen_text TEXT;

    l_pkg_version_wrapped RECORD;
    l_pkg_version RECORD;

    return_value json;
BEGIN

    SET search_path TO _pgpm;
    SELECT _find_schema(p_schema_name, p_v_req) AS version INTO l_pkg_version_wrapped;
    l_pkg_version := l_pkg_version_wrapped.version;

    l_search_path := l_pkg_version.pkg_name || '_' ||
                     l_pkg_version.pkg_v_major::text || '_' ||
                     l_pkg_version.pkg_v_minor::text || '_' ||
                     l_pkg_version.pkg_v_patch::text;

    SELECT string_agg(pkg_name || '_' || pkg_v_major || '_' || pkg_v_minor || '_' || pkg_v_patch, ', ')
    FROM packages
    WHERE pkg_id IN (
        SELECT pkg_link_dep_id from package_dependencies
        JOIN packages ON pkg_id = l_pkg_version.pkg_id
        WHERE pkg_link_core_id = pkg_id
    )
    INTO l_search_path_deps;

    l_search_path := l_search_path || ', ' || l_search_path_deps;

    l_listen_text := 'deployment_events' || '$$' || l_pkg_version.pkg_name;
    EXECUTE 'LISTEN ' || l_listen_text;

    RAISE INFO '%', l_search_path;
    PERFORM set_config('search_path', l_search_path || ', public', false);

    return_value := row_to_json(l_pkg_version);
    RETURN return_value;

END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 16:41:20,284 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _find_schema(p_schema_name TEXT, p_v_req TEXT)
    RETURNS RECORD AS
$BODY$
---
-- @description
-- Searches for existing schema (package) within registered packages in _pgpm schema
--
-- @param p_schema_name
-- Package (schema) name
--
-- @param p_v_req
-- Package version requirement. Version notation supports:
-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)
-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x
-- - comparison operators like >01_02_03 or <2
-- - x for any latest version of package
-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency
--
-- @returns
-- Record containing schema name and exact version or exception if not found in the following format:
-- pkg_name TEXT, pkg_v_major INTEGER, pkg_v_minor INTEGER, pkg_v_patch INTEGER
---
DECLARE
    c_re_version TEXT = '^(<=|>=|<|>{0,2})(\d*|x*)_?(\d*|x*)_?(\d*|x*)';
    l_v_matches TEXT[];

    l_v_major INTEGER;
    l_v_minor INTEGER;
    l_v_patch INTEGER;

    return_value RECORD;
BEGIN

    SELECT regexp_matches(p_v_req, c_re_version, 'gi') INTO l_v_matches;

    IF l_v_matches[2] ~* '^x+|^$' THEN
        SELECT max(pkg_v_major)
        FROM packages
        WHERE pkg_name = p_schema_name
        INTO l_v_major;
    ELSE
        l_v_major := l_v_matches[2]::integer;
    END IF;

    IF l_v_matches[3] ~* '^x+|^$' THEN
        SELECT max(pkg_v_minor)
        FROM packages
        WHERE pkg_name = p_schema_name
              AND pkg_v_major = l_v_major
        INTO l_v_minor;
    ELSE
        l_v_minor := l_v_matches[3]::integer;
    END IF;

    IF l_v_matches[4] ~* '^x+|^$' THEN
        SELECT max(pkg_v_patch)
        FROM packages
        WHERE pkg_name = p_schema_name
              AND pkg_v_major = l_v_major
              AND pkg_v_minor = l_v_minor
        INTO l_v_patch;
    ELSE
        l_v_patch := l_v_matches[4]::integer;
    END IF;

    CASE l_v_matches[1]
        WHEN '=', '' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND pkg_v_major = l_v_major
                  AND pkg_v_minor = l_v_minor
                  AND pkg_v_patch = l_v_patch
            INTO return_value;
        WHEN '<' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major < l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor < l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch < l_v_patch))
            INTO return_value;
        WHEN '>' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major > l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor > l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch > l_v_patch))
            INTO return_value;
        WHEN '<=' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major <= l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor <= l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch <= l_v_patch))
            INTO return_value;
        WHEN '>=' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major >= l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor >= l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch >= l_v_patch))
            INTO return_value;
        ELSE
            RAISE EXCEPTION 'Invalid logical operand. Only <, >, =, <=, >=, = or no operand are allowed.' USING ERRCODE = '20000';
    END CASE;

    RETURN return_value;

END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 16:41:20,286 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _upsert_package_info(p_pkg_name TEXT,
                                             p_pkg_subclass_name TEXT,
                                             p_pkg_v_major INTEGER,
                                             p_pkg_v_minor INTEGER DEFAULT 0,
                                             p_pkg_v_patch INTEGER DEFAULT 0,
                                             p_pkg_v_pre TEXT DEFAULT NULL,
                                             p_pkg_v_metadata TEXT DEFAULT NULL,
                                             p_pkg_description TEXT DEFAULT '',
                                             p_pkg_license TEXT DEFAULT NULL,
                                             p_pkg_deps_ids INTEGER[] DEFAULT '{}',
                                             p_pkg_vcs_ref TEXT DEFAULT NULL,
                                             p_pkg_vcs_link TEXT DEFAULT NULL,
                                             p_pkg_issue_ref TEXT DEFAULT NULL,
                                             p_pkg_issue_link TEXT DEFAULT NULL)
    RETURNS INTEGER AS
$BODY$
---
-- @description
-- Adds package info to pgpm package info table, deployment events table and notifies channels of deployment
--
-- @param p_pkg_name
-- package name
--
-- @param p_pkg_subclass_name
-- package type: either version (with version suffix at the end of the name) or basic (without)
--
-- @param p_pkg_description
-- package description
--
-- @param p_pkg_v_major
-- package major part of version (according to semver)
--
-- @param p_pkg_v_minor
-- package minor part of version (according to semver)
--
-- @param p_pkg_v_patch
-- package patch part of version (according to semver)
--
-- @param p_pkg_v_pre
-- package pre part of version (according to semver)
--
-- @param p_pkg_v_metadata
-- package metadata part of version (according to semver)
--
-- @param p_pkg_license
-- package license name/text
--
-- @param p_pkg_deps_ids
-- IDs of dependent schemas
--
-- @param p_pkg_vcs_ref
-- vcs reference to track the code
--
-- @param p_pkg_vcs_link
-- repository link to track the code
--
-- @param p_pkg_issue_ref
-- issue reference to track the code
--
-- @param p_pkg_issue_link
-- issue tracking system link
---
DECLARE
    l_existing_pkg_id INTEGER;
    l_pkg_dep_id INTEGER;

	return_value INTEGER;
BEGIN

    -- Case 1: unsafe mode, rewrite of the whole schema with the same version or some of the files in it
    -- Case 2: new schema with new version (safe or moderate modes)

    IF p_pkg_subclass_name = 'basic' THEN
        SELECT pkg_id INTO l_existing_pkg_id
        FROM packages
        WHERE pkg_name = p_pkg_name
            AND pkg_subclass IN (SELECT pkg_sc_id
                                 FROM package_subclasses
                                 WHERE pkg_sc_name = p_pkg_subclass_name);
    ELSE
        SELECT pkg_id INTO l_existing_pkg_id
        FROM packages
        WHERE pkg_name = p_pkg_name
            AND pkg_subclass IN (SELECT pkg_sc_id
                                 FROM package_subclasses
                                 WHERE pkg_sc_name = p_pkg_subclass_name)
            AND pkg_v_major = p_pkg_v_major
            AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)
            AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)
            AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre)
            AND pkg_old_rev IS NULL;
    END IF;

    IF FOUND THEN -- Case 1:
        DELETE FROM package_dependencies
            WHERE pkg_link_core_id = l_existing_pkg_id;

        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids
        LOOP
            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (l_existing_pkg_id, l_pkg_dep_id);
        END LOOP;

        UPDATE packages
        SET pkg_name=subquery.p_pkg_name,
            pkg_subclass=subquery.pkg_sc_id,
            pkg_v_major=subquery.p_pkg_v_major,
            pkg_v_minor=subquery.p_pkg_v_minor,
            pkg_v_patch=subquery.p_pkg_v_patch,
            pkg_v_pre=subquery.p_pkg_v_pre,
            pkg_v_metadata=subquery.p_pkg_v_metadata,
            pkg_description=subquery.p_pkg_description,
            pkg_license=subquery.p_pkg_license
        FROM (SELECT
                  p_pkg_name,
                  pkg_sc_id,
                  p_pkg_v_major,
                  p_pkg_v_minor,
                  p_pkg_v_patch,
                  p_pkg_v_pre,
                  p_pkg_v_metadata,
                  p_pkg_description,
                  p_pkg_license
              FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name
        ) as subquery
        WHERE packages.pkg_name=subquery.p_pkg_name;

        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)
            VALUES (l_existing_pkg_id, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);

        return_value := l_existing_pkg_id;
    ELSE -- Case 2:
        INSERT INTO packages (
            pkg_name,
            pkg_description,
            pkg_v_major,
            pkg_v_minor,
            pkg_v_patch,
            pkg_v_pre,
            pkg_v_metadata,
            pkg_subclass,
            pkg_license
        )
        SELECT
            p_pkg_name,
            p_pkg_description,
            p_pkg_v_major,
            p_pkg_v_minor,
            p_pkg_v_patch,
            p_pkg_v_pre,
            p_pkg_v_metadata,
            pkg_sc_id,
            p_pkg_license
        FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name
        RETURNING
            pkg_id
        INTO return_value;

        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids
        LOOP
            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (return_value, l_pkg_dep_id);
        END LOOP;

        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)
            VALUES (return_value, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);

    END IF;

    -- Notify external channels of successful deployment event
    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);

    RETURN return_value;
END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 16:41:20,287 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _alter_schema_owner(p_schema TEXT, p_owner TEXT)
    RETURNS VOID AS
$BODY$
---
-- @description
-- Alters ownership of schema and all its objects to a specified user.
--
-- @param p_schema
-- Schema name
--
-- @param p_owner
-- New owner user name
--
---
DECLARE
    l_schema TEXT;
    l_functions TEXT;
    l_tables TEXT;
    l_sequences TEXT;
    l_views TEXT;
    l_domains TEXT;
    l_triggers TEXT;
    l_types TEXT;

BEGIN

    l_schema := 'ALTER SCHEMA '
                || quote_ident(p_schema)
                || ' OWNER TO '
                || quote_ident(p_owner)
                || ';';

    SELECT string_agg('ALTER FUNCTION '
                || quote_ident(n.nspname) || '.'
                || quote_ident(p.proname) || '('
                || pg_catalog.pg_get_function_identity_arguments(p.oid)
                || ') OWNER TO ' || p_owner || ';'
              , E'\n') AS _sql
    FROM   pg_catalog.pg_proc p
    JOIN   pg_catalog.pg_namespace n ON n.oid = p.pronamespace
    WHERE  n.nspname = p_schema
    INTO l_functions;
    IF l_functions IS NULL THEN
        l_functions := '';
    END IF;

    SELECT string_agg('ALTER TABLE ' || quote_ident(schemaname) || '.' || quote_ident(tablename) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM pg_tables WHERE schemaname = p_schema
    INTO l_tables;
    IF l_tables IS NULL THEN
        l_tables := '';
    END IF;

    SELECT string_agg('ALTER SEQUENCE ' || quote_ident(sequence_schema) || '.' || quote_ident(sequence_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.sequences WHERE sequence_schema = p_schema
    INTO l_sequences;
    IF l_sequences IS NULL THEN
        l_sequences := '';
    END IF;

    SELECT string_agg('ALTER VIEW ' || quote_ident(table_schema) || '.' || quote_ident(table_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.views WHERE table_schema = p_schema
    INTO l_views;
    IF l_views IS NULL THEN
        l_views := '';
    END IF;

    SELECT string_agg('ALTER DOMAIN ' || quote_ident(domain_schema) || '.' || quote_ident(domain_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.domains WHERE domain_schema = p_schema
    INTO l_domains;
    IF l_domains IS NULL THEN
        l_domains := '';
    END IF;

    SELECT string_agg('ALTER TRIGGER ' || quote_ident(trigger_schema) || '.' || quote_ident(trigger_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.triggers WHERE trigger_schema = p_schema
    INTO l_triggers;
    IF l_triggers IS NULL THEN
        l_triggers := '';
    END IF;

    SELECT string_agg('ALTER TYPE ' || quote_ident(user_defined_type_schema) || '.' || quote_ident(user_defined_type_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.user_defined_types WHERE user_defined_type_schema = p_schema
    INTO l_types;
    IF l_types IS NULL THEN
        l_types := '';
    END IF;

    EXECUTE l_schema || l_functions || l_tables || l_sequences || l_views || l_domains || l_triggers || l_types;

END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;
2015-12-10 16:41:20,288 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _log_table_evolution(p_t_evo_file_name TEXT, p_t_evo_package INTEGER)
    RETURNS VOID AS
$BODY$
---
-- @description
-- Adds information about executed table evolution script to log table
--
-- @param p_t_evo_file_name
-- File name with executed statements.
--
-- @param p_t_evo_package
-- Related package id
--
-- @param p_pkg_old_rev
-- higher border of version that is applicaple for this migration
--
---
BEGIN

    INSERT INTO table_evolutions_log (t_evo_file_name, t_evo_package)
        VALUES (p_t_evo_file_name, p_t_evo_package);
END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;
2015-12-10 16:41:20,288 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _is_table_ddl_executed(p_file_name TEXT)
    RETURNS BOOLEAN AS
$BODY$
---
-- @description
-- Checks whether file with table ddl has already been executed
--
-- @param p_file_name
-- File name used to check whether statements were executed
--
-- @returns
-- True if executed, False otherwise
---
DECLARE
    return_value BOOLEAN;
BEGIN

    SELECT EXISTS (SELECT t_evo_id FROM table_evolutions_log WHERE t_evo_file_name=p_file_name) INTO return_value;

    RETURN return_value;

END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 16:41:20,289 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _set_revision_package(p_pkg_name TEXT,
                                             p_pkg_subclass_name TEXT,
                                             p_pkg_old_rev INTEGER,
                                             p_pkg_v_major INTEGER,
                                             p_pkg_v_minor INTEGER DEFAULT 0,
                                             p_pkg_v_patch INTEGER DEFAULT 0,
                                             p_pkg_v_pre TEXT DEFAULT NULL)
    RETURNS INTEGER AS
$BODY$
---
-- @description
-- Set package as old revision, info logged in deployment events table
--
-- @param p_pkg_name
-- package name
--
-- @param p_pkg_subclass_name
-- package type: either version (with version suffix at the end of the name) or basic (without)
--
-- @param p_pkg_old_rev
-- Revision name of package. Used in moderate form. When schema is renamed it is given a revision suffix from here
--
-- @param p_pkg_v_major
-- package major part of version (according to semver)
--
-- @param p_pkg_v_minor
-- package minor part of version (according to semver)
--
-- @param p_pkg_v_patch
-- package patch part of version (according to semver)
--
-- @param p_pkg_v_pre
-- package pre part of version (according to semver)
--
-- @param p_pkg_v_metadata
-- package metadata part of version (according to semver)
--
-- @param p_pkg_vcs_ref
-- vcs reference to track the code
---
DECLARE
    l_existing_pkg_id INTEGER;
    l_pkg_dep_id INTEGER;

	return_value INTEGER;
BEGIN

    SELECT pkg_id INTO l_existing_pkg_id
    FROM packages
    WHERE pkg_name = p_pkg_name
        AND pkg_subclass IN (SELECT pkg_sc_id
                             FROM package_subclasses
                             WHERE pkg_sc_name = p_pkg_subclass_name)
        AND pkg_v_major = p_pkg_v_major
        AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)
        AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)
        AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre);

    IF FOUND THEN
        UPDATE packages
        SET pkg_old_rev=p_pkg_old_rev
        WHERE packages.pkg_id=l_existing_pkg_id;

        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)
            SELECT pkg_id, txid_current(), dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link
            FROM packages
            JOIN deployment_events ON dpl_ev_pkg_id=pkg_id
            WHERE pkg_id=l_existing_pkg_id AND dpl_ev_time IN (
                SELECT max(dpl_ev_time) FROM deployment_events WHERE dpl_ev_pkg_id=packages.pkg_id
            );
    ELSE
        RAISE EXCEPTION 'Package % not found in the list of packages. It could happen if schema exists but wasn''t properly deployed with pgpm', p_pkg_name || '_' || p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch;
    END IF;

    -- Notify external channels of successful deployment event
    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);

    RETURN return_value;
END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 16:41:20,290 - pgpm.app - DEBUG - Functions loaded to schema _pgpm
2015-12-10 16:41:20,290 - pgpm.app - DEBUG - Executing query: set search_path TO _pgpm, public;
2015-12-10 16:41:20,294 - pgpm.app - DEBUG - Executing query: SELECT _find_schema('_pgpm', 'x')
2015-12-10 16:41:20,294 - pgpm.app - ERROR - Can't install pgpm as schema _pgpm already exists
2015-12-10 16:41:20,294 - pgpm.app - DEBUG - Closing connection to host=localhost port=5432 dbname=pgpm_test_1 user=apanchoyan...
2015-12-10 16:41:20,294 - pgpm.app - DEBUG - Connection to host=localhost port=5432 dbname=pgpm_test_1 user=apanchoyan closed.
2015-12-10 16:41:26,181 - pgpm.app - INFO - Uninstalling pgpm... host=localhost port=5432 dbname=pgpm_test_1 user=apanchoyan
2015-12-10 16:41:26,187 - pgpm.app - DEBUG - Executing query: select * from CURRENT_USER;
2015-12-10 16:41:26,189 - pgpm.app - DEBUG - Executing query: select usesuper from pg_user where usename = CURRENT_USER;
2015-12-10 16:41:26,189 - pgpm.app - DEBUG - Removing pgpm from DB by dropping schema _pgpm
2015-12-10 16:41:26,201 - pgpm.app - DEBUG - Executing query: DROP SCHEMA _pgpm CASCADE;
2015-12-10 16:41:26,201 - pgpm.app - DEBUG - NOTICE:  drop cascades to 18 other objects
DETAIL:  drop cascades to table _pgpm.package_subclasses
drop cascades to table _pgpm.packages
drop cascades to table _pgpm.package_dependencies
drop cascades to table _pgpm.deployment_events
drop cascades to table _pgpm.migrations_log
drop cascades to table _pgpm.package_statuses
drop cascades to table _pgpm.ddl_changes_log
drop cascades to table _pgpm.table_evolutions_log
drop cascades to function _pgpm._log_ddl_change()
drop cascades to event trigger ddl_change_trigger
drop cascades to function _pgpm._add_migration_info(text,text)
drop cascades to function _pgpm.set_search_path(text,text)
drop cascades to function _pgpm._find_schema(text,text)
drop cascades to function _pgpm._upsert_package_info(text,text,integer,integer,integer,text,text,text,text,integer[],text,text,text,text)
drop cascades to function _pgpm._alter_schema_owner(text,text)
drop cascades to function _pgpm._log_table_evolution(text,integer)
drop cascades to function _pgpm._is_table_ddl_executed(text)
drop cascades to function _pgpm._set_revision_package(text,text,integer,integer,integer,integer,text)

2015-12-10 16:41:26,205 - pgpm.app - DEBUG - Closing connection to host=localhost port=5432 dbname=pgpm_test_1 user=apanchoyan...
2015-12-10 16:41:26,205 - pgpm.app - DEBUG - Connection to host=localhost port=5432 dbname=pgpm_test_1 user=apanchoyan closed.
2015-12-10 16:41:26,205 - pgpm.app - INFO - Successfully uninstalled pgpm from host=localhost port=5432 dbname=pgpm_test_1 user=apanchoyan
2015-12-10 16:41:26,205 - pgpm.app - INFO - Uninstalling pgpm... host=localhost port=5432 dbname=pgpm_test_2 user=apanchoyan
2015-12-10 16:41:26,211 - pgpm.app - DEBUG - Executing query: select * from CURRENT_USER;
2015-12-10 16:41:26,212 - pgpm.app - DEBUG - Executing query: select usesuper from pg_user where usename = CURRENT_USER;
2015-12-10 16:41:26,212 - pgpm.app - DEBUG - Removing pgpm from DB by dropping schema _pgpm
2015-12-10 16:41:26,227 - pgpm.app - DEBUG - Executing query: DROP SCHEMA _pgpm CASCADE;
2015-12-10 16:41:26,227 - pgpm.app - DEBUG - NOTICE:  drop cascades to 18 other objects
DETAIL:  drop cascades to table _pgpm.package_subclasses
drop cascades to table _pgpm.packages
drop cascades to table _pgpm.package_dependencies
drop cascades to function _pgpm._log_ddl_change()
drop cascades to event trigger ddl_change_trigger
drop cascades to function _pgpm._add_migration_info(text,text)
drop cascades to function _pgpm.set_search_path(text,text)
drop cascades to function _pgpm._find_schema(text,text)
drop cascades to function _pgpm._upsert_package_info(text,text,integer,integer,integer,text,text,text,text,integer[],text,text,text,text)
drop cascades to function _pgpm._alter_schema_owner(text,text)
drop cascades to function _pgpm._log_table_evolution(text,integer)
drop cascades to function _pgpm._is_table_ddl_executed(text)
drop cascades to function _pgpm._set_revision_package(text,text,integer,integer,integer,integer,text)
drop cascades to table _pgpm.deployment_events
drop cascades to table _pgpm.migrations_log
drop cascades to table _pgpm.package_statuses
drop cascades to table _pgpm.ddl_changes_log
drop cascades to table _pgpm.table_evolutions_log

2015-12-10 16:41:26,230 - pgpm.app - DEBUG - Closing connection to host=localhost port=5432 dbname=pgpm_test_2 user=apanchoyan...
2015-12-10 16:41:26,230 - pgpm.app - DEBUG - Connection to host=localhost port=5432 dbname=pgpm_test_2 user=apanchoyan closed.
2015-12-10 16:41:26,230 - pgpm.app - INFO - Successfully uninstalled pgpm from host=localhost port=5432 dbname=pgpm_test_2 user=apanchoyan
2015-12-10 16:41:26,230 - pgpm.app - INFO - Uninstalling pgpm... host=localhost port=5432 dbname=pgpm_test_3 user=apanchoyan
2015-12-10 16:41:26,234 - pgpm.app - DEBUG - Executing query: select * from CURRENT_USER;
2015-12-10 16:41:26,235 - pgpm.app - DEBUG - Executing query: select usesuper from pg_user where usename = CURRENT_USER;
2015-12-10 16:41:26,235 - pgpm.app - DEBUG - Removing pgpm from DB by dropping schema _pgpm
2015-12-10 16:41:26,250 - pgpm.app - DEBUG - Executing query: DROP SCHEMA _pgpm CASCADE;
2015-12-10 16:41:26,250 - pgpm.app - DEBUG - NOTICE:  drop cascades to 18 other objects
DETAIL:  drop cascades to table _pgpm.package_subclasses
drop cascades to table _pgpm.packages
drop cascades to table _pgpm.package_dependencies
drop cascades to function _pgpm._log_ddl_change()
drop cascades to event trigger ddl_change_trigger
drop cascades to function _pgpm._add_migration_info(text,text)
drop cascades to function _pgpm.set_search_path(text,text)
drop cascades to function _pgpm._find_schema(text,text)
drop cascades to function _pgpm._upsert_package_info(text,text,integer,integer,integer,text,text,text,text,integer[],text,text,text,text)
drop cascades to function _pgpm._alter_schema_owner(text,text)
drop cascades to function _pgpm._log_table_evolution(text,integer)
drop cascades to function _pgpm._is_table_ddl_executed(text)
drop cascades to function _pgpm._set_revision_package(text,text,integer,integer,integer,integer,text)
drop cascades to table _pgpm.deployment_events
drop cascades to table _pgpm.migrations_log
drop cascades to table _pgpm.package_statuses
drop cascades to table _pgpm.ddl_changes_log
drop cascades to table _pgpm.table_evolutions_log

2015-12-10 16:41:26,256 - pgpm.app - DEBUG - Closing connection to host=localhost port=5432 dbname=pgpm_test_3 user=apanchoyan...
2015-12-10 16:41:26,256 - pgpm.app - DEBUG - Connection to host=localhost port=5432 dbname=pgpm_test_3 user=apanchoyan closed.
2015-12-10 16:41:26,256 - pgpm.app - INFO - Successfully uninstalled pgpm from host=localhost port=5432 dbname=pgpm_test_3 user=apanchoyan
2015-12-10 17:13:16,837 - pgpm.app - INFO - Uninstalling pgpm... host=localhost port=5432 dbname=pgpm_test_1 user=apanchoyan
2015-12-10 17:13:16,845 - pgpm.app - DEBUG - Executing query: select * from CURRENT_USER;
2015-12-10 17:13:16,846 - pgpm.app - DEBUG - Executing query: select usesuper from pg_user where usename = CURRENT_USER;
2015-12-10 17:13:16,846 - pgpm.app - DEBUG - Removing pgpm from DB by dropping schema _pgpm
2015-12-10 17:13:16,858 - pgpm.app - DEBUG - Executing query: DROP SCHEMA _pgpm CASCADE;
2015-12-10 17:13:16,858 - pgpm.app - DEBUG - NOTICE:  drop cascades to 18 other objects
DETAIL:  drop cascades to table _pgpm.package_subclasses
drop cascades to table _pgpm.packages
drop cascades to table _pgpm.package_dependencies
drop cascades to table _pgpm.deployment_events
drop cascades to table _pgpm.migrations_log
drop cascades to table _pgpm.package_statuses
drop cascades to table _pgpm.ddl_changes_log
drop cascades to table _pgpm.table_evolutions_log
drop cascades to function _pgpm._alter_schema_owner(text,text)
drop cascades to function _pgpm._upsert_package_info(text,text,integer,integer,integer,text,text,text,text,integer[],text,text,text,text)
drop cascades to function _pgpm._log_table_evolution(text,integer)
drop cascades to function _pgpm._log_ddl_change()
drop cascades to event trigger ddl_change_trigger
drop cascades to function _pgpm._add_migration_info(text,text)
drop cascades to function _pgpm._set_revision_package(text,text,integer,integer,integer,integer,text)
drop cascades to function _pgpm._find_schema(text,text)
drop cascades to function _pgpm._is_table_ddl_executed(text)
drop cascades to function _pgpm.set_search_path(text,text)

2015-12-10 17:13:16,861 - pgpm.app - DEBUG - Closing connection to host=localhost port=5432 dbname=pgpm_test_1 user=apanchoyan...
2015-12-10 17:13:16,862 - pgpm.app - DEBUG - Connection to host=localhost port=5432 dbname=pgpm_test_1 user=apanchoyan closed.
2015-12-10 17:13:16,862 - pgpm.app - INFO - Successfully uninstalled pgpm from host=localhost port=5432 dbname=pgpm_test_1 user=apanchoyan
2015-12-10 17:13:16,862 - pgpm.app - INFO - Uninstalling pgpm... host=localhost port=5432 dbname=pgpm_test_2 user=apanchoyan
2015-12-10 17:13:16,869 - pgpm.app - DEBUG - Executing query: select * from CURRENT_USER;
2015-12-10 17:13:16,870 - pgpm.app - DEBUG - Executing query: select usesuper from pg_user where usename = CURRENT_USER;
2015-12-10 17:13:16,871 - pgpm.app - DEBUG - Removing pgpm from DB by dropping schema _pgpm
2015-12-10 17:13:16,885 - pgpm.app - DEBUG - Executing query: DROP SCHEMA _pgpm CASCADE;
2015-12-10 17:13:16,885 - pgpm.app - DEBUG - NOTICE:  drop cascades to 18 other objects
DETAIL:  drop cascades to table _pgpm.package_subclasses
drop cascades to table _pgpm.packages
drop cascades to table _pgpm.package_dependencies
drop cascades to function _pgpm._is_table_ddl_executed(text)
drop cascades to function _pgpm._log_table_evolution(text,integer)
drop cascades to function _pgpm._add_migration_info(text,text)
drop cascades to function _pgpm.set_search_path(text,text)
drop cascades to function _pgpm._set_revision_package(text,text,integer,integer,integer,integer,text)
drop cascades to function _pgpm._find_schema(text,text)
drop cascades to function _pgpm._alter_schema_owner(text,text)
drop cascades to function _pgpm._log_ddl_change()
drop cascades to event trigger ddl_change_trigger
drop cascades to function _pgpm._upsert_package_info(text,text,integer,integer,integer,text,text,text,text,integer[],text,text,text,text)
drop cascades to table _pgpm.deployment_events
drop cascades to table _pgpm.migrations_log
drop cascades to table _pgpm.package_statuses
drop cascades to table _pgpm.ddl_changes_log
drop cascades to table _pgpm.table_evolutions_log

2015-12-10 17:13:16,888 - pgpm.app - DEBUG - Closing connection to host=localhost port=5432 dbname=pgpm_test_2 user=apanchoyan...
2015-12-10 17:13:16,888 - pgpm.app - DEBUG - Connection to host=localhost port=5432 dbname=pgpm_test_2 user=apanchoyan closed.
2015-12-10 17:13:16,888 - pgpm.app - INFO - Successfully uninstalled pgpm from host=localhost port=5432 dbname=pgpm_test_2 user=apanchoyan
2015-12-10 17:13:16,888 - pgpm.app - INFO - Uninstalling pgpm... host=localhost port=5432 dbname=pgpm_test_3 user=apanchoyan
2015-12-10 17:13:16,892 - pgpm.app - DEBUG - Executing query: select * from CURRENT_USER;
2015-12-10 17:13:16,894 - pgpm.app - DEBUG - Executing query: select usesuper from pg_user where usename = CURRENT_USER;
2015-12-10 17:13:16,894 - pgpm.app - DEBUG - Removing pgpm from DB by dropping schema _pgpm
2015-12-10 17:13:16,909 - pgpm.app - DEBUG - Executing query: DROP SCHEMA _pgpm CASCADE;
2015-12-10 17:13:16,909 - pgpm.app - DEBUG - NOTICE:  drop cascades to 18 other objects
DETAIL:  drop cascades to table _pgpm.package_subclasses
drop cascades to table _pgpm.packages
drop cascades to table _pgpm.package_dependencies
drop cascades to function _pgpm._is_table_ddl_executed(text)
drop cascades to function _pgpm._log_table_evolution(text,integer)
drop cascades to function _pgpm._add_migration_info(text,text)
drop cascades to function _pgpm.set_search_path(text,text)
drop cascades to function _pgpm._set_revision_package(text,text,integer,integer,integer,integer,text)
drop cascades to function _pgpm._find_schema(text,text)
drop cascades to function _pgpm._alter_schema_owner(text,text)
drop cascades to function _pgpm._log_ddl_change()
drop cascades to event trigger ddl_change_trigger
drop cascades to function _pgpm._upsert_package_info(text,text,integer,integer,integer,text,text,text,text,integer[],text,text,text,text)
drop cascades to table _pgpm.deployment_events
drop cascades to table _pgpm.migrations_log
drop cascades to table _pgpm.package_statuses
drop cascades to table _pgpm.ddl_changes_log
drop cascades to table _pgpm.table_evolutions_log

2015-12-10 17:13:16,914 - pgpm.app - DEBUG - Closing connection to host=localhost port=5432 dbname=pgpm_test_3 user=apanchoyan...
2015-12-10 17:13:16,914 - pgpm.app - DEBUG - Connection to host=localhost port=5432 dbname=pgpm_test_3 user=apanchoyan closed.
2015-12-10 17:13:16,914 - pgpm.app - INFO - Successfully uninstalled pgpm from host=localhost port=5432 dbname=pgpm_test_3 user=apanchoyan
2015-12-10 17:13:18,775 - pgpm.app - INFO - Installing... host=localhost port=5432 dbname=pgpm_test_1 user=apanchoyan
2015-12-10 17:13:18,781 - pgpm.app - DEBUG - lib/db_scripts/functions/_add_migration_info.sql
2015-12-10 17:13:18,781 - pgpm.app - DEBUG - lib/db_scripts/functions/_alter_schema_owner.sql
2015-12-10 17:13:18,781 - pgpm.app - DEBUG - lib/db_scripts/functions/_find_schema.sql
2015-12-10 17:13:18,781 - pgpm.app - DEBUG - lib/db_scripts/functions/_is_table_ddl_executed.sql
2015-12-10 17:13:18,781 - pgpm.app - DEBUG - lib/db_scripts/functions/_log_ddl_change.sql
2015-12-10 17:13:18,781 - pgpm.app - DEBUG - lib/db_scripts/functions/_log_table_evolution.sql
2015-12-10 17:13:18,781 - pgpm.app - DEBUG - lib/db_scripts/functions/_set_revision_package.sql
2015-12-10 17:13:18,782 - pgpm.app - DEBUG - lib/db_scripts/functions/_upsert_package_info.sql
2015-12-10 17:13:18,782 - pgpm.app - DEBUG - lib/db_scripts/functions/set_search_path.sql
2015-12-10 17:13:18,783 - pgpm.app - DEBUG - Executing query: select * from CURRENT_USER;
2015-12-10 17:13:18,784 - pgpm.app - DEBUG - Executing query: select usesuper from pg_user where usename = CURRENT_USER;
2015-12-10 17:13:18,786 - pgpm.app - DEBUG - Executing query: SELECT EXISTS (SELECT schema_name FROM information_schema.schemata WHERE schema_name = '_pgpm');
2015-12-10 17:13:18,786 - pgpm.app - INFO - Executing a preamble to install statement
2015-12-10 17:13:18,786 - pgpm.app - DEBUG - Executing query: -- Preparation SET statements for deployment
SET statement_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = off;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET escape_string_warning = off;
2015-12-10 17:13:18,787 - pgpm.app - INFO - Installing package manager
2015-12-10 17:13:18,805 - pgpm.app - DEBUG - Executing query: DO
$$BEGIN
    CREATE SCHEMA _pgpm;
    SET search_path TO _pgpm, public;

    CREATE TABLE package_subclasses
    (
        pkg_sc_id SERIAL NOT NULL,
        pkg_sc_name TEXT,
        pkg_sc_created TIMESTAMP DEFAULT now(),
        pkg_sc_last_modified TIMESTAMP DEFAULT now(),
        CONSTRAINT package_subclass_pkey PRIMARY KEY (pkg_sc_id)
    );
    INSERT INTO package_subclasses (pkg_sc_name)
        VALUES ('versioned');
    INSERT INTO package_subclasses (pkg_sc_name)
        VALUES ('basic');

    -- info on packages
    CREATE TABLE packages
    (
        pkg_id serial NOT NULL,
        pkg_name character varying(255),
        pkg_description text,
        pkg_v_major integer,
        pkg_v_minor integer,
        pkg_v_patch integer,
        pkg_v_pre character varying(255),
        pkg_v_metadata character varying(255),
        pkg_old_rev integer,
        pkg_vcs_ref varchar(255),
        pkg_subclass integer,
        pkg_license text,
        pkg_created timestamp without time zone DEFAULT now(),
        pkg_last_modified timestamp without time zone DEFAULT statement_timestamp(),
        CONSTRAINT package_pkey PRIMARY KEY (pkg_id),
        CONSTRAINT package_subclass_fkey FOREIGN KEY (pkg_subclass) REFERENCES package_subclasses (pkg_sc_id)
    );

    -- info on package dependencies
    CREATE TABLE package_dependencies
    (
        pkg_dep_id serial NOT NULL,
        pkg_link_core_id integer NOT NULL,
        pkg_link_dep_id integer NOT NULL CHECK (pkg_link_core_id <> pkg_link_dep_id),
        CONSTRAINT package_dependency_pkey PRIMARY KEY (pkg_dep_id),
        CONSTRAINT package_link_core_fkey FOREIGN KEY (pkg_link_core_id) REFERENCES packages (pkg_id),
        CONSTRAINT package_link_dependency_fkey FOREIGN KEY (pkg_link_dep_id) REFERENCES packages (pkg_id)
    );

END$$;
2015-12-10 17:13:18,805 - pgpm.app - INFO - Running functions definitions scripts
2015-12-10 17:13:18,805 - pgpm.app - DEBUG - {'_log_ddl_change.sql': u'CREATE OR REPLACE FUNCTION _log_ddl_change()\n    RETURNS EVENT_TRIGGER AS\n$BODY$\n---\n-- @description\n-- Logs any DDL changes to the DB\n--\n---\nDECLARE\n    l_current_query TEXT;\n    l_txid BIGINT;\nBEGIN\n\n    SELECT current_query() INTO l_current_query;\n    SELECT txid_current() INTO l_txid;\n    INSERT INTO _pgpm.ddl_changes_log (ddl_change)\n    SELECT l_current_query\n    WHERE\n        NOT EXISTS (\n            SELECT ddl_change_txid, ddl_change FROM _pgpm.ddl_changes_log\n            WHERE ddl_change_txid = l_txid AND ddl_change = l_current_query\n        );\n\n    -- Notify external channels of ddl change\n    PERFORM pg_notify(\'ddl_change\', "session_user"());\n\nEND;\n$BODY$\nLANGUAGE \'plpgsql\' VOLATILE SECURITY DEFINER;', '_add_migration_info.sql': u"CREATE OR REPLACE FUNCTION _add_migration_info(p_m_low_v TEXT, p_m_high_v TEXT)\n    RETURNS VOID AS\n$BODY$\n---\n-- @description\n-- Adds migration info migrations log table\n--\n-- @param p_m_low_v\n-- lower border of version that is applicaple for this migration\n--\n-- @param p_m_high_v\n-- package type: either version (with version suffix at the end of the name) or basic (without)\n--\n-- @param p_pkg_old_rev\n-- higher border of version that is applicaple for this migration\n--\n---\nBEGIN\n\n    BEGIN\n        INSERT INTO migrations_log (m_low_v, m_high_v)\n            VALUES (p_m_low_v, p_m_high_v);\n    EXCEPTION\n        WHEN SQLSTATE '42P01' THEN\n            RAISE WARNING 'Can''t log migration from % to % as migrations_log is not defined yet', p_m_low_v, p_m_high_v;\n    END;\nEND;\n$BODY$\nLANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", 'set_search_path.sql': u"CREATE OR REPLACE FUNCTION set_search_path(p_schema_name TEXT, p_v_req TEXT)\n    RETURNS json AS\n$BODY$\n---\n-- @description\n-- Sets search path that includes also all depending\n--\n-- @param p_schema_name\n-- Package (schema) name\n--\n-- @param p_v_req\n-- Package version requirement. Version notation supports:\n-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)\n-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x\n-- - comparison operators like >01_02_03 or <2\n-- - x for any latest version of package\n-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency\n--\n-- @returns\n-- JSON with schema names and exact versions or exception if not found\n---\nDECLARE\n    l_search_path TEXT;\n    l_search_path_deps TEXT;\n    l_listen_text TEXT;\n\n    l_pkg_version_wrapped RECORD;\n    l_pkg_version RECORD;\n\n    return_value json;\nBEGIN\n\n    SET search_path TO _pgpm;\n    SELECT _find_schema(p_schema_name, p_v_req) AS version INTO l_pkg_version_wrapped;\n    l_pkg_version := l_pkg_version_wrapped.version;\n\n    l_search_path := l_pkg_version.pkg_name || '_' ||\n                     l_pkg_version.pkg_v_major::text || '_' ||\n                     l_pkg_version.pkg_v_minor::text || '_' ||\n                     l_pkg_version.pkg_v_patch::text;\n\n    SELECT string_agg(pkg_name || '_' || pkg_v_major || '_' || pkg_v_minor || '_' || pkg_v_patch, ', ')\n    FROM packages\n    WHERE pkg_id IN (\n        SELECT pkg_link_dep_id from package_dependencies\n        JOIN packages ON pkg_id = l_pkg_version.pkg_id\n        WHERE pkg_link_core_id = pkg_id\n    )\n    INTO l_search_path_deps;\n\n    l_search_path := l_search_path || ', ' || l_search_path_deps;\n\n    l_listen_text := 'deployment_events' || '$$' || l_pkg_version.pkg_name;\n    EXECUTE 'LISTEN ' || l_listen_text;\n\n    RAISE INFO '%', l_search_path;\n    PERFORM set_config('search_path', l_search_path || ', public', false);\n\n    return_value := row_to_json(l_pkg_version);\n    RETURN return_value;\n\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_find_schema.sql': u"CREATE OR REPLACE FUNCTION _find_schema(p_schema_name TEXT, p_v_req TEXT)\n    RETURNS RECORD AS\n$BODY$\n---\n-- @description\n-- Searches for existing schema (package) within registered packages in _pgpm schema\n--\n-- @param p_schema_name\n-- Package (schema) name\n--\n-- @param p_v_req\n-- Package version requirement. Version notation supports:\n-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)\n-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x\n-- - comparison operators like >01_02_03 or <2\n-- - x for any latest version of package\n-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency\n--\n-- @returns\n-- Record containing schema name and exact version or exception if not found in the following format:\n-- pkg_name TEXT, pkg_v_major INTEGER, pkg_v_minor INTEGER, pkg_v_patch INTEGER\n---\nDECLARE\n    c_re_version TEXT = '^(<=|>=|<|>{0,2})(\\d*|x*)_?(\\d*|x*)_?(\\d*|x*)';\n    l_v_matches TEXT[];\n\n    l_v_major INTEGER;\n    l_v_minor INTEGER;\n    l_v_patch INTEGER;\n\n    return_value RECORD;\nBEGIN\n\n    SELECT regexp_matches(p_v_req, c_re_version, 'gi') INTO l_v_matches;\n\n    IF l_v_matches[2] ~* '^x+|^$' THEN\n        SELECT max(pkg_v_major)\n        FROM packages\n        WHERE pkg_name = p_schema_name\n        INTO l_v_major;\n    ELSE\n        l_v_major := l_v_matches[2]::integer;\n    END IF;\n\n    IF l_v_matches[3] ~* '^x+|^$' THEN\n        SELECT max(pkg_v_minor)\n        FROM packages\n        WHERE pkg_name = p_schema_name\n              AND pkg_v_major = l_v_major\n        INTO l_v_minor;\n    ELSE\n        l_v_minor := l_v_matches[3]::integer;\n    END IF;\n\n    IF l_v_matches[4] ~* '^x+|^$' THEN\n        SELECT max(pkg_v_patch)\n        FROM packages\n        WHERE pkg_name = p_schema_name\n              AND pkg_v_major = l_v_major\n              AND pkg_v_minor = l_v_minor\n        INTO l_v_patch;\n    ELSE\n        l_v_patch := l_v_matches[4]::integer;\n    END IF;\n\n    CASE l_v_matches[1]\n        WHEN '=', '' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND pkg_v_major = l_v_major\n                  AND pkg_v_minor = l_v_minor\n                  AND pkg_v_patch = l_v_patch\n            INTO return_value;\n        WHEN '<' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major < l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor < l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch < l_v_patch))\n            INTO return_value;\n        WHEN '>' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major > l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor > l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch > l_v_patch))\n            INTO return_value;\n        WHEN '<=' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major <= l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor <= l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch <= l_v_patch))\n            INTO return_value;\n        WHEN '>=' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major >= l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor >= l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch >= l_v_patch))\n            INTO return_value;\n        ELSE\n            RAISE EXCEPTION 'Invalid logical operand. Only <, >, =, <=, >=, = or no operand are allowed.' USING ERRCODE = '20000';\n    END CASE;\n\n    RETURN return_value;\n\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_upsert_package_info.sql': u"CREATE OR REPLACE FUNCTION _upsert_package_info(p_pkg_name TEXT,\n                                             p_pkg_subclass_name TEXT,\n                                             p_pkg_v_major INTEGER,\n                                             p_pkg_v_minor INTEGER DEFAULT 0,\n                                             p_pkg_v_patch INTEGER DEFAULT 0,\n                                             p_pkg_v_pre TEXT DEFAULT NULL,\n                                             p_pkg_v_metadata TEXT DEFAULT NULL,\n                                             p_pkg_description TEXT DEFAULT '',\n                                             p_pkg_license TEXT DEFAULT NULL,\n                                             p_pkg_deps_ids INTEGER[] DEFAULT '{}',\n                                             p_pkg_vcs_ref TEXT DEFAULT NULL,\n                                             p_pkg_vcs_link TEXT DEFAULT NULL,\n                                             p_pkg_issue_ref TEXT DEFAULT NULL,\n                                             p_pkg_issue_link TEXT DEFAULT NULL)\n    RETURNS INTEGER AS\n$BODY$\n---\n-- @description\n-- Adds package info to pgpm package info table, deployment events table and notifies channels of deployment\n--\n-- @param p_pkg_name\n-- package name\n--\n-- @param p_pkg_subclass_name\n-- package type: either version (with version suffix at the end of the name) or basic (without)\n--\n-- @param p_pkg_description\n-- package description\n--\n-- @param p_pkg_v_major\n-- package major part of version (according to semver)\n--\n-- @param p_pkg_v_minor\n-- package minor part of version (according to semver)\n--\n-- @param p_pkg_v_patch\n-- package patch part of version (according to semver)\n--\n-- @param p_pkg_v_pre\n-- package pre part of version (according to semver)\n--\n-- @param p_pkg_v_metadata\n-- package metadata part of version (according to semver)\n--\n-- @param p_pkg_license\n-- package license name/text\n--\n-- @param p_pkg_deps_ids\n-- IDs of dependent schemas\n--\n-- @param p_pkg_vcs_ref\n-- vcs reference to track the code\n--\n-- @param p_pkg_vcs_link\n-- repository link to track the code\n--\n-- @param p_pkg_issue_ref\n-- issue reference to track the code\n--\n-- @param p_pkg_issue_link\n-- issue tracking system link\n---\nDECLARE\n    l_existing_pkg_id INTEGER;\n    l_pkg_dep_id INTEGER;\n\n\treturn_value INTEGER;\nBEGIN\n\n    -- Case 1: unsafe mode, rewrite of the whole schema with the same version or some of the files in it\n    -- Case 2: new schema with new version (safe or moderate modes)\n\n    IF p_pkg_subclass_name = 'basic' THEN\n        SELECT pkg_id INTO l_existing_pkg_id\n        FROM packages\n        WHERE pkg_name = p_pkg_name\n            AND pkg_subclass IN (SELECT pkg_sc_id\n                                 FROM package_subclasses\n                                 WHERE pkg_sc_name = p_pkg_subclass_name);\n    ELSE\n        SELECT pkg_id INTO l_existing_pkg_id\n        FROM packages\n        WHERE pkg_name = p_pkg_name\n            AND pkg_subclass IN (SELECT pkg_sc_id\n                                 FROM package_subclasses\n                                 WHERE pkg_sc_name = p_pkg_subclass_name)\n            AND pkg_v_major = p_pkg_v_major\n            AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)\n            AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)\n            AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre)\n            AND pkg_old_rev IS NULL;\n    END IF;\n\n    IF FOUND THEN -- Case 1:\n        DELETE FROM package_dependencies\n            WHERE pkg_link_core_id = l_existing_pkg_id;\n\n        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids\n        LOOP\n            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (l_existing_pkg_id, l_pkg_dep_id);\n        END LOOP;\n\n        UPDATE packages\n        SET pkg_name=subquery.p_pkg_name,\n            pkg_subclass=subquery.pkg_sc_id,\n            pkg_v_major=subquery.p_pkg_v_major,\n            pkg_v_minor=subquery.p_pkg_v_minor,\n            pkg_v_patch=subquery.p_pkg_v_patch,\n            pkg_v_pre=subquery.p_pkg_v_pre,\n            pkg_v_metadata=subquery.p_pkg_v_metadata,\n            pkg_description=subquery.p_pkg_description,\n            pkg_license=subquery.p_pkg_license\n        FROM (SELECT\n                  p_pkg_name,\n                  pkg_sc_id,\n                  p_pkg_v_major,\n                  p_pkg_v_minor,\n                  p_pkg_v_patch,\n                  p_pkg_v_pre,\n                  p_pkg_v_metadata,\n                  p_pkg_description,\n                  p_pkg_license\n              FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name\n        ) as subquery\n        WHERE packages.pkg_name=subquery.p_pkg_name;\n\n        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)\n            VALUES (l_existing_pkg_id, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);\n\n        return_value := l_existing_pkg_id;\n    ELSE -- Case 2:\n        INSERT INTO packages (\n            pkg_name,\n            pkg_description,\n            pkg_v_major,\n            pkg_v_minor,\n            pkg_v_patch,\n            pkg_v_pre,\n            pkg_v_metadata,\n            pkg_subclass,\n            pkg_license\n        )\n        SELECT\n            p_pkg_name,\n            p_pkg_description,\n            p_pkg_v_major,\n            p_pkg_v_minor,\n            p_pkg_v_patch,\n            p_pkg_v_pre,\n            p_pkg_v_metadata,\n            pkg_sc_id,\n            p_pkg_license\n        FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name\n        RETURNING\n            pkg_id\n        INTO return_value;\n\n        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids\n        LOOP\n            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (return_value, l_pkg_dep_id);\n        END LOOP;\n\n        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)\n            VALUES (return_value, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);\n\n    END IF;\n\n    -- Notify external channels of successful deployment event\n    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);\n\n    RETURN return_value;\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_alter_schema_owner.sql': u"CREATE OR REPLACE FUNCTION _alter_schema_owner(p_schema TEXT, p_owner TEXT)\n    RETURNS VOID AS\n$BODY$\n---\n-- @description\n-- Alters ownership of schema and all its objects to a specified user.\n--\n-- @param p_schema\n-- Schema name\n--\n-- @param p_owner\n-- New owner user name\n--\n---\nDECLARE\n    l_schema TEXT;\n    l_functions TEXT;\n    l_tables TEXT;\n    l_sequences TEXT;\n    l_views TEXT;\n    l_domains TEXT;\n    l_triggers TEXT;\n    l_types TEXT;\n\nBEGIN\n\n    l_schema := 'ALTER SCHEMA '\n                || quote_ident(p_schema)\n                || ' OWNER TO '\n                || quote_ident(p_owner)\n                || ';';\n\n    SELECT string_agg('ALTER FUNCTION '\n                || quote_ident(n.nspname) || '.'\n                || quote_ident(p.proname) || '('\n                || pg_catalog.pg_get_function_identity_arguments(p.oid)\n                || ') OWNER TO ' || p_owner || ';'\n              , E'\\n') AS _sql\n    FROM   pg_catalog.pg_proc p\n    JOIN   pg_catalog.pg_namespace n ON n.oid = p.pronamespace\n    WHERE  n.nspname = p_schema\n    INTO l_functions;\n    IF l_functions IS NULL THEN\n        l_functions := '';\n    END IF;\n\n    SELECT string_agg('ALTER TABLE ' || quote_ident(schemaname) || '.' || quote_ident(tablename) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM pg_tables WHERE schemaname = p_schema\n    INTO l_tables;\n    IF l_tables IS NULL THEN\n        l_tables := '';\n    END IF;\n\n    SELECT string_agg('ALTER SEQUENCE ' || quote_ident(sequence_schema) || '.' || quote_ident(sequence_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.sequences WHERE sequence_schema = p_schema\n    INTO l_sequences;\n    IF l_sequences IS NULL THEN\n        l_sequences := '';\n    END IF;\n\n    SELECT string_agg('ALTER VIEW ' || quote_ident(table_schema) || '.' || quote_ident(table_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.views WHERE table_schema = p_schema\n    INTO l_views;\n    IF l_views IS NULL THEN\n        l_views := '';\n    END IF;\n\n    SELECT string_agg('ALTER DOMAIN ' || quote_ident(domain_schema) || '.' || quote_ident(domain_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.domains WHERE domain_schema = p_schema\n    INTO l_domains;\n    IF l_domains IS NULL THEN\n        l_domains := '';\n    END IF;\n\n    SELECT string_agg('ALTER TRIGGER ' || quote_ident(trigger_schema) || '.' || quote_ident(trigger_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.triggers WHERE trigger_schema = p_schema\n    INTO l_triggers;\n    IF l_triggers IS NULL THEN\n        l_triggers := '';\n    END IF;\n\n    SELECT string_agg('ALTER TYPE ' || quote_ident(user_defined_type_schema) || '.' || quote_ident(user_defined_type_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.user_defined_types WHERE user_defined_type_schema = p_schema\n    INTO l_types;\n    IF l_types IS NULL THEN\n        l_types := '';\n    END IF;\n\n    EXECUTE l_schema || l_functions || l_tables || l_sequences || l_views || l_domains || l_triggers || l_types;\n\nEND;\n$BODY$\nLANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;", '_log_table_evolution.sql': u"CREATE OR REPLACE FUNCTION _log_table_evolution(p_t_evo_file_name TEXT, p_t_evo_package INTEGER)\n    RETURNS VOID AS\n$BODY$\n---\n-- @description\n-- Adds information about executed table evolution script to log table\n--\n-- @param p_t_evo_file_name\n-- File name with executed statements.\n--\n-- @param p_t_evo_package\n-- Related package id\n--\n-- @param p_pkg_old_rev\n-- higher border of version that is applicaple for this migration\n--\n---\nBEGIN\n\n    INSERT INTO table_evolutions_log (t_evo_file_name, t_evo_package)\n        VALUES (p_t_evo_file_name, p_t_evo_package);\nEND;\n$BODY$\nLANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;", '_is_table_ddl_executed.sql': u"CREATE OR REPLACE FUNCTION _is_table_ddl_executed(p_file_name TEXT)\n    RETURNS BOOLEAN AS\n$BODY$\n---\n-- @description\n-- Checks whether file with table ddl has already been executed\n--\n-- @param p_file_name\n-- File name used to check whether statements were executed\n--\n-- @returns\n-- True if executed, False otherwise\n---\nDECLARE\n    return_value BOOLEAN;\nBEGIN\n\n    SELECT EXISTS (SELECT t_evo_id FROM table_evolutions_log WHERE t_evo_file_name=p_file_name) INTO return_value;\n\n    RETURN return_value;\n\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_set_revision_package.sql': u"CREATE OR REPLACE FUNCTION _set_revision_package(p_pkg_name TEXT,\n                                             p_pkg_subclass_name TEXT,\n                                             p_pkg_old_rev INTEGER,\n                                             p_pkg_v_major INTEGER,\n                                             p_pkg_v_minor INTEGER DEFAULT 0,\n                                             p_pkg_v_patch INTEGER DEFAULT 0,\n                                             p_pkg_v_pre TEXT DEFAULT NULL)\n    RETURNS INTEGER AS\n$BODY$\n---\n-- @description\n-- Set package as old revision, info logged in deployment events table\n--\n-- @param p_pkg_name\n-- package name\n--\n-- @param p_pkg_subclass_name\n-- package type: either version (with version suffix at the end of the name) or basic (without)\n--\n-- @param p_pkg_old_rev\n-- Revision name of package. Used in moderate form. When schema is renamed it is given a revision suffix from here\n--\n-- @param p_pkg_v_major\n-- package major part of version (according to semver)\n--\n-- @param p_pkg_v_minor\n-- package minor part of version (according to semver)\n--\n-- @param p_pkg_v_patch\n-- package patch part of version (according to semver)\n--\n-- @param p_pkg_v_pre\n-- package pre part of version (according to semver)\n--\n-- @param p_pkg_v_metadata\n-- package metadata part of version (according to semver)\n--\n-- @param p_pkg_vcs_ref\n-- vcs reference to track the code\n---\nDECLARE\n    l_existing_pkg_id INTEGER;\n    l_pkg_dep_id INTEGER;\n\n\treturn_value INTEGER;\nBEGIN\n\n    SELECT pkg_id INTO l_existing_pkg_id\n    FROM packages\n    WHERE pkg_name = p_pkg_name\n        AND pkg_subclass IN (SELECT pkg_sc_id\n                             FROM package_subclasses\n                             WHERE pkg_sc_name = p_pkg_subclass_name)\n        AND pkg_v_major = p_pkg_v_major\n        AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)\n        AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)\n        AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre);\n\n    IF FOUND THEN\n        UPDATE packages\n        SET pkg_old_rev=p_pkg_old_rev\n        WHERE packages.pkg_id=l_existing_pkg_id;\n\n        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)\n            SELECT pkg_id, txid_current(), dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link\n            FROM packages\n            JOIN deployment_events ON dpl_ev_pkg_id=pkg_id\n            WHERE pkg_id=l_existing_pkg_id AND dpl_ev_time IN (\n                SELECT max(dpl_ev_time) FROM deployment_events WHERE dpl_ev_pkg_id=packages.pkg_id\n            );\n    ELSE\n        RAISE EXCEPTION 'Package % not found in the list of packages. It could happen if schema exists but wasn''t properly deployed with pgpm', p_pkg_name || '_' || p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch;\n    END IF;\n\n    -- Notify external channels of successful deployment event\n    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);\n\n    RETURN return_value;\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n"}
2015-12-10 17:13:18,806 - pgpm.app - DEBUG - Executing query: set search_path TO _pgpm, public;
2015-12-10 17:13:18,807 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _log_ddl_change()
    RETURNS EVENT_TRIGGER AS
$BODY$
---
-- @description
-- Logs any DDL changes to the DB
--
---
DECLARE
    l_current_query TEXT;
    l_txid BIGINT;
BEGIN

    SELECT current_query() INTO l_current_query;
    SELECT txid_current() INTO l_txid;
    INSERT INTO _pgpm.ddl_changes_log (ddl_change)
    SELECT l_current_query
    WHERE
        NOT EXISTS (
            SELECT ddl_change_txid, ddl_change FROM _pgpm.ddl_changes_log
            WHERE ddl_change_txid = l_txid AND ddl_change = l_current_query
        );

    -- Notify external channels of ddl change
    PERFORM pg_notify('ddl_change', "session_user"());

END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;
2015-12-10 17:13:18,807 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _add_migration_info(p_m_low_v TEXT, p_m_high_v TEXT)
    RETURNS VOID AS
$BODY$
---
-- @description
-- Adds migration info migrations log table
--
-- @param p_m_low_v
-- lower border of version that is applicaple for this migration
--
-- @param p_m_high_v
-- package type: either version (with version suffix at the end of the name) or basic (without)
--
-- @param p_pkg_old_rev
-- higher border of version that is applicaple for this migration
--
---
BEGIN

    BEGIN
        INSERT INTO migrations_log (m_low_v, m_high_v)
            VALUES (p_m_low_v, p_m_high_v);
    EXCEPTION
        WHEN SQLSTATE '42P01' THEN
            RAISE WARNING 'Can''t log migration from % to % as migrations_log is not defined yet', p_m_low_v, p_m_high_v;
    END;
END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 17:13:18,808 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION set_search_path(p_schema_name TEXT, p_v_req TEXT)
    RETURNS json AS
$BODY$
---
-- @description
-- Sets search path that includes also all depending
--
-- @param p_schema_name
-- Package (schema) name
--
-- @param p_v_req
-- Package version requirement. Version notation supports:
-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)
-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x
-- - comparison operators like >01_02_03 or <2
-- - x for any latest version of package
-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency
--
-- @returns
-- JSON with schema names and exact versions or exception if not found
---
DECLARE
    l_search_path TEXT;
    l_search_path_deps TEXT;
    l_listen_text TEXT;

    l_pkg_version_wrapped RECORD;
    l_pkg_version RECORD;

    return_value json;
BEGIN

    SET search_path TO _pgpm;
    SELECT _find_schema(p_schema_name, p_v_req) AS version INTO l_pkg_version_wrapped;
    l_pkg_version := l_pkg_version_wrapped.version;

    l_search_path := l_pkg_version.pkg_name || '_' ||
                     l_pkg_version.pkg_v_major::text || '_' ||
                     l_pkg_version.pkg_v_minor::text || '_' ||
                     l_pkg_version.pkg_v_patch::text;

    SELECT string_agg(pkg_name || '_' || pkg_v_major || '_' || pkg_v_minor || '_' || pkg_v_patch, ', ')
    FROM packages
    WHERE pkg_id IN (
        SELECT pkg_link_dep_id from package_dependencies
        JOIN packages ON pkg_id = l_pkg_version.pkg_id
        WHERE pkg_link_core_id = pkg_id
    )
    INTO l_search_path_deps;

    l_search_path := l_search_path || ', ' || l_search_path_deps;

    l_listen_text := 'deployment_events' || '$$' || l_pkg_version.pkg_name;
    EXECUTE 'LISTEN ' || l_listen_text;

    RAISE INFO '%', l_search_path;
    PERFORM set_config('search_path', l_search_path || ', public', false);

    return_value := row_to_json(l_pkg_version);
    RETURN return_value;

END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 17:13:18,809 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _find_schema(p_schema_name TEXT, p_v_req TEXT)
    RETURNS RECORD AS
$BODY$
---
-- @description
-- Searches for existing schema (package) within registered packages in _pgpm schema
--
-- @param p_schema_name
-- Package (schema) name
--
-- @param p_v_req
-- Package version requirement. Version notation supports:
-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)
-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x
-- - comparison operators like >01_02_03 or <2
-- - x for any latest version of package
-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency
--
-- @returns
-- Record containing schema name and exact version or exception if not found in the following format:
-- pkg_name TEXT, pkg_v_major INTEGER, pkg_v_minor INTEGER, pkg_v_patch INTEGER
---
DECLARE
    c_re_version TEXT = '^(<=|>=|<|>{0,2})(\d*|x*)_?(\d*|x*)_?(\d*|x*)';
    l_v_matches TEXT[];

    l_v_major INTEGER;
    l_v_minor INTEGER;
    l_v_patch INTEGER;

    return_value RECORD;
BEGIN

    SELECT regexp_matches(p_v_req, c_re_version, 'gi') INTO l_v_matches;

    IF l_v_matches[2] ~* '^x+|^$' THEN
        SELECT max(pkg_v_major)
        FROM packages
        WHERE pkg_name = p_schema_name
        INTO l_v_major;
    ELSE
        l_v_major := l_v_matches[2]::integer;
    END IF;

    IF l_v_matches[3] ~* '^x+|^$' THEN
        SELECT max(pkg_v_minor)
        FROM packages
        WHERE pkg_name = p_schema_name
              AND pkg_v_major = l_v_major
        INTO l_v_minor;
    ELSE
        l_v_minor := l_v_matches[3]::integer;
    END IF;

    IF l_v_matches[4] ~* '^x+|^$' THEN
        SELECT max(pkg_v_patch)
        FROM packages
        WHERE pkg_name = p_schema_name
              AND pkg_v_major = l_v_major
              AND pkg_v_minor = l_v_minor
        INTO l_v_patch;
    ELSE
        l_v_patch := l_v_matches[4]::integer;
    END IF;

    CASE l_v_matches[1]
        WHEN '=', '' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND pkg_v_major = l_v_major
                  AND pkg_v_minor = l_v_minor
                  AND pkg_v_patch = l_v_patch
            INTO return_value;
        WHEN '<' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major < l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor < l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch < l_v_patch))
            INTO return_value;
        WHEN '>' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major > l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor > l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch > l_v_patch))
            INTO return_value;
        WHEN '<=' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major <= l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor <= l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch <= l_v_patch))
            INTO return_value;
        WHEN '>=' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major >= l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor >= l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch >= l_v_patch))
            INTO return_value;
        ELSE
            RAISE EXCEPTION 'Invalid logical operand. Only <, >, =, <=, >=, = or no operand are allowed.' USING ERRCODE = '20000';
    END CASE;

    RETURN return_value;

END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 17:13:18,811 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _upsert_package_info(p_pkg_name TEXT,
                                             p_pkg_subclass_name TEXT,
                                             p_pkg_v_major INTEGER,
                                             p_pkg_v_minor INTEGER DEFAULT 0,
                                             p_pkg_v_patch INTEGER DEFAULT 0,
                                             p_pkg_v_pre TEXT DEFAULT NULL,
                                             p_pkg_v_metadata TEXT DEFAULT NULL,
                                             p_pkg_description TEXT DEFAULT '',
                                             p_pkg_license TEXT DEFAULT NULL,
                                             p_pkg_deps_ids INTEGER[] DEFAULT '{}',
                                             p_pkg_vcs_ref TEXT DEFAULT NULL,
                                             p_pkg_vcs_link TEXT DEFAULT NULL,
                                             p_pkg_issue_ref TEXT DEFAULT NULL,
                                             p_pkg_issue_link TEXT DEFAULT NULL)
    RETURNS INTEGER AS
$BODY$
---
-- @description
-- Adds package info to pgpm package info table, deployment events table and notifies channels of deployment
--
-- @param p_pkg_name
-- package name
--
-- @param p_pkg_subclass_name
-- package type: either version (with version suffix at the end of the name) or basic (without)
--
-- @param p_pkg_description
-- package description
--
-- @param p_pkg_v_major
-- package major part of version (according to semver)
--
-- @param p_pkg_v_minor
-- package minor part of version (according to semver)
--
-- @param p_pkg_v_patch
-- package patch part of version (according to semver)
--
-- @param p_pkg_v_pre
-- package pre part of version (according to semver)
--
-- @param p_pkg_v_metadata
-- package metadata part of version (according to semver)
--
-- @param p_pkg_license
-- package license name/text
--
-- @param p_pkg_deps_ids
-- IDs of dependent schemas
--
-- @param p_pkg_vcs_ref
-- vcs reference to track the code
--
-- @param p_pkg_vcs_link
-- repository link to track the code
--
-- @param p_pkg_issue_ref
-- issue reference to track the code
--
-- @param p_pkg_issue_link
-- issue tracking system link
---
DECLARE
    l_existing_pkg_id INTEGER;
    l_pkg_dep_id INTEGER;

	return_value INTEGER;
BEGIN

    -- Case 1: unsafe mode, rewrite of the whole schema with the same version or some of the files in it
    -- Case 2: new schema with new version (safe or moderate modes)

    IF p_pkg_subclass_name = 'basic' THEN
        SELECT pkg_id INTO l_existing_pkg_id
        FROM packages
        WHERE pkg_name = p_pkg_name
            AND pkg_subclass IN (SELECT pkg_sc_id
                                 FROM package_subclasses
                                 WHERE pkg_sc_name = p_pkg_subclass_name);
    ELSE
        SELECT pkg_id INTO l_existing_pkg_id
        FROM packages
        WHERE pkg_name = p_pkg_name
            AND pkg_subclass IN (SELECT pkg_sc_id
                                 FROM package_subclasses
                                 WHERE pkg_sc_name = p_pkg_subclass_name)
            AND pkg_v_major = p_pkg_v_major
            AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)
            AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)
            AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre)
            AND pkg_old_rev IS NULL;
    END IF;

    IF FOUND THEN -- Case 1:
        DELETE FROM package_dependencies
            WHERE pkg_link_core_id = l_existing_pkg_id;

        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids
        LOOP
            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (l_existing_pkg_id, l_pkg_dep_id);
        END LOOP;

        UPDATE packages
        SET pkg_name=subquery.p_pkg_name,
            pkg_subclass=subquery.pkg_sc_id,
            pkg_v_major=subquery.p_pkg_v_major,
            pkg_v_minor=subquery.p_pkg_v_minor,
            pkg_v_patch=subquery.p_pkg_v_patch,
            pkg_v_pre=subquery.p_pkg_v_pre,
            pkg_v_metadata=subquery.p_pkg_v_metadata,
            pkg_description=subquery.p_pkg_description,
            pkg_license=subquery.p_pkg_license
        FROM (SELECT
                  p_pkg_name,
                  pkg_sc_id,
                  p_pkg_v_major,
                  p_pkg_v_minor,
                  p_pkg_v_patch,
                  p_pkg_v_pre,
                  p_pkg_v_metadata,
                  p_pkg_description,
                  p_pkg_license
              FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name
        ) as subquery
        WHERE packages.pkg_name=subquery.p_pkg_name;

        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)
            VALUES (l_existing_pkg_id, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);

        return_value := l_existing_pkg_id;
    ELSE -- Case 2:
        INSERT INTO packages (
            pkg_name,
            pkg_description,
            pkg_v_major,
            pkg_v_minor,
            pkg_v_patch,
            pkg_v_pre,
            pkg_v_metadata,
            pkg_subclass,
            pkg_license
        )
        SELECT
            p_pkg_name,
            p_pkg_description,
            p_pkg_v_major,
            p_pkg_v_minor,
            p_pkg_v_patch,
            p_pkg_v_pre,
            p_pkg_v_metadata,
            pkg_sc_id,
            p_pkg_license
        FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name
        RETURNING
            pkg_id
        INTO return_value;

        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids
        LOOP
            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (return_value, l_pkg_dep_id);
        END LOOP;

        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)
            VALUES (return_value, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);

    END IF;

    -- Notify external channels of successful deployment event
    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);

    RETURN return_value;
END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 17:13:18,812 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _alter_schema_owner(p_schema TEXT, p_owner TEXT)
    RETURNS VOID AS
$BODY$
---
-- @description
-- Alters ownership of schema and all its objects to a specified user.
--
-- @param p_schema
-- Schema name
--
-- @param p_owner
-- New owner user name
--
---
DECLARE
    l_schema TEXT;
    l_functions TEXT;
    l_tables TEXT;
    l_sequences TEXT;
    l_views TEXT;
    l_domains TEXT;
    l_triggers TEXT;
    l_types TEXT;

BEGIN

    l_schema := 'ALTER SCHEMA '
                || quote_ident(p_schema)
                || ' OWNER TO '
                || quote_ident(p_owner)
                || ';';

    SELECT string_agg('ALTER FUNCTION '
                || quote_ident(n.nspname) || '.'
                || quote_ident(p.proname) || '('
                || pg_catalog.pg_get_function_identity_arguments(p.oid)
                || ') OWNER TO ' || p_owner || ';'
              , E'\n') AS _sql
    FROM   pg_catalog.pg_proc p
    JOIN   pg_catalog.pg_namespace n ON n.oid = p.pronamespace
    WHERE  n.nspname = p_schema
    INTO l_functions;
    IF l_functions IS NULL THEN
        l_functions := '';
    END IF;

    SELECT string_agg('ALTER TABLE ' || quote_ident(schemaname) || '.' || quote_ident(tablename) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM pg_tables WHERE schemaname = p_schema
    INTO l_tables;
    IF l_tables IS NULL THEN
        l_tables := '';
    END IF;

    SELECT string_agg('ALTER SEQUENCE ' || quote_ident(sequence_schema) || '.' || quote_ident(sequence_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.sequences WHERE sequence_schema = p_schema
    INTO l_sequences;
    IF l_sequences IS NULL THEN
        l_sequences := '';
    END IF;

    SELECT string_agg('ALTER VIEW ' || quote_ident(table_schema) || '.' || quote_ident(table_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.views WHERE table_schema = p_schema
    INTO l_views;
    IF l_views IS NULL THEN
        l_views := '';
    END IF;

    SELECT string_agg('ALTER DOMAIN ' || quote_ident(domain_schema) || '.' || quote_ident(domain_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.domains WHERE domain_schema = p_schema
    INTO l_domains;
    IF l_domains IS NULL THEN
        l_domains := '';
    END IF;

    SELECT string_agg('ALTER TRIGGER ' || quote_ident(trigger_schema) || '.' || quote_ident(trigger_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.triggers WHERE trigger_schema = p_schema
    INTO l_triggers;
    IF l_triggers IS NULL THEN
        l_triggers := '';
    END IF;

    SELECT string_agg('ALTER TYPE ' || quote_ident(user_defined_type_schema) || '.' || quote_ident(user_defined_type_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.user_defined_types WHERE user_defined_type_schema = p_schema
    INTO l_types;
    IF l_types IS NULL THEN
        l_types := '';
    END IF;

    EXECUTE l_schema || l_functions || l_tables || l_sequences || l_views || l_domains || l_triggers || l_types;

END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;
2015-12-10 17:13:18,813 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _log_table_evolution(p_t_evo_file_name TEXT, p_t_evo_package INTEGER)
    RETURNS VOID AS
$BODY$
---
-- @description
-- Adds information about executed table evolution script to log table
--
-- @param p_t_evo_file_name
-- File name with executed statements.
--
-- @param p_t_evo_package
-- Related package id
--
-- @param p_pkg_old_rev
-- higher border of version that is applicaple for this migration
--
---
BEGIN

    INSERT INTO table_evolutions_log (t_evo_file_name, t_evo_package)
        VALUES (p_t_evo_file_name, p_t_evo_package);
END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;
2015-12-10 17:13:18,813 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _is_table_ddl_executed(p_file_name TEXT)
    RETURNS BOOLEAN AS
$BODY$
---
-- @description
-- Checks whether file with table ddl has already been executed
--
-- @param p_file_name
-- File name used to check whether statements were executed
--
-- @returns
-- True if executed, False otherwise
---
DECLARE
    return_value BOOLEAN;
BEGIN

    SELECT EXISTS (SELECT t_evo_id FROM table_evolutions_log WHERE t_evo_file_name=p_file_name) INTO return_value;

    RETURN return_value;

END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 17:13:18,814 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _set_revision_package(p_pkg_name TEXT,
                                             p_pkg_subclass_name TEXT,
                                             p_pkg_old_rev INTEGER,
                                             p_pkg_v_major INTEGER,
                                             p_pkg_v_minor INTEGER DEFAULT 0,
                                             p_pkg_v_patch INTEGER DEFAULT 0,
                                             p_pkg_v_pre TEXT DEFAULT NULL)
    RETURNS INTEGER AS
$BODY$
---
-- @description
-- Set package as old revision, info logged in deployment events table
--
-- @param p_pkg_name
-- package name
--
-- @param p_pkg_subclass_name
-- package type: either version (with version suffix at the end of the name) or basic (without)
--
-- @param p_pkg_old_rev
-- Revision name of package. Used in moderate form. When schema is renamed it is given a revision suffix from here
--
-- @param p_pkg_v_major
-- package major part of version (according to semver)
--
-- @param p_pkg_v_minor
-- package minor part of version (according to semver)
--
-- @param p_pkg_v_patch
-- package patch part of version (according to semver)
--
-- @param p_pkg_v_pre
-- package pre part of version (according to semver)
--
-- @param p_pkg_v_metadata
-- package metadata part of version (according to semver)
--
-- @param p_pkg_vcs_ref
-- vcs reference to track the code
---
DECLARE
    l_existing_pkg_id INTEGER;
    l_pkg_dep_id INTEGER;

	return_value INTEGER;
BEGIN

    SELECT pkg_id INTO l_existing_pkg_id
    FROM packages
    WHERE pkg_name = p_pkg_name
        AND pkg_subclass IN (SELECT pkg_sc_id
                             FROM package_subclasses
                             WHERE pkg_sc_name = p_pkg_subclass_name)
        AND pkg_v_major = p_pkg_v_major
        AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)
        AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)
        AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre);

    IF FOUND THEN
        UPDATE packages
        SET pkg_old_rev=p_pkg_old_rev
        WHERE packages.pkg_id=l_existing_pkg_id;

        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)
            SELECT pkg_id, txid_current(), dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link
            FROM packages
            JOIN deployment_events ON dpl_ev_pkg_id=pkg_id
            WHERE pkg_id=l_existing_pkg_id AND dpl_ev_time IN (
                SELECT max(dpl_ev_time) FROM deployment_events WHERE dpl_ev_pkg_id=packages.pkg_id
            );
    ELSE
        RAISE EXCEPTION 'Package % not found in the list of packages. It could happen if schema exists but wasn''t properly deployed with pgpm', p_pkg_name || '_' || p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch;
    END IF;

    -- Notify external channels of successful deployment event
    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);

    RETURN return_value;
END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 17:13:18,814 - pgpm.app - DEBUG - Functions loaded to schema _pgpm
2015-12-10 17:13:18,814 - pgpm.app - DEBUG - Running version upgrade script 0.0.1-0.0.6.tmpl.sql
2015-12-10 17:13:18,814 - pgpm.app - DEBUG - /*
    Migration script from version 0.0.1 to 0.0.6 (or higher if tool doesn't find other migration scripts)
 */
DO
$$BEGIN
    SET search_path TO _pgpm, public;
    GRANT USAGE ON SCHEMA _pgpm TO public;
    COMMENT ON SCHEMA _pgpm IS
        'Schema containing all information about postgres packages (name, version, dependencies, etc.)
         and utility functions';

    -- drop created and last modified in subclasses, add comment and change varchar to text
    ALTER TABLE package_subclasses DROP COLUMN pkg_sc_created;
    ALTER TABLE package_subclasses DROP COLUMN pkg_sc_last_modified;
    ALTER TABLE package_subclasses ALTER COLUMN pkg_sc_name TYPE TEXT;
    COMMENT ON TABLE package_subclasses IS
        'Subclass of package. Can refer either to versioned schema (that adds suffix at the end)
         or non-versioned (basic) one (without suffix at the end)';

    -- remove vcf reference, created and last modified (will be moved to deployment_events table), add comments,
    -- change varchar to text and bump version of pgpm to 0.0.6
    ALTER TABLE packages DROP COLUMN pkg_created;
    ALTER TABLE packages DROP COLUMN pkg_last_modified;
    ALTER TABLE packages DROP COLUMN pkg_vcs_ref;
    ALTER TABLE packages ALTER COLUMN pkg_name TYPE TEXT;
    ALTER TABLE packages ALTER COLUMN pkg_v_pre TYPE TEXT;
    ALTER TABLE packages ALTER COLUMN pkg_v_metadata TYPE TEXT;
    UPDATE packages SET pkg_v_major = 0, pkg_v_minor = 0, pkg_v_patch = 6 WHERE pkg_name = '_pgpm';
    COMMENT ON TABLE packages IS
        'Information about package (schema) tracked with pgpm.';
    COMMENT ON COLUMN packages.pkg_v_major IS
        'Major part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_minor IS
        'Minor part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_patch IS
        'Patch part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_pre IS
        'Pre part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_metadata IS
        'Metadata part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_old_rev IS
        'Incremental number of the revision of the package of the same version.
         Used the following way. If package deployed with the version of already existing package in moderate mode then
         old package is renamed by adding an ending with incremental revision (starting with 0)';
    COMMENT ON COLUMN packages.pkg_license IS
        'Name of license (or a link) of a package';

    -- change Primary key to combination of 2 keys and remove old key
    ALTER TABLE package_dependencies DROP CONSTRAINT package_dependency_pkey;
    ALTER TABLE package_dependencies ADD CONSTRAINT package_dependency_pkey PRIMARY KEY (pkg_link_core_id, pkg_link_dep_id);
    COMMENT ON TABLE package_dependencies IS
        'Many to many relationship between dependant packages. Package cannot depend on itself';

    CREATE TABLE deployment_events
    (
        dpl_ev_pkg_id INTEGER,
        dpl_ev_vcs_ref TEXT,
        dpl_ev_vcs_link TEXT,
        dpl_ev_time TIMESTAMP DEFAULT NOW(),
        dpl_ev_issue_id TEXT,
        dpl_ev_issue_link TEXT,
        CONSTRAINT dpl_ev_pkg_fkey FOREIGN KEY (dpl_ev_pkg_id) REFERENCES packages (pkg_id)
    );
    COMMENT ON TABLE deployment_events IS
        'Table tracks all deployments tracked by pgpm';
    COMMENT ON COLUMN deployment_events.dpl_ev_vcs_ref IS
        'Reference to VCS point that was installed.
         In case of git, best option is to put here a specific commit reference.
         In case of SVN, revision number.';
    COMMENT ON COLUMN deployment_events.dpl_ev_vcs_link IS
        'Link to VCS repository.';
    COMMENT ON COLUMN deployment_events.dpl_ev_time IS
        'Deployment time';
    COMMENT ON COLUMN deployment_events.dpl_ev_issue_id IS
        'ID of an issue in issue tracker. E.g. ABS-111 for JIRA.';
    COMMENT ON COLUMN deployment_events.dpl_ev_issue_link IS
        'Link to an issue related to this deployment in issue tracker.';

END$$;
2015-12-10 17:13:18,821 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.0.1 to 0.0.6 (or higher if tool doesn't find other migration scripts)
 */
DO
$$BEGIN
    SET search_path TO _pgpm, public;
    GRANT USAGE ON SCHEMA _pgpm TO public;
    COMMENT ON SCHEMA _pgpm IS
        'Schema containing all information about postgres packages (name, version, dependencies, etc.)
         and utility functions';

    -- drop created and last modified in subclasses, add comment and change varchar to text
    ALTER TABLE package_subclasses DROP COLUMN pkg_sc_created;
    ALTER TABLE package_subclasses DROP COLUMN pkg_sc_last_modified;
    ALTER TABLE package_subclasses ALTER COLUMN pkg_sc_name TYPE TEXT;
    COMMENT ON TABLE package_subclasses IS
        'Subclass of package. Can refer either to versioned schema (that adds suffix at the end)
         or non-versioned (basic) one (without suffix at the end)';

    -- remove vcf reference, created and last modified (will be moved to deployment_events table), add comments,
    -- change varchar to text and bump version of pgpm to 0.0.6
    ALTER TABLE packages DROP COLUMN pkg_created;
    ALTER TABLE packages DROP COLUMN pkg_last_modified;
    ALTER TABLE packages DROP COLUMN pkg_vcs_ref;
    ALTER TABLE packages ALTER COLUMN pkg_name TYPE TEXT;
    ALTER TABLE packages ALTER COLUMN pkg_v_pre TYPE TEXT;
    ALTER TABLE packages ALTER COLUMN pkg_v_metadata TYPE TEXT;
    UPDATE packages SET pkg_v_major = 0, pkg_v_minor = 0, pkg_v_patch = 6 WHERE pkg_name = '_pgpm';
    COMMENT ON TABLE packages IS
        'Information about package (schema) tracked with pgpm.';
    COMMENT ON COLUMN packages.pkg_v_major IS
        'Major part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_minor IS
        'Minor part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_patch IS
        'Patch part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_pre IS
        'Pre part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_metadata IS
        'Metadata part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_old_rev IS
        'Incremental number of the revision of the package of the same version.
         Used the following way. If package deployed with the version of already existing package in moderate mode then
         old package is renamed by adding an ending with incremental revision (starting with 0)';
    COMMENT ON COLUMN packages.pkg_license IS
        'Name of license (or a link) of a package';

    -- change Primary key to combination of 2 keys and remove old key
    ALTER TABLE package_dependencies DROP CONSTRAINT package_dependency_pkey;
    ALTER TABLE package_dependencies ADD CONSTRAINT package_dependency_pkey PRIMARY KEY (pkg_link_core_id, pkg_link_dep_id);
    COMMENT ON TABLE package_dependencies IS
        'Many to many relationship between dependant packages. Package cannot depend on itself';

    CREATE TABLE deployment_events
    (
        dpl_ev_pkg_id INTEGER,
        dpl_ev_vcs_ref TEXT,
        dpl_ev_vcs_link TEXT,
        dpl_ev_time TIMESTAMP DEFAULT NOW(),
        dpl_ev_issue_id TEXT,
        dpl_ev_issue_link TEXT,
        CONSTRAINT dpl_ev_pkg_fkey FOREIGN KEY (dpl_ev_pkg_id) REFERENCES packages (pkg_id)
    );
    COMMENT ON TABLE deployment_events IS
        'Table tracks all deployments tracked by pgpm';
    COMMENT ON COLUMN deployment_events.dpl_ev_vcs_ref IS
        'Reference to VCS point that was installed.
         In case of git, best option is to put here a specific commit reference.
         In case of SVN, revision number.';
    COMMENT ON COLUMN deployment_events.dpl_ev_vcs_link IS
        'Link to VCS repository.';
    COMMENT ON COLUMN deployment_events.dpl_ev_time IS
        'Deployment time';
    COMMENT ON COLUMN deployment_events.dpl_ev_issue_id IS
        'ID of an issue in issue tracker. E.g. ABS-111 for JIRA.';
    COMMENT ON COLUMN deployment_events.dpl_ev_issue_link IS
        'Link to an issue related to this deployment in issue tracker.';

END$$;
2015-12-10 17:13:18,821 - pgpm.app - DEBUG - Running version upgrade script 0.0.7-0.1.3.tmpl.sql
2015-12-10 17:13:18,821 - pgpm.app - DEBUG - /*
    Migration script from version 0.7.0 to 0.1.3 (or higher if tool doesn't find other migration scripts)
 */
DROP FUNCTION IF EXISTS _pgpm._add_package_info(TEXT, TEXT, INTEGER, INTEGER, INTEGER, INTEGER, TEXT, TEXT, TEXT, TEXT, INTEGER[], TEXT);

CREATE TABLE IF NOT EXISTS _pgpm.migrations_log
(
    m_id SERIAL NOT NULL,
    m_low_v TEXT,
    m_high_v TEXT,
    m_created TIMESTAMP DEFAULT NOW(),
    CONSTRAINT migrations_log_pkey PRIMARY KEY (m_id)
);
INSERT INTO _pgpm.migrations_log (m_low_v, m_high_v)
SELECT '0.0.1', '0.0.6'
WHERE
    NOT EXISTS (
        SELECT m_low_v, m_high_v FROM _pgpm.migrations_log
        WHERE m_low_v = '0.0.1' AND m_high_v = '0.0.6'
    );
COMMENT ON TABLE _pgpm.migrations_log IS
    'Logs each migration of pgpm to newer version. TODO: add statuses';

ALTER TABLE _pgpm.deployment_events DROP CONSTRAINT IF EXISTS dpl_ev_pkey;
ALTER TABLE _pgpm.deployment_events ADD CONSTRAINT dpl_ev_pkey PRIMARY KEY (dpl_ev_pkg_id, dpl_ev_time);
2015-12-10 17:13:18,826 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.7.0 to 0.1.3 (or higher if tool doesn't find other migration scripts)
 */
DROP FUNCTION IF EXISTS _pgpm._add_package_info(TEXT, TEXT, INTEGER, INTEGER, INTEGER, INTEGER, TEXT, TEXT, TEXT, TEXT, INTEGER[], TEXT);

CREATE TABLE IF NOT EXISTS _pgpm.migrations_log
(
    m_id SERIAL NOT NULL,
    m_low_v TEXT,
    m_high_v TEXT,
    m_created TIMESTAMP DEFAULT NOW(),
    CONSTRAINT migrations_log_pkey PRIMARY KEY (m_id)
);
INSERT INTO _pgpm.migrations_log (m_low_v, m_high_v)
SELECT '0.0.1', '0.0.6'
WHERE
    NOT EXISTS (
        SELECT m_low_v, m_high_v FROM _pgpm.migrations_log
        WHERE m_low_v = '0.0.1' AND m_high_v = '0.0.6'
    );
COMMENT ON TABLE _pgpm.migrations_log IS
    'Logs each migration of pgpm to newer version. TODO: add statuses';

ALTER TABLE _pgpm.deployment_events DROP CONSTRAINT IF EXISTS dpl_ev_pkey;
ALTER TABLE _pgpm.deployment_events ADD CONSTRAINT dpl_ev_pkey PRIMARY KEY (dpl_ev_pkg_id, dpl_ev_time);
2015-12-10 17:13:18,826 - pgpm.app - DEBUG - Running version upgrade script 0.1.4-0.1.5.tmpl.sql
2015-12-10 17:13:18,826 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.4 to 0.1.5 (or higher if tool doesn't find other migration scripts)
 */
DO $$
    BEGIN
        BEGIN
            ALTER TABLE _pgpm.deployment_events ADD COLUMN dpl_ev_id SERIAL NOT NULL;
            ALTER TABLE _pgpm.deployment_events DROP CONSTRAINT IF EXISTS dpl_ev_pkey;
            ALTER TABLE _pgpm.deployment_events ADD CONSTRAINT dpl_ev_pkey PRIMARY KEY (dpl_ev_id);
        EXCEPTION
            WHEN duplicate_column THEN RAISE NOTICE 'column dpl_ev_id already exists in _pgpm.deployment_events.';
        END;
    END;
$$

2015-12-10 17:13:18,831 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.4 to 0.1.5 (or higher if tool doesn't find other migration scripts)
 */
DO $$
    BEGIN
        BEGIN
            ALTER TABLE _pgpm.deployment_events ADD COLUMN dpl_ev_id SERIAL NOT NULL;
            ALTER TABLE _pgpm.deployment_events DROP CONSTRAINT IF EXISTS dpl_ev_pkey;
            ALTER TABLE _pgpm.deployment_events ADD CONSTRAINT dpl_ev_pkey PRIMARY KEY (dpl_ev_id);
        EXCEPTION
            WHEN duplicate_column THEN RAISE NOTICE 'column dpl_ev_id already exists in _pgpm.deployment_events.';
        END;
    END;
$$

2015-12-10 17:13:18,832 - pgpm.app - DEBUG - Running version upgrade script 0.1.6-0.1.7.tmpl.sql
2015-12-10 17:13:18,832 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.6 to 0.1.7 (or higher if tool doesn't find other migration scripts)
 */
ALTER TABLE _pgpm.packages DROP CONSTRAINT IF EXISTS pkg_unique;
ALTER TABLE _pgpm.packages ADD CONSTRAINT pkg_unique UNIQUE (pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch, pkg_v_pre, pkg_old_rev);
2015-12-10 17:13:18,833 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.6 to 0.1.7 (or higher if tool doesn't find other migration scripts)
 */
ALTER TABLE _pgpm.packages DROP CONSTRAINT IF EXISTS pkg_unique;
ALTER TABLE _pgpm.packages ADD CONSTRAINT pkg_unique UNIQUE (pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch, pkg_v_pre, pkg_old_rev);
2015-12-10 17:13:18,833 - pgpm.app - DEBUG - Running version upgrade script 0.1.8-0.1.9.tmpl.sql
2015-12-10 17:13:18,833 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.8 to 0.1.9 (or higher if tool doesn't find other migration scripts)
 */
CREATE TABLE IF NOT EXISTS _pgpm.package_statuses
(
    pkg_s_id SERIAL NOT NULL,
    pkg_s_name TEXT,
    CONSTRAINT pkg_s_pkey PRIMARY KEY (pkg_s_id)
);
COMMENT ON TABLE _pgpm.package_statuses IS
    'Package statuses';
INSERT INTO _pgpm.package_statuses (pkg_s_id, pkg_s_name)
SELECT 1, 'ADDED'
WHERE
    NOT EXISTS (
        SELECT pkg_s_id, pkg_s_name FROM _pgpm.package_statuses
        WHERE pkg_s_id = 1
    );

INSERT INTO _pgpm.package_statuses (pkg_s_id, pkg_s_name)
SELECT 2, 'IN PROGRESS'
WHERE
    NOT EXISTS (
        SELECT pkg_s_id, pkg_s_name FROM _pgpm.package_statuses
        WHERE pkg_s_id = 2
    );

INSERT INTO _pgpm.package_statuses (pkg_s_id, pkg_s_name)
SELECT 3, 'DELETED'
WHERE
    NOT EXISTS (
        SELECT pkg_s_id, pkg_s_name FROM _pgpm.package_statuses
        WHERE pkg_s_id = 3
    );

ALTER TABLE _pgpm.packages ADD COLUMN pkg_status INTEGER DEFAULT 1;
ALTER TABLE _pgpm.packages ADD CONSTRAINT pkg_status_fkey FOREIGN KEY (pkg_status) REFERENCES _pgpm.package_statuses (pkg_s_id);
2015-12-10 17:13:18,842 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.8 to 0.1.9 (or higher if tool doesn't find other migration scripts)
 */
CREATE TABLE IF NOT EXISTS _pgpm.package_statuses
(
    pkg_s_id SERIAL NOT NULL,
    pkg_s_name TEXT,
    CONSTRAINT pkg_s_pkey PRIMARY KEY (pkg_s_id)
);
COMMENT ON TABLE _pgpm.package_statuses IS
    'Package statuses';
INSERT INTO _pgpm.package_statuses (pkg_s_id, pkg_s_name)
SELECT 1, 'ADDED'
WHERE
    NOT EXISTS (
        SELECT pkg_s_id, pkg_s_name FROM _pgpm.package_statuses
        WHERE pkg_s_id = 1
    );

INSERT INTO _pgpm.package_statuses (pkg_s_id, pkg_s_name)
SELECT 2, 'IN PROGRESS'
WHERE
    NOT EXISTS (
        SELECT pkg_s_id, pkg_s_name FROM _pgpm.package_statuses
        WHERE pkg_s_id = 2
    );

INSERT INTO _pgpm.package_statuses (pkg_s_id, pkg_s_name)
SELECT 3, 'DELETED'
WHERE
    NOT EXISTS (
        SELECT pkg_s_id, pkg_s_name FROM _pgpm.package_statuses
        WHERE pkg_s_id = 3
    );

ALTER TABLE _pgpm.packages ADD COLUMN pkg_status INTEGER DEFAULT 1;
ALTER TABLE _pgpm.packages ADD CONSTRAINT pkg_status_fkey FOREIGN KEY (pkg_status) REFERENCES _pgpm.package_statuses (pkg_s_id);
2015-12-10 17:13:18,842 - pgpm.app - DEBUG - Running version upgrade script 0.1.10-0.1.10.tmpl.sql
2015-12-10 17:13:18,842 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.10 to 0.1.10 (or higher if tool doesn't find other migration scripts)
 */

CREATE TABLE IF NOT EXISTS _pgpm.ddl_changes_log
(
    ddl_change_id SERIAL NOT NULL,
    dpl_ev_id INTEGER,
    ddl_change_user NAME DEFAULT current_user,
    ddl_change TEXT,
    ddl_change_txid BIGINT DEFAULT txid_current(),
    ddl_change_created TIMESTAMP DEFAULT NOW(),
    CONSTRAINT ddl_change_pkey PRIMARY KEY (ddl_change_id)
);
COMMENT ON TABLE _pgpm.ddl_changes_log IS
    'Log of changes of DDL in database linked to deployment events if happened through deployment';

DROP EVENT TRIGGER IF EXISTS ddl_change_trigger;
CREATE EVENT TRIGGER ddl_change_trigger
ON ddl_command_end
WHEN TAG IN (
'ALTER AGGREGATE',
'ALTER COLLATION',
'ALTER CONVERSION',
'ALTER DOMAIN',
'ALTER EXTENSION',
'ALTER FOREIGN DATA WRAPPER',
'ALTER FOREIGN TABLE',
'ALTER FUNCTION',
'ALTER LANGUAGE',
'ALTER OPERATOR',
'ALTER OPERATOR CLASS',
'ALTER OPERATOR FAMILY',
'ALTER SCHEMA',
'ALTER SEQUENCE',
'ALTER SERVER',
'ALTER TABLE',
'ALTER TEXT SEARCH CONFIGURATION',
'ALTER TEXT SEARCH DICTIONARY',
'ALTER TEXT SEARCH PARSER',
'ALTER TEXT SEARCH TEMPLATE',
'ALTER TRIGGER',
'ALTER TYPE',
'ALTER USER MAPPING',
'ALTER VIEW',
'CREATE AGGREGATE',
'CREATE CAST',
'CREATE COLLATION',
'CREATE CONVERSION',
'CREATE DOMAIN',
'CREATE EXTENSION',
'CREATE FOREIGN DATA WRAPPER',
'CREATE FOREIGN TABLE',
'CREATE FUNCTION',
'CREATE INDEX',
'CREATE LANGUAGE',
'CREATE OPERATOR',
'CREATE OPERATOR CLASS',
'CREATE OPERATOR FAMILY',
'CREATE RULE',
'CREATE SCHEMA',
'CREATE SEQUENCE',
'CREATE SERVER',
'CREATE TABLE',
'CREATE TABLE AS',
'CREATE TEXT SEARCH CONFIGURATION',
'CREATE TEXT SEARCH DICTIONARY',
'CREATE TEXT SEARCH PARSER',
'CREATE TEXT SEARCH TEMPLATE',
'CREATE TRIGGER',
'CREATE TYPE',
'CREATE USER MAPPING',
'CREATE VIEW',
'DROP AGGREGATE',
'DROP CAST',
'DROP COLLATION',
'DROP CONVERSION',
'DROP DOMAIN',
'DROP EXTENSION',
'DROP FOREIGN DATA WRAPPER',
'DROP FOREIGN TABLE',
'DROP FUNCTION',
'DROP INDEX',
'DROP LANGUAGE',
'DROP OPERATOR',
'DROP OPERATOR CLASS',
'DROP OPERATOR FAMILY',
'DROP OWNED',
'DROP RULE',
'DROP SCHEMA',
'DROP SEQUENCE',
'DROP SERVER',
'DROP TABLE',
'DROP TEXT SEARCH CONFIGURATION',
'DROP TEXT SEARCH DICTIONARY',
'DROP TEXT SEARCH PARSER',
'DROP TEXT SEARCH TEMPLATE',
'DROP TRIGGER',
'DROP TYPE',
'DROP USER MAPPING',
'DROP VIEW')
EXECUTE PROCEDURE _pgpm._log_ddl_change();
2015-12-10 17:13:18,846 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.10 to 0.1.10 (or higher if tool doesn't find other migration scripts)
 */

CREATE TABLE IF NOT EXISTS _pgpm.ddl_changes_log
(
    ddl_change_id SERIAL NOT NULL,
    dpl_ev_id INTEGER,
    ddl_change_user NAME DEFAULT current_user,
    ddl_change TEXT,
    ddl_change_txid BIGINT DEFAULT txid_current(),
    ddl_change_created TIMESTAMP DEFAULT NOW(),
    CONSTRAINT ddl_change_pkey PRIMARY KEY (ddl_change_id)
);
COMMENT ON TABLE _pgpm.ddl_changes_log IS
    'Log of changes of DDL in database linked to deployment events if happened through deployment';

DROP EVENT TRIGGER IF EXISTS ddl_change_trigger;
CREATE EVENT TRIGGER ddl_change_trigger
ON ddl_command_end
WHEN TAG IN (
'ALTER AGGREGATE',
'ALTER COLLATION',
'ALTER CONVERSION',
'ALTER DOMAIN',
'ALTER EXTENSION',
'ALTER FOREIGN DATA WRAPPER',
'ALTER FOREIGN TABLE',
'ALTER FUNCTION',
'ALTER LANGUAGE',
'ALTER OPERATOR',
'ALTER OPERATOR CLASS',
'ALTER OPERATOR FAMILY',
'ALTER SCHEMA',
'ALTER SEQUENCE',
'ALTER SERVER',
'ALTER TABLE',
'ALTER TEXT SEARCH CONFIGURATION',
'ALTER TEXT SEARCH DICTIONARY',
'ALTER TEXT SEARCH PARSER',
'ALTER TEXT SEARCH TEMPLATE',
'ALTER TRIGGER',
'ALTER TYPE',
'ALTER USER MAPPING',
'ALTER VIEW',
'CREATE AGGREGATE',
'CREATE CAST',
'CREATE COLLATION',
'CREATE CONVERSION',
'CREATE DOMAIN',
'CREATE EXTENSION',
'CREATE FOREIGN DATA WRAPPER',
'CREATE FOREIGN TABLE',
'CREATE FUNCTION',
'CREATE INDEX',
'CREATE LANGUAGE',
'CREATE OPERATOR',
'CREATE OPERATOR CLASS',
'CREATE OPERATOR FAMILY',
'CREATE RULE',
'CREATE SCHEMA',
'CREATE SEQUENCE',
'CREATE SERVER',
'CREATE TABLE',
'CREATE TABLE AS',
'CREATE TEXT SEARCH CONFIGURATION',
'CREATE TEXT SEARCH DICTIONARY',
'CREATE TEXT SEARCH PARSER',
'CREATE TEXT SEARCH TEMPLATE',
'CREATE TRIGGER',
'CREATE TYPE',
'CREATE USER MAPPING',
'CREATE VIEW',
'DROP AGGREGATE',
'DROP CAST',
'DROP COLLATION',
'DROP CONVERSION',
'DROP DOMAIN',
'DROP EXTENSION',
'DROP FOREIGN DATA WRAPPER',
'DROP FOREIGN TABLE',
'DROP FUNCTION',
'DROP INDEX',
'DROP LANGUAGE',
'DROP OPERATOR',
'DROP OPERATOR CLASS',
'DROP OPERATOR FAMILY',
'DROP OWNED',
'DROP RULE',
'DROP SCHEMA',
'DROP SEQUENCE',
'DROP SERVER',
'DROP TABLE',
'DROP TEXT SEARCH CONFIGURATION',
'DROP TEXT SEARCH DICTIONARY',
'DROP TEXT SEARCH PARSER',
'DROP TEXT SEARCH TEMPLATE',
'DROP TRIGGER',
'DROP TYPE',
'DROP USER MAPPING',
'DROP VIEW')
EXECUTE PROCEDURE _pgpm._log_ddl_change();
2015-12-10 17:13:18,846 - pgpm.app - DEBUG - Running version upgrade script 0.1.11-0.1.11.tmpl.sql
2015-12-10 17:13:18,846 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.11 to 0.1.11 (or higher if tool doesn't find other migration scripts)
 */

ALTER TABLE _pgpm.ddl_changes_log DROP COLUMN dpl_ev_id;
ALTER TABLE _pgpm.deployment_events ADD COLUMN dpl_ev_txid BIGINT;

2015-12-10 17:13:18,847 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.11 to 0.1.11 (or higher if tool doesn't find other migration scripts)
 */

ALTER TABLE _pgpm.ddl_changes_log DROP COLUMN dpl_ev_id;
ALTER TABLE _pgpm.deployment_events ADD COLUMN dpl_ev_txid BIGINT;

2015-12-10 17:13:18,847 - pgpm.app - DEBUG - Running version upgrade script 0.1.12-0.1.12.tmpl.sql
2015-12-10 17:13:18,847 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.12 to 0.1.12 (or higher if tool doesn't find other migration scripts)
 */

CREATE TABLE _pgpm.table_evolutions_log (
    t_evo_id SERIAL NOT NULL,
    t_evo_file_name TEXT,
    t_evo_package INTEGER,
    CONSTRAINT table_evolutions_log_pkey PRIMARY KEY (t_evo_id),
    CONSTRAINT package_fkey FOREIGN KEY (t_evo_package) REFERENCES _pgpm.packages (pkg_id)
);
2015-12-10 17:13:18,852 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.12 to 0.1.12 (or higher if tool doesn't find other migration scripts)
 */

CREATE TABLE _pgpm.table_evolutions_log (
    t_evo_id SERIAL NOT NULL,
    t_evo_file_name TEXT,
    t_evo_package INTEGER,
    CONSTRAINT table_evolutions_log_pkey PRIMARY KEY (t_evo_id),
    CONSTRAINT package_fkey FOREIGN KEY (t_evo_package) REFERENCES _pgpm.packages (pkg_id)
);
2015-12-10 17:13:18,852 - pgpm.app - DEBUG - Running version upgrade script 0.1.13-0.1.17.tmpl.sql
2015-12-10 17:13:18,852 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.13 to 0.1.17 (or higher if tool doesn't find other migration scripts)
 */

ALTER TABLE _pgpm.table_evolutions_log ADD COLUMN t_evo_created TIMESTAMP DEFAULT NOW();

2015-12-10 17:13:18,857 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.13 to 0.1.17 (or higher if tool doesn't find other migration scripts)
 */

ALTER TABLE _pgpm.table_evolutions_log ADD COLUMN t_evo_created TIMESTAMP DEFAULT NOW();

2015-12-10 17:13:18,858 - pgpm.app - DEBUG - Running version upgrade script 0.1.18-0.1.18.tmpl.sql
2015-12-10 17:13:18,858 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.18 to 0.1.18 (or higher if tool doesn't find other migration scripts)
 */
COMMENT ON TABLE _pgpm.table_evolutions_log IS
    'Table tracks all table evolution statements (ALTER TABLE + DML) for pgpm packages';
COMMENT ON COLUMN _pgpm.table_evolutions_log.t_evo_file_name IS
    'File name acts as a key to check whether evolution has already been applied or not';
2015-12-10 17:13:18,858 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.18 to 0.1.18 (or higher if tool doesn't find other migration scripts)
 */
COMMENT ON TABLE _pgpm.table_evolutions_log IS
    'Table tracks all table evolution statements (ALTER TABLE + DML) for pgpm packages';
COMMENT ON COLUMN _pgpm.table_evolutions_log.t_evo_file_name IS
    'File name acts as a key to check whether evolution has already been applied or not';
2015-12-10 17:13:18,858 - pgpm.app - DEBUG - Running version upgrade script 0.1.19-0.1.33.tmpl.sql
2015-12-10 17:13:18,858 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.19 to 0.1.33 (or higher if tool doesn't find other migration scripts)
 */

ALTER TABLE _pgpm.ddl_changes_log ALTER COLUMN ddl_change_user SET DEFAULT session_user;
2015-12-10 17:13:18,859 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.19 to 0.1.33 (or higher if tool doesn't find other migration scripts)
 */

ALTER TABLE _pgpm.ddl_changes_log ALTER COLUMN ddl_change_user SET DEFAULT session_user;
2015-12-10 17:13:18,860 - pgpm.app - DEBUG - Calling stored procedure: SELECT * FROM _add_migration_info('0.0.7','0.1.49')
2015-12-10 17:13:18,866 - pgpm.app - DEBUG - No user was specified to have permisions on _pgpm schema. This means only user that installed _pgpm will be able to deploy. We recommend adding more users.
2015-12-10 17:13:18,866 - pgpm.app - DEBUG - Executing query: set search_path TO _pgpm, public;
2015-12-10 17:13:18,870 - pgpm.app - DEBUG - Calling stored procedure: SELECT * FROM _upsert_package_info('_pgpm','basic','0','1','49',NULL,NULL,'Package manager for Postgres','MIT')
2015-12-10 17:13:18,870 - pgpm.app - DEBUG - Closing connection to host=localhost port=5432 dbname=pgpm_test_1 user=apanchoyan...
2015-12-10 17:13:18,870 - pgpm.app - DEBUG - Connection to host=localhost port=5432 dbname=pgpm_test_1 user=apanchoyan closed.
2015-12-10 17:13:18,870 - pgpm.app - INFO - Successfully installed host=localhost port=5432 dbname=pgpm_test_1 user=apanchoyan
2015-12-10 17:13:18,870 - pgpm.app - INFO - Installing... host=localhost port=5432 dbname=pgpm_test_2 user=apanchoyan
2015-12-10 17:13:18,874 - pgpm.app - DEBUG - lib/db_scripts/functions/_add_migration_info.sql
2015-12-10 17:13:18,874 - pgpm.app - DEBUG - lib/db_scripts/functions/_alter_schema_owner.sql
2015-12-10 17:13:18,874 - pgpm.app - DEBUG - lib/db_scripts/functions/_find_schema.sql
2015-12-10 17:13:18,875 - pgpm.app - DEBUG - lib/db_scripts/functions/_is_table_ddl_executed.sql
2015-12-10 17:13:18,875 - pgpm.app - DEBUG - lib/db_scripts/functions/_log_ddl_change.sql
2015-12-10 17:13:18,875 - pgpm.app - DEBUG - lib/db_scripts/functions/_log_table_evolution.sql
2015-12-10 17:13:18,875 - pgpm.app - DEBUG - lib/db_scripts/functions/_set_revision_package.sql
2015-12-10 17:13:18,875 - pgpm.app - DEBUG - lib/db_scripts/functions/_upsert_package_info.sql
2015-12-10 17:13:18,875 - pgpm.app - DEBUG - lib/db_scripts/functions/set_search_path.sql
2015-12-10 17:13:18,876 - pgpm.app - DEBUG - Executing query: select * from CURRENT_USER;
2015-12-10 17:13:18,877 - pgpm.app - DEBUG - Executing query: select usesuper from pg_user where usename = CURRENT_USER;
2015-12-10 17:13:18,879 - pgpm.app - DEBUG - Executing query: SELECT EXISTS (SELECT schema_name FROM information_schema.schemata WHERE schema_name = '_pgpm');
2015-12-10 17:13:18,879 - pgpm.app - INFO - Executing a preamble to install statement
2015-12-10 17:13:18,880 - pgpm.app - DEBUG - Executing query: -- Preparation SET statements for deployment
SET statement_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = off;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET escape_string_warning = off;
2015-12-10 17:13:18,880 - pgpm.app - INFO - Installing package manager
2015-12-10 17:13:18,895 - pgpm.app - DEBUG - Executing query: DO
$$BEGIN
    CREATE SCHEMA _pgpm;
    SET search_path TO _pgpm, public;

    CREATE TABLE package_subclasses
    (
        pkg_sc_id SERIAL NOT NULL,
        pkg_sc_name TEXT,
        pkg_sc_created TIMESTAMP DEFAULT now(),
        pkg_sc_last_modified TIMESTAMP DEFAULT now(),
        CONSTRAINT package_subclass_pkey PRIMARY KEY (pkg_sc_id)
    );
    INSERT INTO package_subclasses (pkg_sc_name)
        VALUES ('versioned');
    INSERT INTO package_subclasses (pkg_sc_name)
        VALUES ('basic');

    -- info on packages
    CREATE TABLE packages
    (
        pkg_id serial NOT NULL,
        pkg_name character varying(255),
        pkg_description text,
        pkg_v_major integer,
        pkg_v_minor integer,
        pkg_v_patch integer,
        pkg_v_pre character varying(255),
        pkg_v_metadata character varying(255),
        pkg_old_rev integer,
        pkg_vcs_ref varchar(255),
        pkg_subclass integer,
        pkg_license text,
        pkg_created timestamp without time zone DEFAULT now(),
        pkg_last_modified timestamp without time zone DEFAULT statement_timestamp(),
        CONSTRAINT package_pkey PRIMARY KEY (pkg_id),
        CONSTRAINT package_subclass_fkey FOREIGN KEY (pkg_subclass) REFERENCES package_subclasses (pkg_sc_id)
    );

    -- info on package dependencies
    CREATE TABLE package_dependencies
    (
        pkg_dep_id serial NOT NULL,
        pkg_link_core_id integer NOT NULL,
        pkg_link_dep_id integer NOT NULL CHECK (pkg_link_core_id <> pkg_link_dep_id),
        CONSTRAINT package_dependency_pkey PRIMARY KEY (pkg_dep_id),
        CONSTRAINT package_link_core_fkey FOREIGN KEY (pkg_link_core_id) REFERENCES packages (pkg_id),
        CONSTRAINT package_link_dependency_fkey FOREIGN KEY (pkg_link_dep_id) REFERENCES packages (pkg_id)
    );

END$$;
2015-12-10 17:13:18,895 - pgpm.app - INFO - Running functions definitions scripts
2015-12-10 17:13:18,895 - pgpm.app - DEBUG - {'_log_ddl_change.sql': u'CREATE OR REPLACE FUNCTION _log_ddl_change()\n    RETURNS EVENT_TRIGGER AS\n$BODY$\n---\n-- @description\n-- Logs any DDL changes to the DB\n--\n---\nDECLARE\n    l_current_query TEXT;\n    l_txid BIGINT;\nBEGIN\n\n    SELECT current_query() INTO l_current_query;\n    SELECT txid_current() INTO l_txid;\n    INSERT INTO _pgpm.ddl_changes_log (ddl_change)\n    SELECT l_current_query\n    WHERE\n        NOT EXISTS (\n            SELECT ddl_change_txid, ddl_change FROM _pgpm.ddl_changes_log\n            WHERE ddl_change_txid = l_txid AND ddl_change = l_current_query\n        );\n\n    -- Notify external channels of ddl change\n    PERFORM pg_notify(\'ddl_change\', "session_user"());\n\nEND;\n$BODY$\nLANGUAGE \'plpgsql\' VOLATILE SECURITY DEFINER;', '_add_migration_info.sql': u"CREATE OR REPLACE FUNCTION _add_migration_info(p_m_low_v TEXT, p_m_high_v TEXT)\n    RETURNS VOID AS\n$BODY$\n---\n-- @description\n-- Adds migration info migrations log table\n--\n-- @param p_m_low_v\n-- lower border of version that is applicaple for this migration\n--\n-- @param p_m_high_v\n-- package type: either version (with version suffix at the end of the name) or basic (without)\n--\n-- @param p_pkg_old_rev\n-- higher border of version that is applicaple for this migration\n--\n---\nBEGIN\n\n    BEGIN\n        INSERT INTO migrations_log (m_low_v, m_high_v)\n            VALUES (p_m_low_v, p_m_high_v);\n    EXCEPTION\n        WHEN SQLSTATE '42P01' THEN\n            RAISE WARNING 'Can''t log migration from % to % as migrations_log is not defined yet', p_m_low_v, p_m_high_v;\n    END;\nEND;\n$BODY$\nLANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", 'set_search_path.sql': u"CREATE OR REPLACE FUNCTION set_search_path(p_schema_name TEXT, p_v_req TEXT)\n    RETURNS json AS\n$BODY$\n---\n-- @description\n-- Sets search path that includes also all depending\n--\n-- @param p_schema_name\n-- Package (schema) name\n--\n-- @param p_v_req\n-- Package version requirement. Version notation supports:\n-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)\n-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x\n-- - comparison operators like >01_02_03 or <2\n-- - x for any latest version of package\n-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency\n--\n-- @returns\n-- JSON with schema names and exact versions or exception if not found\n---\nDECLARE\n    l_search_path TEXT;\n    l_search_path_deps TEXT;\n    l_listen_text TEXT;\n\n    l_pkg_version_wrapped RECORD;\n    l_pkg_version RECORD;\n\n    return_value json;\nBEGIN\n\n    SET search_path TO _pgpm;\n    SELECT _find_schema(p_schema_name, p_v_req) AS version INTO l_pkg_version_wrapped;\n    l_pkg_version := l_pkg_version_wrapped.version;\n\n    l_search_path := l_pkg_version.pkg_name || '_' ||\n                     l_pkg_version.pkg_v_major::text || '_' ||\n                     l_pkg_version.pkg_v_minor::text || '_' ||\n                     l_pkg_version.pkg_v_patch::text;\n\n    SELECT string_agg(pkg_name || '_' || pkg_v_major || '_' || pkg_v_minor || '_' || pkg_v_patch, ', ')\n    FROM packages\n    WHERE pkg_id IN (\n        SELECT pkg_link_dep_id from package_dependencies\n        JOIN packages ON pkg_id = l_pkg_version.pkg_id\n        WHERE pkg_link_core_id = pkg_id\n    )\n    INTO l_search_path_deps;\n\n    l_search_path := l_search_path || ', ' || l_search_path_deps;\n\n    l_listen_text := 'deployment_events' || '$$' || l_pkg_version.pkg_name;\n    EXECUTE 'LISTEN ' || l_listen_text;\n\n    RAISE INFO '%', l_search_path;\n    PERFORM set_config('search_path', l_search_path || ', public', false);\n\n    return_value := row_to_json(l_pkg_version);\n    RETURN return_value;\n\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_find_schema.sql': u"CREATE OR REPLACE FUNCTION _find_schema(p_schema_name TEXT, p_v_req TEXT)\n    RETURNS RECORD AS\n$BODY$\n---\n-- @description\n-- Searches for existing schema (package) within registered packages in _pgpm schema\n--\n-- @param p_schema_name\n-- Package (schema) name\n--\n-- @param p_v_req\n-- Package version requirement. Version notation supports:\n-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)\n-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x\n-- - comparison operators like >01_02_03 or <2\n-- - x for any latest version of package\n-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency\n--\n-- @returns\n-- Record containing schema name and exact version or exception if not found in the following format:\n-- pkg_name TEXT, pkg_v_major INTEGER, pkg_v_minor INTEGER, pkg_v_patch INTEGER\n---\nDECLARE\n    c_re_version TEXT = '^(<=|>=|<|>{0,2})(\\d*|x*)_?(\\d*|x*)_?(\\d*|x*)';\n    l_v_matches TEXT[];\n\n    l_v_major INTEGER;\n    l_v_minor INTEGER;\n    l_v_patch INTEGER;\n\n    return_value RECORD;\nBEGIN\n\n    SELECT regexp_matches(p_v_req, c_re_version, 'gi') INTO l_v_matches;\n\n    IF l_v_matches[2] ~* '^x+|^$' THEN\n        SELECT max(pkg_v_major)\n        FROM packages\n        WHERE pkg_name = p_schema_name\n        INTO l_v_major;\n    ELSE\n        l_v_major := l_v_matches[2]::integer;\n    END IF;\n\n    IF l_v_matches[3] ~* '^x+|^$' THEN\n        SELECT max(pkg_v_minor)\n        FROM packages\n        WHERE pkg_name = p_schema_name\n              AND pkg_v_major = l_v_major\n        INTO l_v_minor;\n    ELSE\n        l_v_minor := l_v_matches[3]::integer;\n    END IF;\n\n    IF l_v_matches[4] ~* '^x+|^$' THEN\n        SELECT max(pkg_v_patch)\n        FROM packages\n        WHERE pkg_name = p_schema_name\n              AND pkg_v_major = l_v_major\n              AND pkg_v_minor = l_v_minor\n        INTO l_v_patch;\n    ELSE\n        l_v_patch := l_v_matches[4]::integer;\n    END IF;\n\n    CASE l_v_matches[1]\n        WHEN '=', '' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND pkg_v_major = l_v_major\n                  AND pkg_v_minor = l_v_minor\n                  AND pkg_v_patch = l_v_patch\n            INTO return_value;\n        WHEN '<' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major < l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor < l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch < l_v_patch))\n            INTO return_value;\n        WHEN '>' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major > l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor > l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch > l_v_patch))\n            INTO return_value;\n        WHEN '<=' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major <= l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor <= l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch <= l_v_patch))\n            INTO return_value;\n        WHEN '>=' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major >= l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor >= l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch >= l_v_patch))\n            INTO return_value;\n        ELSE\n            RAISE EXCEPTION 'Invalid logical operand. Only <, >, =, <=, >=, = or no operand are allowed.' USING ERRCODE = '20000';\n    END CASE;\n\n    RETURN return_value;\n\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_upsert_package_info.sql': u"CREATE OR REPLACE FUNCTION _upsert_package_info(p_pkg_name TEXT,\n                                             p_pkg_subclass_name TEXT,\n                                             p_pkg_v_major INTEGER,\n                                             p_pkg_v_minor INTEGER DEFAULT 0,\n                                             p_pkg_v_patch INTEGER DEFAULT 0,\n                                             p_pkg_v_pre TEXT DEFAULT NULL,\n                                             p_pkg_v_metadata TEXT DEFAULT NULL,\n                                             p_pkg_description TEXT DEFAULT '',\n                                             p_pkg_license TEXT DEFAULT NULL,\n                                             p_pkg_deps_ids INTEGER[] DEFAULT '{}',\n                                             p_pkg_vcs_ref TEXT DEFAULT NULL,\n                                             p_pkg_vcs_link TEXT DEFAULT NULL,\n                                             p_pkg_issue_ref TEXT DEFAULT NULL,\n                                             p_pkg_issue_link TEXT DEFAULT NULL)\n    RETURNS INTEGER AS\n$BODY$\n---\n-- @description\n-- Adds package info to pgpm package info table, deployment events table and notifies channels of deployment\n--\n-- @param p_pkg_name\n-- package name\n--\n-- @param p_pkg_subclass_name\n-- package type: either version (with version suffix at the end of the name) or basic (without)\n--\n-- @param p_pkg_description\n-- package description\n--\n-- @param p_pkg_v_major\n-- package major part of version (according to semver)\n--\n-- @param p_pkg_v_minor\n-- package minor part of version (according to semver)\n--\n-- @param p_pkg_v_patch\n-- package patch part of version (according to semver)\n--\n-- @param p_pkg_v_pre\n-- package pre part of version (according to semver)\n--\n-- @param p_pkg_v_metadata\n-- package metadata part of version (according to semver)\n--\n-- @param p_pkg_license\n-- package license name/text\n--\n-- @param p_pkg_deps_ids\n-- IDs of dependent schemas\n--\n-- @param p_pkg_vcs_ref\n-- vcs reference to track the code\n--\n-- @param p_pkg_vcs_link\n-- repository link to track the code\n--\n-- @param p_pkg_issue_ref\n-- issue reference to track the code\n--\n-- @param p_pkg_issue_link\n-- issue tracking system link\n---\nDECLARE\n    l_existing_pkg_id INTEGER;\n    l_pkg_dep_id INTEGER;\n\n\treturn_value INTEGER;\nBEGIN\n\n    -- Case 1: unsafe mode, rewrite of the whole schema with the same version or some of the files in it\n    -- Case 2: new schema with new version (safe or moderate modes)\n\n    IF p_pkg_subclass_name = 'basic' THEN\n        SELECT pkg_id INTO l_existing_pkg_id\n        FROM packages\n        WHERE pkg_name = p_pkg_name\n            AND pkg_subclass IN (SELECT pkg_sc_id\n                                 FROM package_subclasses\n                                 WHERE pkg_sc_name = p_pkg_subclass_name);\n    ELSE\n        SELECT pkg_id INTO l_existing_pkg_id\n        FROM packages\n        WHERE pkg_name = p_pkg_name\n            AND pkg_subclass IN (SELECT pkg_sc_id\n                                 FROM package_subclasses\n                                 WHERE pkg_sc_name = p_pkg_subclass_name)\n            AND pkg_v_major = p_pkg_v_major\n            AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)\n            AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)\n            AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre)\n            AND pkg_old_rev IS NULL;\n    END IF;\n\n    IF FOUND THEN -- Case 1:\n        DELETE FROM package_dependencies\n            WHERE pkg_link_core_id = l_existing_pkg_id;\n\n        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids\n        LOOP\n            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (l_existing_pkg_id, l_pkg_dep_id);\n        END LOOP;\n\n        UPDATE packages\n        SET pkg_name=subquery.p_pkg_name,\n            pkg_subclass=subquery.pkg_sc_id,\n            pkg_v_major=subquery.p_pkg_v_major,\n            pkg_v_minor=subquery.p_pkg_v_minor,\n            pkg_v_patch=subquery.p_pkg_v_patch,\n            pkg_v_pre=subquery.p_pkg_v_pre,\n            pkg_v_metadata=subquery.p_pkg_v_metadata,\n            pkg_description=subquery.p_pkg_description,\n            pkg_license=subquery.p_pkg_license\n        FROM (SELECT\n                  p_pkg_name,\n                  pkg_sc_id,\n                  p_pkg_v_major,\n                  p_pkg_v_minor,\n                  p_pkg_v_patch,\n                  p_pkg_v_pre,\n                  p_pkg_v_metadata,\n                  p_pkg_description,\n                  p_pkg_license\n              FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name\n        ) as subquery\n        WHERE packages.pkg_name=subquery.p_pkg_name;\n\n        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)\n            VALUES (l_existing_pkg_id, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);\n\n        return_value := l_existing_pkg_id;\n    ELSE -- Case 2:\n        INSERT INTO packages (\n            pkg_name,\n            pkg_description,\n            pkg_v_major,\n            pkg_v_minor,\n            pkg_v_patch,\n            pkg_v_pre,\n            pkg_v_metadata,\n            pkg_subclass,\n            pkg_license\n        )\n        SELECT\n            p_pkg_name,\n            p_pkg_description,\n            p_pkg_v_major,\n            p_pkg_v_minor,\n            p_pkg_v_patch,\n            p_pkg_v_pre,\n            p_pkg_v_metadata,\n            pkg_sc_id,\n            p_pkg_license\n        FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name\n        RETURNING\n            pkg_id\n        INTO return_value;\n\n        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids\n        LOOP\n            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (return_value, l_pkg_dep_id);\n        END LOOP;\n\n        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)\n            VALUES (return_value, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);\n\n    END IF;\n\n    -- Notify external channels of successful deployment event\n    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);\n\n    RETURN return_value;\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_alter_schema_owner.sql': u"CREATE OR REPLACE FUNCTION _alter_schema_owner(p_schema TEXT, p_owner TEXT)\n    RETURNS VOID AS\n$BODY$\n---\n-- @description\n-- Alters ownership of schema and all its objects to a specified user.\n--\n-- @param p_schema\n-- Schema name\n--\n-- @param p_owner\n-- New owner user name\n--\n---\nDECLARE\n    l_schema TEXT;\n    l_functions TEXT;\n    l_tables TEXT;\n    l_sequences TEXT;\n    l_views TEXT;\n    l_domains TEXT;\n    l_triggers TEXT;\n    l_types TEXT;\n\nBEGIN\n\n    l_schema := 'ALTER SCHEMA '\n                || quote_ident(p_schema)\n                || ' OWNER TO '\n                || quote_ident(p_owner)\n                || ';';\n\n    SELECT string_agg('ALTER FUNCTION '\n                || quote_ident(n.nspname) || '.'\n                || quote_ident(p.proname) || '('\n                || pg_catalog.pg_get_function_identity_arguments(p.oid)\n                || ') OWNER TO ' || p_owner || ';'\n              , E'\\n') AS _sql\n    FROM   pg_catalog.pg_proc p\n    JOIN   pg_catalog.pg_namespace n ON n.oid = p.pronamespace\n    WHERE  n.nspname = p_schema\n    INTO l_functions;\n    IF l_functions IS NULL THEN\n        l_functions := '';\n    END IF;\n\n    SELECT string_agg('ALTER TABLE ' || quote_ident(schemaname) || '.' || quote_ident(tablename) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM pg_tables WHERE schemaname = p_schema\n    INTO l_tables;\n    IF l_tables IS NULL THEN\n        l_tables := '';\n    END IF;\n\n    SELECT string_agg('ALTER SEQUENCE ' || quote_ident(sequence_schema) || '.' || quote_ident(sequence_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.sequences WHERE sequence_schema = p_schema\n    INTO l_sequences;\n    IF l_sequences IS NULL THEN\n        l_sequences := '';\n    END IF;\n\n    SELECT string_agg('ALTER VIEW ' || quote_ident(table_schema) || '.' || quote_ident(table_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.views WHERE table_schema = p_schema\n    INTO l_views;\n    IF l_views IS NULL THEN\n        l_views := '';\n    END IF;\n\n    SELECT string_agg('ALTER DOMAIN ' || quote_ident(domain_schema) || '.' || quote_ident(domain_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.domains WHERE domain_schema = p_schema\n    INTO l_domains;\n    IF l_domains IS NULL THEN\n        l_domains := '';\n    END IF;\n\n    SELECT string_agg('ALTER TRIGGER ' || quote_ident(trigger_schema) || '.' || quote_ident(trigger_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.triggers WHERE trigger_schema = p_schema\n    INTO l_triggers;\n    IF l_triggers IS NULL THEN\n        l_triggers := '';\n    END IF;\n\n    SELECT string_agg('ALTER TYPE ' || quote_ident(user_defined_type_schema) || '.' || quote_ident(user_defined_type_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.user_defined_types WHERE user_defined_type_schema = p_schema\n    INTO l_types;\n    IF l_types IS NULL THEN\n        l_types := '';\n    END IF;\n\n    EXECUTE l_schema || l_functions || l_tables || l_sequences || l_views || l_domains || l_triggers || l_types;\n\nEND;\n$BODY$\nLANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;", '_log_table_evolution.sql': u"CREATE OR REPLACE FUNCTION _log_table_evolution(p_t_evo_file_name TEXT, p_t_evo_package INTEGER)\n    RETURNS VOID AS\n$BODY$\n---\n-- @description\n-- Adds information about executed table evolution script to log table\n--\n-- @param p_t_evo_file_name\n-- File name with executed statements.\n--\n-- @param p_t_evo_package\n-- Related package id\n--\n-- @param p_pkg_old_rev\n-- higher border of version that is applicaple for this migration\n--\n---\nBEGIN\n\n    INSERT INTO table_evolutions_log (t_evo_file_name, t_evo_package)\n        VALUES (p_t_evo_file_name, p_t_evo_package);\nEND;\n$BODY$\nLANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;", '_is_table_ddl_executed.sql': u"CREATE OR REPLACE FUNCTION _is_table_ddl_executed(p_file_name TEXT)\n    RETURNS BOOLEAN AS\n$BODY$\n---\n-- @description\n-- Checks whether file with table ddl has already been executed\n--\n-- @param p_file_name\n-- File name used to check whether statements were executed\n--\n-- @returns\n-- True if executed, False otherwise\n---\nDECLARE\n    return_value BOOLEAN;\nBEGIN\n\n    SELECT EXISTS (SELECT t_evo_id FROM table_evolutions_log WHERE t_evo_file_name=p_file_name) INTO return_value;\n\n    RETURN return_value;\n\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_set_revision_package.sql': u"CREATE OR REPLACE FUNCTION _set_revision_package(p_pkg_name TEXT,\n                                             p_pkg_subclass_name TEXT,\n                                             p_pkg_old_rev INTEGER,\n                                             p_pkg_v_major INTEGER,\n                                             p_pkg_v_minor INTEGER DEFAULT 0,\n                                             p_pkg_v_patch INTEGER DEFAULT 0,\n                                             p_pkg_v_pre TEXT DEFAULT NULL)\n    RETURNS INTEGER AS\n$BODY$\n---\n-- @description\n-- Set package as old revision, info logged in deployment events table\n--\n-- @param p_pkg_name\n-- package name\n--\n-- @param p_pkg_subclass_name\n-- package type: either version (with version suffix at the end of the name) or basic (without)\n--\n-- @param p_pkg_old_rev\n-- Revision name of package. Used in moderate form. When schema is renamed it is given a revision suffix from here\n--\n-- @param p_pkg_v_major\n-- package major part of version (according to semver)\n--\n-- @param p_pkg_v_minor\n-- package minor part of version (according to semver)\n--\n-- @param p_pkg_v_patch\n-- package patch part of version (according to semver)\n--\n-- @param p_pkg_v_pre\n-- package pre part of version (according to semver)\n--\n-- @param p_pkg_v_metadata\n-- package metadata part of version (according to semver)\n--\n-- @param p_pkg_vcs_ref\n-- vcs reference to track the code\n---\nDECLARE\n    l_existing_pkg_id INTEGER;\n    l_pkg_dep_id INTEGER;\n\n\treturn_value INTEGER;\nBEGIN\n\n    SELECT pkg_id INTO l_existing_pkg_id\n    FROM packages\n    WHERE pkg_name = p_pkg_name\n        AND pkg_subclass IN (SELECT pkg_sc_id\n                             FROM package_subclasses\n                             WHERE pkg_sc_name = p_pkg_subclass_name)\n        AND pkg_v_major = p_pkg_v_major\n        AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)\n        AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)\n        AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre);\n\n    IF FOUND THEN\n        UPDATE packages\n        SET pkg_old_rev=p_pkg_old_rev\n        WHERE packages.pkg_id=l_existing_pkg_id;\n\n        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)\n            SELECT pkg_id, txid_current(), dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link\n            FROM packages\n            JOIN deployment_events ON dpl_ev_pkg_id=pkg_id\n            WHERE pkg_id=l_existing_pkg_id AND dpl_ev_time IN (\n                SELECT max(dpl_ev_time) FROM deployment_events WHERE dpl_ev_pkg_id=packages.pkg_id\n            );\n    ELSE\n        RAISE EXCEPTION 'Package % not found in the list of packages. It could happen if schema exists but wasn''t properly deployed with pgpm', p_pkg_name || '_' || p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch;\n    END IF;\n\n    -- Notify external channels of successful deployment event\n    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);\n\n    RETURN return_value;\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n"}
2015-12-10 17:13:18,895 - pgpm.app - DEBUG - Executing query: set search_path TO _pgpm, public;
2015-12-10 17:13:18,896 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _log_ddl_change()
    RETURNS EVENT_TRIGGER AS
$BODY$
---
-- @description
-- Logs any DDL changes to the DB
--
---
DECLARE
    l_current_query TEXT;
    l_txid BIGINT;
BEGIN

    SELECT current_query() INTO l_current_query;
    SELECT txid_current() INTO l_txid;
    INSERT INTO _pgpm.ddl_changes_log (ddl_change)
    SELECT l_current_query
    WHERE
        NOT EXISTS (
            SELECT ddl_change_txid, ddl_change FROM _pgpm.ddl_changes_log
            WHERE ddl_change_txid = l_txid AND ddl_change = l_current_query
        );

    -- Notify external channels of ddl change
    PERFORM pg_notify('ddl_change', "session_user"());

END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;
2015-12-10 17:13:18,896 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _add_migration_info(p_m_low_v TEXT, p_m_high_v TEXT)
    RETURNS VOID AS
$BODY$
---
-- @description
-- Adds migration info migrations log table
--
-- @param p_m_low_v
-- lower border of version that is applicaple for this migration
--
-- @param p_m_high_v
-- package type: either version (with version suffix at the end of the name) or basic (without)
--
-- @param p_pkg_old_rev
-- higher border of version that is applicaple for this migration
--
---
BEGIN

    BEGIN
        INSERT INTO migrations_log (m_low_v, m_high_v)
            VALUES (p_m_low_v, p_m_high_v);
    EXCEPTION
        WHEN SQLSTATE '42P01' THEN
            RAISE WARNING 'Can''t log migration from % to % as migrations_log is not defined yet', p_m_low_v, p_m_high_v;
    END;
END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 17:13:18,897 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION set_search_path(p_schema_name TEXT, p_v_req TEXT)
    RETURNS json AS
$BODY$
---
-- @description
-- Sets search path that includes also all depending
--
-- @param p_schema_name
-- Package (schema) name
--
-- @param p_v_req
-- Package version requirement. Version notation supports:
-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)
-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x
-- - comparison operators like >01_02_03 or <2
-- - x for any latest version of package
-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency
--
-- @returns
-- JSON with schema names and exact versions or exception if not found
---
DECLARE
    l_search_path TEXT;
    l_search_path_deps TEXT;
    l_listen_text TEXT;

    l_pkg_version_wrapped RECORD;
    l_pkg_version RECORD;

    return_value json;
BEGIN

    SET search_path TO _pgpm;
    SELECT _find_schema(p_schema_name, p_v_req) AS version INTO l_pkg_version_wrapped;
    l_pkg_version := l_pkg_version_wrapped.version;

    l_search_path := l_pkg_version.pkg_name || '_' ||
                     l_pkg_version.pkg_v_major::text || '_' ||
                     l_pkg_version.pkg_v_minor::text || '_' ||
                     l_pkg_version.pkg_v_patch::text;

    SELECT string_agg(pkg_name || '_' || pkg_v_major || '_' || pkg_v_minor || '_' || pkg_v_patch, ', ')
    FROM packages
    WHERE pkg_id IN (
        SELECT pkg_link_dep_id from package_dependencies
        JOIN packages ON pkg_id = l_pkg_version.pkg_id
        WHERE pkg_link_core_id = pkg_id
    )
    INTO l_search_path_deps;

    l_search_path := l_search_path || ', ' || l_search_path_deps;

    l_listen_text := 'deployment_events' || '$$' || l_pkg_version.pkg_name;
    EXECUTE 'LISTEN ' || l_listen_text;

    RAISE INFO '%', l_search_path;
    PERFORM set_config('search_path', l_search_path || ', public', false);

    return_value := row_to_json(l_pkg_version);
    RETURN return_value;

END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 17:13:18,897 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _find_schema(p_schema_name TEXT, p_v_req TEXT)
    RETURNS RECORD AS
$BODY$
---
-- @description
-- Searches for existing schema (package) within registered packages in _pgpm schema
--
-- @param p_schema_name
-- Package (schema) name
--
-- @param p_v_req
-- Package version requirement. Version notation supports:
-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)
-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x
-- - comparison operators like >01_02_03 or <2
-- - x for any latest version of package
-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency
--
-- @returns
-- Record containing schema name and exact version or exception if not found in the following format:
-- pkg_name TEXT, pkg_v_major INTEGER, pkg_v_minor INTEGER, pkg_v_patch INTEGER
---
DECLARE
    c_re_version TEXT = '^(<=|>=|<|>{0,2})(\d*|x*)_?(\d*|x*)_?(\d*|x*)';
    l_v_matches TEXT[];

    l_v_major INTEGER;
    l_v_minor INTEGER;
    l_v_patch INTEGER;

    return_value RECORD;
BEGIN

    SELECT regexp_matches(p_v_req, c_re_version, 'gi') INTO l_v_matches;

    IF l_v_matches[2] ~* '^x+|^$' THEN
        SELECT max(pkg_v_major)
        FROM packages
        WHERE pkg_name = p_schema_name
        INTO l_v_major;
    ELSE
        l_v_major := l_v_matches[2]::integer;
    END IF;

    IF l_v_matches[3] ~* '^x+|^$' THEN
        SELECT max(pkg_v_minor)
        FROM packages
        WHERE pkg_name = p_schema_name
              AND pkg_v_major = l_v_major
        INTO l_v_minor;
    ELSE
        l_v_minor := l_v_matches[3]::integer;
    END IF;

    IF l_v_matches[4] ~* '^x+|^$' THEN
        SELECT max(pkg_v_patch)
        FROM packages
        WHERE pkg_name = p_schema_name
              AND pkg_v_major = l_v_major
              AND pkg_v_minor = l_v_minor
        INTO l_v_patch;
    ELSE
        l_v_patch := l_v_matches[4]::integer;
    END IF;

    CASE l_v_matches[1]
        WHEN '=', '' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND pkg_v_major = l_v_major
                  AND pkg_v_minor = l_v_minor
                  AND pkg_v_patch = l_v_patch
            INTO return_value;
        WHEN '<' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major < l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor < l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch < l_v_patch))
            INTO return_value;
        WHEN '>' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major > l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor > l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch > l_v_patch))
            INTO return_value;
        WHEN '<=' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major <= l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor <= l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch <= l_v_patch))
            INTO return_value;
        WHEN '>=' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major >= l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor >= l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch >= l_v_patch))
            INTO return_value;
        ELSE
            RAISE EXCEPTION 'Invalid logical operand. Only <, >, =, <=, >=, = or no operand are allowed.' USING ERRCODE = '20000';
    END CASE;

    RETURN return_value;

END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 17:13:18,898 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _upsert_package_info(p_pkg_name TEXT,
                                             p_pkg_subclass_name TEXT,
                                             p_pkg_v_major INTEGER,
                                             p_pkg_v_minor INTEGER DEFAULT 0,
                                             p_pkg_v_patch INTEGER DEFAULT 0,
                                             p_pkg_v_pre TEXT DEFAULT NULL,
                                             p_pkg_v_metadata TEXT DEFAULT NULL,
                                             p_pkg_description TEXT DEFAULT '',
                                             p_pkg_license TEXT DEFAULT NULL,
                                             p_pkg_deps_ids INTEGER[] DEFAULT '{}',
                                             p_pkg_vcs_ref TEXT DEFAULT NULL,
                                             p_pkg_vcs_link TEXT DEFAULT NULL,
                                             p_pkg_issue_ref TEXT DEFAULT NULL,
                                             p_pkg_issue_link TEXT DEFAULT NULL)
    RETURNS INTEGER AS
$BODY$
---
-- @description
-- Adds package info to pgpm package info table, deployment events table and notifies channels of deployment
--
-- @param p_pkg_name
-- package name
--
-- @param p_pkg_subclass_name
-- package type: either version (with version suffix at the end of the name) or basic (without)
--
-- @param p_pkg_description
-- package description
--
-- @param p_pkg_v_major
-- package major part of version (according to semver)
--
-- @param p_pkg_v_minor
-- package minor part of version (according to semver)
--
-- @param p_pkg_v_patch
-- package patch part of version (according to semver)
--
-- @param p_pkg_v_pre
-- package pre part of version (according to semver)
--
-- @param p_pkg_v_metadata
-- package metadata part of version (according to semver)
--
-- @param p_pkg_license
-- package license name/text
--
-- @param p_pkg_deps_ids
-- IDs of dependent schemas
--
-- @param p_pkg_vcs_ref
-- vcs reference to track the code
--
-- @param p_pkg_vcs_link
-- repository link to track the code
--
-- @param p_pkg_issue_ref
-- issue reference to track the code
--
-- @param p_pkg_issue_link
-- issue tracking system link
---
DECLARE
    l_existing_pkg_id INTEGER;
    l_pkg_dep_id INTEGER;

	return_value INTEGER;
BEGIN

    -- Case 1: unsafe mode, rewrite of the whole schema with the same version or some of the files in it
    -- Case 2: new schema with new version (safe or moderate modes)

    IF p_pkg_subclass_name = 'basic' THEN
        SELECT pkg_id INTO l_existing_pkg_id
        FROM packages
        WHERE pkg_name = p_pkg_name
            AND pkg_subclass IN (SELECT pkg_sc_id
                                 FROM package_subclasses
                                 WHERE pkg_sc_name = p_pkg_subclass_name);
    ELSE
        SELECT pkg_id INTO l_existing_pkg_id
        FROM packages
        WHERE pkg_name = p_pkg_name
            AND pkg_subclass IN (SELECT pkg_sc_id
                                 FROM package_subclasses
                                 WHERE pkg_sc_name = p_pkg_subclass_name)
            AND pkg_v_major = p_pkg_v_major
            AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)
            AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)
            AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre)
            AND pkg_old_rev IS NULL;
    END IF;

    IF FOUND THEN -- Case 1:
        DELETE FROM package_dependencies
            WHERE pkg_link_core_id = l_existing_pkg_id;

        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids
        LOOP
            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (l_existing_pkg_id, l_pkg_dep_id);
        END LOOP;

        UPDATE packages
        SET pkg_name=subquery.p_pkg_name,
            pkg_subclass=subquery.pkg_sc_id,
            pkg_v_major=subquery.p_pkg_v_major,
            pkg_v_minor=subquery.p_pkg_v_minor,
            pkg_v_patch=subquery.p_pkg_v_patch,
            pkg_v_pre=subquery.p_pkg_v_pre,
            pkg_v_metadata=subquery.p_pkg_v_metadata,
            pkg_description=subquery.p_pkg_description,
            pkg_license=subquery.p_pkg_license
        FROM (SELECT
                  p_pkg_name,
                  pkg_sc_id,
                  p_pkg_v_major,
                  p_pkg_v_minor,
                  p_pkg_v_patch,
                  p_pkg_v_pre,
                  p_pkg_v_metadata,
                  p_pkg_description,
                  p_pkg_license
              FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name
        ) as subquery
        WHERE packages.pkg_name=subquery.p_pkg_name;

        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)
            VALUES (l_existing_pkg_id, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);

        return_value := l_existing_pkg_id;
    ELSE -- Case 2:
        INSERT INTO packages (
            pkg_name,
            pkg_description,
            pkg_v_major,
            pkg_v_minor,
            pkg_v_patch,
            pkg_v_pre,
            pkg_v_metadata,
            pkg_subclass,
            pkg_license
        )
        SELECT
            p_pkg_name,
            p_pkg_description,
            p_pkg_v_major,
            p_pkg_v_minor,
            p_pkg_v_patch,
            p_pkg_v_pre,
            p_pkg_v_metadata,
            pkg_sc_id,
            p_pkg_license
        FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name
        RETURNING
            pkg_id
        INTO return_value;

        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids
        LOOP
            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (return_value, l_pkg_dep_id);
        END LOOP;

        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)
            VALUES (return_value, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);

    END IF;

    -- Notify external channels of successful deployment event
    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);

    RETURN return_value;
END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 17:13:18,899 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _alter_schema_owner(p_schema TEXT, p_owner TEXT)
    RETURNS VOID AS
$BODY$
---
-- @description
-- Alters ownership of schema and all its objects to a specified user.
--
-- @param p_schema
-- Schema name
--
-- @param p_owner
-- New owner user name
--
---
DECLARE
    l_schema TEXT;
    l_functions TEXT;
    l_tables TEXT;
    l_sequences TEXT;
    l_views TEXT;
    l_domains TEXT;
    l_triggers TEXT;
    l_types TEXT;

BEGIN

    l_schema := 'ALTER SCHEMA '
                || quote_ident(p_schema)
                || ' OWNER TO '
                || quote_ident(p_owner)
                || ';';

    SELECT string_agg('ALTER FUNCTION '
                || quote_ident(n.nspname) || '.'
                || quote_ident(p.proname) || '('
                || pg_catalog.pg_get_function_identity_arguments(p.oid)
                || ') OWNER TO ' || p_owner || ';'
              , E'\n') AS _sql
    FROM   pg_catalog.pg_proc p
    JOIN   pg_catalog.pg_namespace n ON n.oid = p.pronamespace
    WHERE  n.nspname = p_schema
    INTO l_functions;
    IF l_functions IS NULL THEN
        l_functions := '';
    END IF;

    SELECT string_agg('ALTER TABLE ' || quote_ident(schemaname) || '.' || quote_ident(tablename) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM pg_tables WHERE schemaname = p_schema
    INTO l_tables;
    IF l_tables IS NULL THEN
        l_tables := '';
    END IF;

    SELECT string_agg('ALTER SEQUENCE ' || quote_ident(sequence_schema) || '.' || quote_ident(sequence_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.sequences WHERE sequence_schema = p_schema
    INTO l_sequences;
    IF l_sequences IS NULL THEN
        l_sequences := '';
    END IF;

    SELECT string_agg('ALTER VIEW ' || quote_ident(table_schema) || '.' || quote_ident(table_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.views WHERE table_schema = p_schema
    INTO l_views;
    IF l_views IS NULL THEN
        l_views := '';
    END IF;

    SELECT string_agg('ALTER DOMAIN ' || quote_ident(domain_schema) || '.' || quote_ident(domain_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.domains WHERE domain_schema = p_schema
    INTO l_domains;
    IF l_domains IS NULL THEN
        l_domains := '';
    END IF;

    SELECT string_agg('ALTER TRIGGER ' || quote_ident(trigger_schema) || '.' || quote_ident(trigger_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.triggers WHERE trigger_schema = p_schema
    INTO l_triggers;
    IF l_triggers IS NULL THEN
        l_triggers := '';
    END IF;

    SELECT string_agg('ALTER TYPE ' || quote_ident(user_defined_type_schema) || '.' || quote_ident(user_defined_type_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.user_defined_types WHERE user_defined_type_schema = p_schema
    INTO l_types;
    IF l_types IS NULL THEN
        l_types := '';
    END IF;

    EXECUTE l_schema || l_functions || l_tables || l_sequences || l_views || l_domains || l_triggers || l_types;

END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;
2015-12-10 17:13:18,899 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _log_table_evolution(p_t_evo_file_name TEXT, p_t_evo_package INTEGER)
    RETURNS VOID AS
$BODY$
---
-- @description
-- Adds information about executed table evolution script to log table
--
-- @param p_t_evo_file_name
-- File name with executed statements.
--
-- @param p_t_evo_package
-- Related package id
--
-- @param p_pkg_old_rev
-- higher border of version that is applicaple for this migration
--
---
BEGIN

    INSERT INTO table_evolutions_log (t_evo_file_name, t_evo_package)
        VALUES (p_t_evo_file_name, p_t_evo_package);
END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;
2015-12-10 17:13:18,900 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _is_table_ddl_executed(p_file_name TEXT)
    RETURNS BOOLEAN AS
$BODY$
---
-- @description
-- Checks whether file with table ddl has already been executed
--
-- @param p_file_name
-- File name used to check whether statements were executed
--
-- @returns
-- True if executed, False otherwise
---
DECLARE
    return_value BOOLEAN;
BEGIN

    SELECT EXISTS (SELECT t_evo_id FROM table_evolutions_log WHERE t_evo_file_name=p_file_name) INTO return_value;

    RETURN return_value;

END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 17:13:18,900 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _set_revision_package(p_pkg_name TEXT,
                                             p_pkg_subclass_name TEXT,
                                             p_pkg_old_rev INTEGER,
                                             p_pkg_v_major INTEGER,
                                             p_pkg_v_minor INTEGER DEFAULT 0,
                                             p_pkg_v_patch INTEGER DEFAULT 0,
                                             p_pkg_v_pre TEXT DEFAULT NULL)
    RETURNS INTEGER AS
$BODY$
---
-- @description
-- Set package as old revision, info logged in deployment events table
--
-- @param p_pkg_name
-- package name
--
-- @param p_pkg_subclass_name
-- package type: either version (with version suffix at the end of the name) or basic (without)
--
-- @param p_pkg_old_rev
-- Revision name of package. Used in moderate form. When schema is renamed it is given a revision suffix from here
--
-- @param p_pkg_v_major
-- package major part of version (according to semver)
--
-- @param p_pkg_v_minor
-- package minor part of version (according to semver)
--
-- @param p_pkg_v_patch
-- package patch part of version (according to semver)
--
-- @param p_pkg_v_pre
-- package pre part of version (according to semver)
--
-- @param p_pkg_v_metadata
-- package metadata part of version (according to semver)
--
-- @param p_pkg_vcs_ref
-- vcs reference to track the code
---
DECLARE
    l_existing_pkg_id INTEGER;
    l_pkg_dep_id INTEGER;

	return_value INTEGER;
BEGIN

    SELECT pkg_id INTO l_existing_pkg_id
    FROM packages
    WHERE pkg_name = p_pkg_name
        AND pkg_subclass IN (SELECT pkg_sc_id
                             FROM package_subclasses
                             WHERE pkg_sc_name = p_pkg_subclass_name)
        AND pkg_v_major = p_pkg_v_major
        AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)
        AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)
        AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre);

    IF FOUND THEN
        UPDATE packages
        SET pkg_old_rev=p_pkg_old_rev
        WHERE packages.pkg_id=l_existing_pkg_id;

        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)
            SELECT pkg_id, txid_current(), dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link
            FROM packages
            JOIN deployment_events ON dpl_ev_pkg_id=pkg_id
            WHERE pkg_id=l_existing_pkg_id AND dpl_ev_time IN (
                SELECT max(dpl_ev_time) FROM deployment_events WHERE dpl_ev_pkg_id=packages.pkg_id
            );
    ELSE
        RAISE EXCEPTION 'Package % not found in the list of packages. It could happen if schema exists but wasn''t properly deployed with pgpm', p_pkg_name || '_' || p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch;
    END IF;

    -- Notify external channels of successful deployment event
    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);

    RETURN return_value;
END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 17:13:18,900 - pgpm.app - DEBUG - Functions loaded to schema _pgpm
2015-12-10 17:13:18,900 - pgpm.app - DEBUG - Running version upgrade script 0.0.1-0.0.6.tmpl.sql
2015-12-10 17:13:18,900 - pgpm.app - DEBUG - /*
    Migration script from version 0.0.1 to 0.0.6 (or higher if tool doesn't find other migration scripts)
 */
DO
$$BEGIN
    SET search_path TO _pgpm, public;
    GRANT USAGE ON SCHEMA _pgpm TO public;
    COMMENT ON SCHEMA _pgpm IS
        'Schema containing all information about postgres packages (name, version, dependencies, etc.)
         and utility functions';

    -- drop created and last modified in subclasses, add comment and change varchar to text
    ALTER TABLE package_subclasses DROP COLUMN pkg_sc_created;
    ALTER TABLE package_subclasses DROP COLUMN pkg_sc_last_modified;
    ALTER TABLE package_subclasses ALTER COLUMN pkg_sc_name TYPE TEXT;
    COMMENT ON TABLE package_subclasses IS
        'Subclass of package. Can refer either to versioned schema (that adds suffix at the end)
         or non-versioned (basic) one (without suffix at the end)';

    -- remove vcf reference, created and last modified (will be moved to deployment_events table), add comments,
    -- change varchar to text and bump version of pgpm to 0.0.6
    ALTER TABLE packages DROP COLUMN pkg_created;
    ALTER TABLE packages DROP COLUMN pkg_last_modified;
    ALTER TABLE packages DROP COLUMN pkg_vcs_ref;
    ALTER TABLE packages ALTER COLUMN pkg_name TYPE TEXT;
    ALTER TABLE packages ALTER COLUMN pkg_v_pre TYPE TEXT;
    ALTER TABLE packages ALTER COLUMN pkg_v_metadata TYPE TEXT;
    UPDATE packages SET pkg_v_major = 0, pkg_v_minor = 0, pkg_v_patch = 6 WHERE pkg_name = '_pgpm';
    COMMENT ON TABLE packages IS
        'Information about package (schema) tracked with pgpm.';
    COMMENT ON COLUMN packages.pkg_v_major IS
        'Major part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_minor IS
        'Minor part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_patch IS
        'Patch part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_pre IS
        'Pre part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_metadata IS
        'Metadata part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_old_rev IS
        'Incremental number of the revision of the package of the same version.
         Used the following way. If package deployed with the version of already existing package in moderate mode then
         old package is renamed by adding an ending with incremental revision (starting with 0)';
    COMMENT ON COLUMN packages.pkg_license IS
        'Name of license (or a link) of a package';

    -- change Primary key to combination of 2 keys and remove old key
    ALTER TABLE package_dependencies DROP CONSTRAINT package_dependency_pkey;
    ALTER TABLE package_dependencies ADD CONSTRAINT package_dependency_pkey PRIMARY KEY (pkg_link_core_id, pkg_link_dep_id);
    COMMENT ON TABLE package_dependencies IS
        'Many to many relationship between dependant packages. Package cannot depend on itself';

    CREATE TABLE deployment_events
    (
        dpl_ev_pkg_id INTEGER,
        dpl_ev_vcs_ref TEXT,
        dpl_ev_vcs_link TEXT,
        dpl_ev_time TIMESTAMP DEFAULT NOW(),
        dpl_ev_issue_id TEXT,
        dpl_ev_issue_link TEXT,
        CONSTRAINT dpl_ev_pkg_fkey FOREIGN KEY (dpl_ev_pkg_id) REFERENCES packages (pkg_id)
    );
    COMMENT ON TABLE deployment_events IS
        'Table tracks all deployments tracked by pgpm';
    COMMENT ON COLUMN deployment_events.dpl_ev_vcs_ref IS
        'Reference to VCS point that was installed.
         In case of git, best option is to put here a specific commit reference.
         In case of SVN, revision number.';
    COMMENT ON COLUMN deployment_events.dpl_ev_vcs_link IS
        'Link to VCS repository.';
    COMMENT ON COLUMN deployment_events.dpl_ev_time IS
        'Deployment time';
    COMMENT ON COLUMN deployment_events.dpl_ev_issue_id IS
        'ID of an issue in issue tracker. E.g. ABS-111 for JIRA.';
    COMMENT ON COLUMN deployment_events.dpl_ev_issue_link IS
        'Link to an issue related to this deployment in issue tracker.';

END$$;
2015-12-10 17:13:18,911 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.0.1 to 0.0.6 (or higher if tool doesn't find other migration scripts)
 */
DO
$$BEGIN
    SET search_path TO _pgpm, public;
    GRANT USAGE ON SCHEMA _pgpm TO public;
    COMMENT ON SCHEMA _pgpm IS
        'Schema containing all information about postgres packages (name, version, dependencies, etc.)
         and utility functions';

    -- drop created and last modified in subclasses, add comment and change varchar to text
    ALTER TABLE package_subclasses DROP COLUMN pkg_sc_created;
    ALTER TABLE package_subclasses DROP COLUMN pkg_sc_last_modified;
    ALTER TABLE package_subclasses ALTER COLUMN pkg_sc_name TYPE TEXT;
    COMMENT ON TABLE package_subclasses IS
        'Subclass of package. Can refer either to versioned schema (that adds suffix at the end)
         or non-versioned (basic) one (without suffix at the end)';

    -- remove vcf reference, created and last modified (will be moved to deployment_events table), add comments,
    -- change varchar to text and bump version of pgpm to 0.0.6
    ALTER TABLE packages DROP COLUMN pkg_created;
    ALTER TABLE packages DROP COLUMN pkg_last_modified;
    ALTER TABLE packages DROP COLUMN pkg_vcs_ref;
    ALTER TABLE packages ALTER COLUMN pkg_name TYPE TEXT;
    ALTER TABLE packages ALTER COLUMN pkg_v_pre TYPE TEXT;
    ALTER TABLE packages ALTER COLUMN pkg_v_metadata TYPE TEXT;
    UPDATE packages SET pkg_v_major = 0, pkg_v_minor = 0, pkg_v_patch = 6 WHERE pkg_name = '_pgpm';
    COMMENT ON TABLE packages IS
        'Information about package (schema) tracked with pgpm.';
    COMMENT ON COLUMN packages.pkg_v_major IS
        'Major part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_minor IS
        'Minor part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_patch IS
        'Patch part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_pre IS
        'Pre part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_metadata IS
        'Metadata part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_old_rev IS
        'Incremental number of the revision of the package of the same version.
         Used the following way. If package deployed with the version of already existing package in moderate mode then
         old package is renamed by adding an ending with incremental revision (starting with 0)';
    COMMENT ON COLUMN packages.pkg_license IS
        'Name of license (or a link) of a package';

    -- change Primary key to combination of 2 keys and remove old key
    ALTER TABLE package_dependencies DROP CONSTRAINT package_dependency_pkey;
    ALTER TABLE package_dependencies ADD CONSTRAINT package_dependency_pkey PRIMARY KEY (pkg_link_core_id, pkg_link_dep_id);
    COMMENT ON TABLE package_dependencies IS
        'Many to many relationship between dependant packages. Package cannot depend on itself';

    CREATE TABLE deployment_events
    (
        dpl_ev_pkg_id INTEGER,
        dpl_ev_vcs_ref TEXT,
        dpl_ev_vcs_link TEXT,
        dpl_ev_time TIMESTAMP DEFAULT NOW(),
        dpl_ev_issue_id TEXT,
        dpl_ev_issue_link TEXT,
        CONSTRAINT dpl_ev_pkg_fkey FOREIGN KEY (dpl_ev_pkg_id) REFERENCES packages (pkg_id)
    );
    COMMENT ON TABLE deployment_events IS
        'Table tracks all deployments tracked by pgpm';
    COMMENT ON COLUMN deployment_events.dpl_ev_vcs_ref IS
        'Reference to VCS point that was installed.
         In case of git, best option is to put here a specific commit reference.
         In case of SVN, revision number.';
    COMMENT ON COLUMN deployment_events.dpl_ev_vcs_link IS
        'Link to VCS repository.';
    COMMENT ON COLUMN deployment_events.dpl_ev_time IS
        'Deployment time';
    COMMENT ON COLUMN deployment_events.dpl_ev_issue_id IS
        'ID of an issue in issue tracker. E.g. ABS-111 for JIRA.';
    COMMENT ON COLUMN deployment_events.dpl_ev_issue_link IS
        'Link to an issue related to this deployment in issue tracker.';

END$$;
2015-12-10 17:13:18,911 - pgpm.app - DEBUG - Running version upgrade script 0.0.7-0.1.3.tmpl.sql
2015-12-10 17:13:18,911 - pgpm.app - DEBUG - /*
    Migration script from version 0.7.0 to 0.1.3 (or higher if tool doesn't find other migration scripts)
 */
DROP FUNCTION IF EXISTS _pgpm._add_package_info(TEXT, TEXT, INTEGER, INTEGER, INTEGER, INTEGER, TEXT, TEXT, TEXT, TEXT, INTEGER[], TEXT);

CREATE TABLE IF NOT EXISTS _pgpm.migrations_log
(
    m_id SERIAL NOT NULL,
    m_low_v TEXT,
    m_high_v TEXT,
    m_created TIMESTAMP DEFAULT NOW(),
    CONSTRAINT migrations_log_pkey PRIMARY KEY (m_id)
);
INSERT INTO _pgpm.migrations_log (m_low_v, m_high_v)
SELECT '0.0.1', '0.0.6'
WHERE
    NOT EXISTS (
        SELECT m_low_v, m_high_v FROM _pgpm.migrations_log
        WHERE m_low_v = '0.0.1' AND m_high_v = '0.0.6'
    );
COMMENT ON TABLE _pgpm.migrations_log IS
    'Logs each migration of pgpm to newer version. TODO: add statuses';

ALTER TABLE _pgpm.deployment_events DROP CONSTRAINT IF EXISTS dpl_ev_pkey;
ALTER TABLE _pgpm.deployment_events ADD CONSTRAINT dpl_ev_pkey PRIMARY KEY (dpl_ev_pkg_id, dpl_ev_time);
2015-12-10 17:13:18,918 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.7.0 to 0.1.3 (or higher if tool doesn't find other migration scripts)
 */
DROP FUNCTION IF EXISTS _pgpm._add_package_info(TEXT, TEXT, INTEGER, INTEGER, INTEGER, INTEGER, TEXT, TEXT, TEXT, TEXT, INTEGER[], TEXT);

CREATE TABLE IF NOT EXISTS _pgpm.migrations_log
(
    m_id SERIAL NOT NULL,
    m_low_v TEXT,
    m_high_v TEXT,
    m_created TIMESTAMP DEFAULT NOW(),
    CONSTRAINT migrations_log_pkey PRIMARY KEY (m_id)
);
INSERT INTO _pgpm.migrations_log (m_low_v, m_high_v)
SELECT '0.0.1', '0.0.6'
WHERE
    NOT EXISTS (
        SELECT m_low_v, m_high_v FROM _pgpm.migrations_log
        WHERE m_low_v = '0.0.1' AND m_high_v = '0.0.6'
    );
COMMENT ON TABLE _pgpm.migrations_log IS
    'Logs each migration of pgpm to newer version. TODO: add statuses';

ALTER TABLE _pgpm.deployment_events DROP CONSTRAINT IF EXISTS dpl_ev_pkey;
ALTER TABLE _pgpm.deployment_events ADD CONSTRAINT dpl_ev_pkey PRIMARY KEY (dpl_ev_pkg_id, dpl_ev_time);
2015-12-10 17:13:18,918 - pgpm.app - DEBUG - Running version upgrade script 0.1.4-0.1.5.tmpl.sql
2015-12-10 17:13:18,918 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.4 to 0.1.5 (or higher if tool doesn't find other migration scripts)
 */
DO $$
    BEGIN
        BEGIN
            ALTER TABLE _pgpm.deployment_events ADD COLUMN dpl_ev_id SERIAL NOT NULL;
            ALTER TABLE _pgpm.deployment_events DROP CONSTRAINT IF EXISTS dpl_ev_pkey;
            ALTER TABLE _pgpm.deployment_events ADD CONSTRAINT dpl_ev_pkey PRIMARY KEY (dpl_ev_id);
        EXCEPTION
            WHEN duplicate_column THEN RAISE NOTICE 'column dpl_ev_id already exists in _pgpm.deployment_events.';
        END;
    END;
$$

2015-12-10 17:13:18,923 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.4 to 0.1.5 (or higher if tool doesn't find other migration scripts)
 */
DO $$
    BEGIN
        BEGIN
            ALTER TABLE _pgpm.deployment_events ADD COLUMN dpl_ev_id SERIAL NOT NULL;
            ALTER TABLE _pgpm.deployment_events DROP CONSTRAINT IF EXISTS dpl_ev_pkey;
            ALTER TABLE _pgpm.deployment_events ADD CONSTRAINT dpl_ev_pkey PRIMARY KEY (dpl_ev_id);
        EXCEPTION
            WHEN duplicate_column THEN RAISE NOTICE 'column dpl_ev_id already exists in _pgpm.deployment_events.';
        END;
    END;
$$

2015-12-10 17:13:18,923 - pgpm.app - DEBUG - Running version upgrade script 0.1.6-0.1.7.tmpl.sql
2015-12-10 17:13:18,923 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.6 to 0.1.7 (or higher if tool doesn't find other migration scripts)
 */
ALTER TABLE _pgpm.packages DROP CONSTRAINT IF EXISTS pkg_unique;
ALTER TABLE _pgpm.packages ADD CONSTRAINT pkg_unique UNIQUE (pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch, pkg_v_pre, pkg_old_rev);
2015-12-10 17:13:18,924 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.6 to 0.1.7 (or higher if tool doesn't find other migration scripts)
 */
ALTER TABLE _pgpm.packages DROP CONSTRAINT IF EXISTS pkg_unique;
ALTER TABLE _pgpm.packages ADD CONSTRAINT pkg_unique UNIQUE (pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch, pkg_v_pre, pkg_old_rev);
2015-12-10 17:13:18,925 - pgpm.app - DEBUG - Running version upgrade script 0.1.8-0.1.9.tmpl.sql
2015-12-10 17:13:18,925 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.8 to 0.1.9 (or higher if tool doesn't find other migration scripts)
 */
CREATE TABLE IF NOT EXISTS _pgpm.package_statuses
(
    pkg_s_id SERIAL NOT NULL,
    pkg_s_name TEXT,
    CONSTRAINT pkg_s_pkey PRIMARY KEY (pkg_s_id)
);
COMMENT ON TABLE _pgpm.package_statuses IS
    'Package statuses';
INSERT INTO _pgpm.package_statuses (pkg_s_id, pkg_s_name)
SELECT 1, 'ADDED'
WHERE
    NOT EXISTS (
        SELECT pkg_s_id, pkg_s_name FROM _pgpm.package_statuses
        WHERE pkg_s_id = 1
    );

INSERT INTO _pgpm.package_statuses (pkg_s_id, pkg_s_name)
SELECT 2, 'IN PROGRESS'
WHERE
    NOT EXISTS (
        SELECT pkg_s_id, pkg_s_name FROM _pgpm.package_statuses
        WHERE pkg_s_id = 2
    );

INSERT INTO _pgpm.package_statuses (pkg_s_id, pkg_s_name)
SELECT 3, 'DELETED'
WHERE
    NOT EXISTS (
        SELECT pkg_s_id, pkg_s_name FROM _pgpm.package_statuses
        WHERE pkg_s_id = 3
    );

ALTER TABLE _pgpm.packages ADD COLUMN pkg_status INTEGER DEFAULT 1;
ALTER TABLE _pgpm.packages ADD CONSTRAINT pkg_status_fkey FOREIGN KEY (pkg_status) REFERENCES _pgpm.package_statuses (pkg_s_id);
2015-12-10 17:13:18,993 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.8 to 0.1.9 (or higher if tool doesn't find other migration scripts)
 */
CREATE TABLE IF NOT EXISTS _pgpm.package_statuses
(
    pkg_s_id SERIAL NOT NULL,
    pkg_s_name TEXT,
    CONSTRAINT pkg_s_pkey PRIMARY KEY (pkg_s_id)
);
COMMENT ON TABLE _pgpm.package_statuses IS
    'Package statuses';
INSERT INTO _pgpm.package_statuses (pkg_s_id, pkg_s_name)
SELECT 1, 'ADDED'
WHERE
    NOT EXISTS (
        SELECT pkg_s_id, pkg_s_name FROM _pgpm.package_statuses
        WHERE pkg_s_id = 1
    );

INSERT INTO _pgpm.package_statuses (pkg_s_id, pkg_s_name)
SELECT 2, 'IN PROGRESS'
WHERE
    NOT EXISTS (
        SELECT pkg_s_id, pkg_s_name FROM _pgpm.package_statuses
        WHERE pkg_s_id = 2
    );

INSERT INTO _pgpm.package_statuses (pkg_s_id, pkg_s_name)
SELECT 3, 'DELETED'
WHERE
    NOT EXISTS (
        SELECT pkg_s_id, pkg_s_name FROM _pgpm.package_statuses
        WHERE pkg_s_id = 3
    );

ALTER TABLE _pgpm.packages ADD COLUMN pkg_status INTEGER DEFAULT 1;
ALTER TABLE _pgpm.packages ADD CONSTRAINT pkg_status_fkey FOREIGN KEY (pkg_status) REFERENCES _pgpm.package_statuses (pkg_s_id);
2015-12-10 17:13:18,994 - pgpm.app - DEBUG - Running version upgrade script 0.1.10-0.1.10.tmpl.sql
2015-12-10 17:13:18,994 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.10 to 0.1.10 (or higher if tool doesn't find other migration scripts)
 */

CREATE TABLE IF NOT EXISTS _pgpm.ddl_changes_log
(
    ddl_change_id SERIAL NOT NULL,
    dpl_ev_id INTEGER,
    ddl_change_user NAME DEFAULT current_user,
    ddl_change TEXT,
    ddl_change_txid BIGINT DEFAULT txid_current(),
    ddl_change_created TIMESTAMP DEFAULT NOW(),
    CONSTRAINT ddl_change_pkey PRIMARY KEY (ddl_change_id)
);
COMMENT ON TABLE _pgpm.ddl_changes_log IS
    'Log of changes of DDL in database linked to deployment events if happened through deployment';

DROP EVENT TRIGGER IF EXISTS ddl_change_trigger;
CREATE EVENT TRIGGER ddl_change_trigger
ON ddl_command_end
WHEN TAG IN (
'ALTER AGGREGATE',
'ALTER COLLATION',
'ALTER CONVERSION',
'ALTER DOMAIN',
'ALTER EXTENSION',
'ALTER FOREIGN DATA WRAPPER',
'ALTER FOREIGN TABLE',
'ALTER FUNCTION',
'ALTER LANGUAGE',
'ALTER OPERATOR',
'ALTER OPERATOR CLASS',
'ALTER OPERATOR FAMILY',
'ALTER SCHEMA',
'ALTER SEQUENCE',
'ALTER SERVER',
'ALTER TABLE',
'ALTER TEXT SEARCH CONFIGURATION',
'ALTER TEXT SEARCH DICTIONARY',
'ALTER TEXT SEARCH PARSER',
'ALTER TEXT SEARCH TEMPLATE',
'ALTER TRIGGER',
'ALTER TYPE',
'ALTER USER MAPPING',
'ALTER VIEW',
'CREATE AGGREGATE',
'CREATE CAST',
'CREATE COLLATION',
'CREATE CONVERSION',
'CREATE DOMAIN',
'CREATE EXTENSION',
'CREATE FOREIGN DATA WRAPPER',
'CREATE FOREIGN TABLE',
'CREATE FUNCTION',
'CREATE INDEX',
'CREATE LANGUAGE',
'CREATE OPERATOR',
'CREATE OPERATOR CLASS',
'CREATE OPERATOR FAMILY',
'CREATE RULE',
'CREATE SCHEMA',
'CREATE SEQUENCE',
'CREATE SERVER',
'CREATE TABLE',
'CREATE TABLE AS',
'CREATE TEXT SEARCH CONFIGURATION',
'CREATE TEXT SEARCH DICTIONARY',
'CREATE TEXT SEARCH PARSER',
'CREATE TEXT SEARCH TEMPLATE',
'CREATE TRIGGER',
'CREATE TYPE',
'CREATE USER MAPPING',
'CREATE VIEW',
'DROP AGGREGATE',
'DROP CAST',
'DROP COLLATION',
'DROP CONVERSION',
'DROP DOMAIN',
'DROP EXTENSION',
'DROP FOREIGN DATA WRAPPER',
'DROP FOREIGN TABLE',
'DROP FUNCTION',
'DROP INDEX',
'DROP LANGUAGE',
'DROP OPERATOR',
'DROP OPERATOR CLASS',
'DROP OPERATOR FAMILY',
'DROP OWNED',
'DROP RULE',
'DROP SCHEMA',
'DROP SEQUENCE',
'DROP SERVER',
'DROP TABLE',
'DROP TEXT SEARCH CONFIGURATION',
'DROP TEXT SEARCH DICTIONARY',
'DROP TEXT SEARCH PARSER',
'DROP TEXT SEARCH TEMPLATE',
'DROP TRIGGER',
'DROP TYPE',
'DROP USER MAPPING',
'DROP VIEW')
EXECUTE PROCEDURE _pgpm._log_ddl_change();
2015-12-10 17:13:18,997 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.10 to 0.1.10 (or higher if tool doesn't find other migration scripts)
 */

CREATE TABLE IF NOT EXISTS _pgpm.ddl_changes_log
(
    ddl_change_id SERIAL NOT NULL,
    dpl_ev_id INTEGER,
    ddl_change_user NAME DEFAULT current_user,
    ddl_change TEXT,
    ddl_change_txid BIGINT DEFAULT txid_current(),
    ddl_change_created TIMESTAMP DEFAULT NOW(),
    CONSTRAINT ddl_change_pkey PRIMARY KEY (ddl_change_id)
);
COMMENT ON TABLE _pgpm.ddl_changes_log IS
    'Log of changes of DDL in database linked to deployment events if happened through deployment';

DROP EVENT TRIGGER IF EXISTS ddl_change_trigger;
CREATE EVENT TRIGGER ddl_change_trigger
ON ddl_command_end
WHEN TAG IN (
'ALTER AGGREGATE',
'ALTER COLLATION',
'ALTER CONVERSION',
'ALTER DOMAIN',
'ALTER EXTENSION',
'ALTER FOREIGN DATA WRAPPER',
'ALTER FOREIGN TABLE',
'ALTER FUNCTION',
'ALTER LANGUAGE',
'ALTER OPERATOR',
'ALTER OPERATOR CLASS',
'ALTER OPERATOR FAMILY',
'ALTER SCHEMA',
'ALTER SEQUENCE',
'ALTER SERVER',
'ALTER TABLE',
'ALTER TEXT SEARCH CONFIGURATION',
'ALTER TEXT SEARCH DICTIONARY',
'ALTER TEXT SEARCH PARSER',
'ALTER TEXT SEARCH TEMPLATE',
'ALTER TRIGGER',
'ALTER TYPE',
'ALTER USER MAPPING',
'ALTER VIEW',
'CREATE AGGREGATE',
'CREATE CAST',
'CREATE COLLATION',
'CREATE CONVERSION',
'CREATE DOMAIN',
'CREATE EXTENSION',
'CREATE FOREIGN DATA WRAPPER',
'CREATE FOREIGN TABLE',
'CREATE FUNCTION',
'CREATE INDEX',
'CREATE LANGUAGE',
'CREATE OPERATOR',
'CREATE OPERATOR CLASS',
'CREATE OPERATOR FAMILY',
'CREATE RULE',
'CREATE SCHEMA',
'CREATE SEQUENCE',
'CREATE SERVER',
'CREATE TABLE',
'CREATE TABLE AS',
'CREATE TEXT SEARCH CONFIGURATION',
'CREATE TEXT SEARCH DICTIONARY',
'CREATE TEXT SEARCH PARSER',
'CREATE TEXT SEARCH TEMPLATE',
'CREATE TRIGGER',
'CREATE TYPE',
'CREATE USER MAPPING',
'CREATE VIEW',
'DROP AGGREGATE',
'DROP CAST',
'DROP COLLATION',
'DROP CONVERSION',
'DROP DOMAIN',
'DROP EXTENSION',
'DROP FOREIGN DATA WRAPPER',
'DROP FOREIGN TABLE',
'DROP FUNCTION',
'DROP INDEX',
'DROP LANGUAGE',
'DROP OPERATOR',
'DROP OPERATOR CLASS',
'DROP OPERATOR FAMILY',
'DROP OWNED',
'DROP RULE',
'DROP SCHEMA',
'DROP SEQUENCE',
'DROP SERVER',
'DROP TABLE',
'DROP TEXT SEARCH CONFIGURATION',
'DROP TEXT SEARCH DICTIONARY',
'DROP TEXT SEARCH PARSER',
'DROP TEXT SEARCH TEMPLATE',
'DROP TRIGGER',
'DROP TYPE',
'DROP USER MAPPING',
'DROP VIEW')
EXECUTE PROCEDURE _pgpm._log_ddl_change();
2015-12-10 17:13:18,998 - pgpm.app - DEBUG - Running version upgrade script 0.1.11-0.1.11.tmpl.sql
2015-12-10 17:13:18,998 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.11 to 0.1.11 (or higher if tool doesn't find other migration scripts)
 */

ALTER TABLE _pgpm.ddl_changes_log DROP COLUMN dpl_ev_id;
ALTER TABLE _pgpm.deployment_events ADD COLUMN dpl_ev_txid BIGINT;

2015-12-10 17:13:18,999 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.11 to 0.1.11 (or higher if tool doesn't find other migration scripts)
 */

ALTER TABLE _pgpm.ddl_changes_log DROP COLUMN dpl_ev_id;
ALTER TABLE _pgpm.deployment_events ADD COLUMN dpl_ev_txid BIGINT;

2015-12-10 17:13:18,999 - pgpm.app - DEBUG - Running version upgrade script 0.1.12-0.1.12.tmpl.sql
2015-12-10 17:13:18,999 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.12 to 0.1.12 (or higher if tool doesn't find other migration scripts)
 */

CREATE TABLE _pgpm.table_evolutions_log (
    t_evo_id SERIAL NOT NULL,
    t_evo_file_name TEXT,
    t_evo_package INTEGER,
    CONSTRAINT table_evolutions_log_pkey PRIMARY KEY (t_evo_id),
    CONSTRAINT package_fkey FOREIGN KEY (t_evo_package) REFERENCES _pgpm.packages (pkg_id)
);
2015-12-10 17:13:19,005 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.12 to 0.1.12 (or higher if tool doesn't find other migration scripts)
 */

CREATE TABLE _pgpm.table_evolutions_log (
    t_evo_id SERIAL NOT NULL,
    t_evo_file_name TEXT,
    t_evo_package INTEGER,
    CONSTRAINT table_evolutions_log_pkey PRIMARY KEY (t_evo_id),
    CONSTRAINT package_fkey FOREIGN KEY (t_evo_package) REFERENCES _pgpm.packages (pkg_id)
);
2015-12-10 17:13:19,005 - pgpm.app - DEBUG - Running version upgrade script 0.1.13-0.1.17.tmpl.sql
2015-12-10 17:13:19,006 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.13 to 0.1.17 (or higher if tool doesn't find other migration scripts)
 */

ALTER TABLE _pgpm.table_evolutions_log ADD COLUMN t_evo_created TIMESTAMP DEFAULT NOW();

2015-12-10 17:13:19,010 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.13 to 0.1.17 (or higher if tool doesn't find other migration scripts)
 */

ALTER TABLE _pgpm.table_evolutions_log ADD COLUMN t_evo_created TIMESTAMP DEFAULT NOW();

2015-12-10 17:13:19,011 - pgpm.app - DEBUG - Running version upgrade script 0.1.18-0.1.18.tmpl.sql
2015-12-10 17:13:19,011 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.18 to 0.1.18 (or higher if tool doesn't find other migration scripts)
 */
COMMENT ON TABLE _pgpm.table_evolutions_log IS
    'Table tracks all table evolution statements (ALTER TABLE + DML) for pgpm packages';
COMMENT ON COLUMN _pgpm.table_evolutions_log.t_evo_file_name IS
    'File name acts as a key to check whether evolution has already been applied or not';
2015-12-10 17:13:19,011 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.18 to 0.1.18 (or higher if tool doesn't find other migration scripts)
 */
COMMENT ON TABLE _pgpm.table_evolutions_log IS
    'Table tracks all table evolution statements (ALTER TABLE + DML) for pgpm packages';
COMMENT ON COLUMN _pgpm.table_evolutions_log.t_evo_file_name IS
    'File name acts as a key to check whether evolution has already been applied or not';
2015-12-10 17:13:19,011 - pgpm.app - DEBUG - Running version upgrade script 0.1.19-0.1.33.tmpl.sql
2015-12-10 17:13:19,011 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.19 to 0.1.33 (or higher if tool doesn't find other migration scripts)
 */

ALTER TABLE _pgpm.ddl_changes_log ALTER COLUMN ddl_change_user SET DEFAULT session_user;
2015-12-10 17:13:19,013 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.19 to 0.1.33 (or higher if tool doesn't find other migration scripts)
 */

ALTER TABLE _pgpm.ddl_changes_log ALTER COLUMN ddl_change_user SET DEFAULT session_user;
2015-12-10 17:13:19,013 - pgpm.app - DEBUG - Calling stored procedure: SELECT * FROM _add_migration_info('0.0.7','0.1.49')
2015-12-10 17:13:19,018 - pgpm.app - DEBUG - No user was specified to have permisions on _pgpm schema. This means only user that installed _pgpm will be able to deploy. We recommend adding more users.
2015-12-10 17:13:19,018 - pgpm.app - DEBUG - Executing query: set search_path TO _pgpm, public;
2015-12-10 17:13:19,022 - pgpm.app - DEBUG - Calling stored procedure: SELECT * FROM _upsert_package_info('_pgpm','basic','0','1','49',NULL,NULL,'Package manager for Postgres','MIT')
2015-12-10 17:13:19,022 - pgpm.app - DEBUG - Closing connection to host=localhost port=5432 dbname=pgpm_test_2 user=apanchoyan...
2015-12-10 17:13:19,022 - pgpm.app - DEBUG - Connection to host=localhost port=5432 dbname=pgpm_test_2 user=apanchoyan closed.
2015-12-10 17:13:19,022 - pgpm.app - INFO - Successfully installed host=localhost port=5432 dbname=pgpm_test_2 user=apanchoyan
2015-12-10 17:13:19,022 - pgpm.app - INFO - Installing... host=localhost port=5432 dbname=pgpm_test_3 user=apanchoyan
2015-12-10 17:13:19,026 - pgpm.app - DEBUG - lib/db_scripts/functions/_add_migration_info.sql
2015-12-10 17:13:19,026 - pgpm.app - DEBUG - lib/db_scripts/functions/_alter_schema_owner.sql
2015-12-10 17:13:19,026 - pgpm.app - DEBUG - lib/db_scripts/functions/_find_schema.sql
2015-12-10 17:13:19,027 - pgpm.app - DEBUG - lib/db_scripts/functions/_is_table_ddl_executed.sql
2015-12-10 17:13:19,027 - pgpm.app - DEBUG - lib/db_scripts/functions/_log_ddl_change.sql
2015-12-10 17:13:19,027 - pgpm.app - DEBUG - lib/db_scripts/functions/_log_table_evolution.sql
2015-12-10 17:13:19,027 - pgpm.app - DEBUG - lib/db_scripts/functions/_set_revision_package.sql
2015-12-10 17:13:19,027 - pgpm.app - DEBUG - lib/db_scripts/functions/_upsert_package_info.sql
2015-12-10 17:13:19,027 - pgpm.app - DEBUG - lib/db_scripts/functions/set_search_path.sql
2015-12-10 17:13:19,028 - pgpm.app - DEBUG - Executing query: select * from CURRENT_USER;
2015-12-10 17:13:19,029 - pgpm.app - DEBUG - Executing query: select usesuper from pg_user where usename = CURRENT_USER;
2015-12-10 17:13:19,031 - pgpm.app - DEBUG - Executing query: SELECT EXISTS (SELECT schema_name FROM information_schema.schemata WHERE schema_name = '_pgpm');
2015-12-10 17:13:19,031 - pgpm.app - INFO - Executing a preamble to install statement
2015-12-10 17:13:19,032 - pgpm.app - DEBUG - Executing query: -- Preparation SET statements for deployment
SET statement_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = off;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET escape_string_warning = off;
2015-12-10 17:13:19,032 - pgpm.app - INFO - Installing package manager
2015-12-10 17:13:19,047 - pgpm.app - DEBUG - Executing query: DO
$$BEGIN
    CREATE SCHEMA _pgpm;
    SET search_path TO _pgpm, public;

    CREATE TABLE package_subclasses
    (
        pkg_sc_id SERIAL NOT NULL,
        pkg_sc_name TEXT,
        pkg_sc_created TIMESTAMP DEFAULT now(),
        pkg_sc_last_modified TIMESTAMP DEFAULT now(),
        CONSTRAINT package_subclass_pkey PRIMARY KEY (pkg_sc_id)
    );
    INSERT INTO package_subclasses (pkg_sc_name)
        VALUES ('versioned');
    INSERT INTO package_subclasses (pkg_sc_name)
        VALUES ('basic');

    -- info on packages
    CREATE TABLE packages
    (
        pkg_id serial NOT NULL,
        pkg_name character varying(255),
        pkg_description text,
        pkg_v_major integer,
        pkg_v_minor integer,
        pkg_v_patch integer,
        pkg_v_pre character varying(255),
        pkg_v_metadata character varying(255),
        pkg_old_rev integer,
        pkg_vcs_ref varchar(255),
        pkg_subclass integer,
        pkg_license text,
        pkg_created timestamp without time zone DEFAULT now(),
        pkg_last_modified timestamp without time zone DEFAULT statement_timestamp(),
        CONSTRAINT package_pkey PRIMARY KEY (pkg_id),
        CONSTRAINT package_subclass_fkey FOREIGN KEY (pkg_subclass) REFERENCES package_subclasses (pkg_sc_id)
    );

    -- info on package dependencies
    CREATE TABLE package_dependencies
    (
        pkg_dep_id serial NOT NULL,
        pkg_link_core_id integer NOT NULL,
        pkg_link_dep_id integer NOT NULL CHECK (pkg_link_core_id <> pkg_link_dep_id),
        CONSTRAINT package_dependency_pkey PRIMARY KEY (pkg_dep_id),
        CONSTRAINT package_link_core_fkey FOREIGN KEY (pkg_link_core_id) REFERENCES packages (pkg_id),
        CONSTRAINT package_link_dependency_fkey FOREIGN KEY (pkg_link_dep_id) REFERENCES packages (pkg_id)
    );

END$$;
2015-12-10 17:13:19,048 - pgpm.app - INFO - Running functions definitions scripts
2015-12-10 17:13:19,048 - pgpm.app - DEBUG - {'_log_ddl_change.sql': u'CREATE OR REPLACE FUNCTION _log_ddl_change()\n    RETURNS EVENT_TRIGGER AS\n$BODY$\n---\n-- @description\n-- Logs any DDL changes to the DB\n--\n---\nDECLARE\n    l_current_query TEXT;\n    l_txid BIGINT;\nBEGIN\n\n    SELECT current_query() INTO l_current_query;\n    SELECT txid_current() INTO l_txid;\n    INSERT INTO _pgpm.ddl_changes_log (ddl_change)\n    SELECT l_current_query\n    WHERE\n        NOT EXISTS (\n            SELECT ddl_change_txid, ddl_change FROM _pgpm.ddl_changes_log\n            WHERE ddl_change_txid = l_txid AND ddl_change = l_current_query\n        );\n\n    -- Notify external channels of ddl change\n    PERFORM pg_notify(\'ddl_change\', "session_user"());\n\nEND;\n$BODY$\nLANGUAGE \'plpgsql\' VOLATILE SECURITY DEFINER;', '_add_migration_info.sql': u"CREATE OR REPLACE FUNCTION _add_migration_info(p_m_low_v TEXT, p_m_high_v TEXT)\n    RETURNS VOID AS\n$BODY$\n---\n-- @description\n-- Adds migration info migrations log table\n--\n-- @param p_m_low_v\n-- lower border of version that is applicaple for this migration\n--\n-- @param p_m_high_v\n-- package type: either version (with version suffix at the end of the name) or basic (without)\n--\n-- @param p_pkg_old_rev\n-- higher border of version that is applicaple for this migration\n--\n---\nBEGIN\n\n    BEGIN\n        INSERT INTO migrations_log (m_low_v, m_high_v)\n            VALUES (p_m_low_v, p_m_high_v);\n    EXCEPTION\n        WHEN SQLSTATE '42P01' THEN\n            RAISE WARNING 'Can''t log migration from % to % as migrations_log is not defined yet', p_m_low_v, p_m_high_v;\n    END;\nEND;\n$BODY$\nLANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", 'set_search_path.sql': u"CREATE OR REPLACE FUNCTION set_search_path(p_schema_name TEXT, p_v_req TEXT)\n    RETURNS json AS\n$BODY$\n---\n-- @description\n-- Sets search path that includes also all depending\n--\n-- @param p_schema_name\n-- Package (schema) name\n--\n-- @param p_v_req\n-- Package version requirement. Version notation supports:\n-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)\n-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x\n-- - comparison operators like >01_02_03 or <2\n-- - x for any latest version of package\n-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency\n--\n-- @returns\n-- JSON with schema names and exact versions or exception if not found\n---\nDECLARE\n    l_search_path TEXT;\n    l_search_path_deps TEXT;\n    l_listen_text TEXT;\n\n    l_pkg_version_wrapped RECORD;\n    l_pkg_version RECORD;\n\n    return_value json;\nBEGIN\n\n    SET search_path TO _pgpm;\n    SELECT _find_schema(p_schema_name, p_v_req) AS version INTO l_pkg_version_wrapped;\n    l_pkg_version := l_pkg_version_wrapped.version;\n\n    l_search_path := l_pkg_version.pkg_name || '_' ||\n                     l_pkg_version.pkg_v_major::text || '_' ||\n                     l_pkg_version.pkg_v_minor::text || '_' ||\n                     l_pkg_version.pkg_v_patch::text;\n\n    SELECT string_agg(pkg_name || '_' || pkg_v_major || '_' || pkg_v_minor || '_' || pkg_v_patch, ', ')\n    FROM packages\n    WHERE pkg_id IN (\n        SELECT pkg_link_dep_id from package_dependencies\n        JOIN packages ON pkg_id = l_pkg_version.pkg_id\n        WHERE pkg_link_core_id = pkg_id\n    )\n    INTO l_search_path_deps;\n\n    l_search_path := l_search_path || ', ' || l_search_path_deps;\n\n    l_listen_text := 'deployment_events' || '$$' || l_pkg_version.pkg_name;\n    EXECUTE 'LISTEN ' || l_listen_text;\n\n    RAISE INFO '%', l_search_path;\n    PERFORM set_config('search_path', l_search_path || ', public', false);\n\n    return_value := row_to_json(l_pkg_version);\n    RETURN return_value;\n\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_find_schema.sql': u"CREATE OR REPLACE FUNCTION _find_schema(p_schema_name TEXT, p_v_req TEXT)\n    RETURNS RECORD AS\n$BODY$\n---\n-- @description\n-- Searches for existing schema (package) within registered packages in _pgpm schema\n--\n-- @param p_schema_name\n-- Package (schema) name\n--\n-- @param p_v_req\n-- Package version requirement. Version notation supports:\n-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)\n-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x\n-- - comparison operators like >01_02_03 or <2\n-- - x for any latest version of package\n-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency\n--\n-- @returns\n-- Record containing schema name and exact version or exception if not found in the following format:\n-- pkg_name TEXT, pkg_v_major INTEGER, pkg_v_minor INTEGER, pkg_v_patch INTEGER\n---\nDECLARE\n    c_re_version TEXT = '^(<=|>=|<|>{0,2})(\\d*|x*)_?(\\d*|x*)_?(\\d*|x*)';\n    l_v_matches TEXT[];\n\n    l_v_major INTEGER;\n    l_v_minor INTEGER;\n    l_v_patch INTEGER;\n\n    return_value RECORD;\nBEGIN\n\n    SELECT regexp_matches(p_v_req, c_re_version, 'gi') INTO l_v_matches;\n\n    IF l_v_matches[2] ~* '^x+|^$' THEN\n        SELECT max(pkg_v_major)\n        FROM packages\n        WHERE pkg_name = p_schema_name\n        INTO l_v_major;\n    ELSE\n        l_v_major := l_v_matches[2]::integer;\n    END IF;\n\n    IF l_v_matches[3] ~* '^x+|^$' THEN\n        SELECT max(pkg_v_minor)\n        FROM packages\n        WHERE pkg_name = p_schema_name\n              AND pkg_v_major = l_v_major\n        INTO l_v_minor;\n    ELSE\n        l_v_minor := l_v_matches[3]::integer;\n    END IF;\n\n    IF l_v_matches[4] ~* '^x+|^$' THEN\n        SELECT max(pkg_v_patch)\n        FROM packages\n        WHERE pkg_name = p_schema_name\n              AND pkg_v_major = l_v_major\n              AND pkg_v_minor = l_v_minor\n        INTO l_v_patch;\n    ELSE\n        l_v_patch := l_v_matches[4]::integer;\n    END IF;\n\n    CASE l_v_matches[1]\n        WHEN '=', '' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND pkg_v_major = l_v_major\n                  AND pkg_v_minor = l_v_minor\n                  AND pkg_v_patch = l_v_patch\n            INTO return_value;\n        WHEN '<' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major < l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor < l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch < l_v_patch))\n            INTO return_value;\n        WHEN '>' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major > l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor > l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch > l_v_patch))\n            INTO return_value;\n        WHEN '<=' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major <= l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor <= l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch <= l_v_patch))\n            INTO return_value;\n        WHEN '>=' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major >= l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor >= l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch >= l_v_patch))\n            INTO return_value;\n        ELSE\n            RAISE EXCEPTION 'Invalid logical operand. Only <, >, =, <=, >=, = or no operand are allowed.' USING ERRCODE = '20000';\n    END CASE;\n\n    RETURN return_value;\n\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_upsert_package_info.sql': u"CREATE OR REPLACE FUNCTION _upsert_package_info(p_pkg_name TEXT,\n                                             p_pkg_subclass_name TEXT,\n                                             p_pkg_v_major INTEGER,\n                                             p_pkg_v_minor INTEGER DEFAULT 0,\n                                             p_pkg_v_patch INTEGER DEFAULT 0,\n                                             p_pkg_v_pre TEXT DEFAULT NULL,\n                                             p_pkg_v_metadata TEXT DEFAULT NULL,\n                                             p_pkg_description TEXT DEFAULT '',\n                                             p_pkg_license TEXT DEFAULT NULL,\n                                             p_pkg_deps_ids INTEGER[] DEFAULT '{}',\n                                             p_pkg_vcs_ref TEXT DEFAULT NULL,\n                                             p_pkg_vcs_link TEXT DEFAULT NULL,\n                                             p_pkg_issue_ref TEXT DEFAULT NULL,\n                                             p_pkg_issue_link TEXT DEFAULT NULL)\n    RETURNS INTEGER AS\n$BODY$\n---\n-- @description\n-- Adds package info to pgpm package info table, deployment events table and notifies channels of deployment\n--\n-- @param p_pkg_name\n-- package name\n--\n-- @param p_pkg_subclass_name\n-- package type: either version (with version suffix at the end of the name) or basic (without)\n--\n-- @param p_pkg_description\n-- package description\n--\n-- @param p_pkg_v_major\n-- package major part of version (according to semver)\n--\n-- @param p_pkg_v_minor\n-- package minor part of version (according to semver)\n--\n-- @param p_pkg_v_patch\n-- package patch part of version (according to semver)\n--\n-- @param p_pkg_v_pre\n-- package pre part of version (according to semver)\n--\n-- @param p_pkg_v_metadata\n-- package metadata part of version (according to semver)\n--\n-- @param p_pkg_license\n-- package license name/text\n--\n-- @param p_pkg_deps_ids\n-- IDs of dependent schemas\n--\n-- @param p_pkg_vcs_ref\n-- vcs reference to track the code\n--\n-- @param p_pkg_vcs_link\n-- repository link to track the code\n--\n-- @param p_pkg_issue_ref\n-- issue reference to track the code\n--\n-- @param p_pkg_issue_link\n-- issue tracking system link\n---\nDECLARE\n    l_existing_pkg_id INTEGER;\n    l_pkg_dep_id INTEGER;\n\n\treturn_value INTEGER;\nBEGIN\n\n    -- Case 1: unsafe mode, rewrite of the whole schema with the same version or some of the files in it\n    -- Case 2: new schema with new version (safe or moderate modes)\n\n    IF p_pkg_subclass_name = 'basic' THEN\n        SELECT pkg_id INTO l_existing_pkg_id\n        FROM packages\n        WHERE pkg_name = p_pkg_name\n            AND pkg_subclass IN (SELECT pkg_sc_id\n                                 FROM package_subclasses\n                                 WHERE pkg_sc_name = p_pkg_subclass_name);\n    ELSE\n        SELECT pkg_id INTO l_existing_pkg_id\n        FROM packages\n        WHERE pkg_name = p_pkg_name\n            AND pkg_subclass IN (SELECT pkg_sc_id\n                                 FROM package_subclasses\n                                 WHERE pkg_sc_name = p_pkg_subclass_name)\n            AND pkg_v_major = p_pkg_v_major\n            AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)\n            AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)\n            AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre)\n            AND pkg_old_rev IS NULL;\n    END IF;\n\n    IF FOUND THEN -- Case 1:\n        DELETE FROM package_dependencies\n            WHERE pkg_link_core_id = l_existing_pkg_id;\n\n        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids\n        LOOP\n            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (l_existing_pkg_id, l_pkg_dep_id);\n        END LOOP;\n\n        UPDATE packages\n        SET pkg_name=subquery.p_pkg_name,\n            pkg_subclass=subquery.pkg_sc_id,\n            pkg_v_major=subquery.p_pkg_v_major,\n            pkg_v_minor=subquery.p_pkg_v_minor,\n            pkg_v_patch=subquery.p_pkg_v_patch,\n            pkg_v_pre=subquery.p_pkg_v_pre,\n            pkg_v_metadata=subquery.p_pkg_v_metadata,\n            pkg_description=subquery.p_pkg_description,\n            pkg_license=subquery.p_pkg_license\n        FROM (SELECT\n                  p_pkg_name,\n                  pkg_sc_id,\n                  p_pkg_v_major,\n                  p_pkg_v_minor,\n                  p_pkg_v_patch,\n                  p_pkg_v_pre,\n                  p_pkg_v_metadata,\n                  p_pkg_description,\n                  p_pkg_license\n              FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name\n        ) as subquery\n        WHERE packages.pkg_name=subquery.p_pkg_name;\n\n        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)\n            VALUES (l_existing_pkg_id, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);\n\n        return_value := l_existing_pkg_id;\n    ELSE -- Case 2:\n        INSERT INTO packages (\n            pkg_name,\n            pkg_description,\n            pkg_v_major,\n            pkg_v_minor,\n            pkg_v_patch,\n            pkg_v_pre,\n            pkg_v_metadata,\n            pkg_subclass,\n            pkg_license\n        )\n        SELECT\n            p_pkg_name,\n            p_pkg_description,\n            p_pkg_v_major,\n            p_pkg_v_minor,\n            p_pkg_v_patch,\n            p_pkg_v_pre,\n            p_pkg_v_metadata,\n            pkg_sc_id,\n            p_pkg_license\n        FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name\n        RETURNING\n            pkg_id\n        INTO return_value;\n\n        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids\n        LOOP\n            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (return_value, l_pkg_dep_id);\n        END LOOP;\n\n        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)\n            VALUES (return_value, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);\n\n    END IF;\n\n    -- Notify external channels of successful deployment event\n    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);\n\n    RETURN return_value;\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_alter_schema_owner.sql': u"CREATE OR REPLACE FUNCTION _alter_schema_owner(p_schema TEXT, p_owner TEXT)\n    RETURNS VOID AS\n$BODY$\n---\n-- @description\n-- Alters ownership of schema and all its objects to a specified user.\n--\n-- @param p_schema\n-- Schema name\n--\n-- @param p_owner\n-- New owner user name\n--\n---\nDECLARE\n    l_schema TEXT;\n    l_functions TEXT;\n    l_tables TEXT;\n    l_sequences TEXT;\n    l_views TEXT;\n    l_domains TEXT;\n    l_triggers TEXT;\n    l_types TEXT;\n\nBEGIN\n\n    l_schema := 'ALTER SCHEMA '\n                || quote_ident(p_schema)\n                || ' OWNER TO '\n                || quote_ident(p_owner)\n                || ';';\n\n    SELECT string_agg('ALTER FUNCTION '\n                || quote_ident(n.nspname) || '.'\n                || quote_ident(p.proname) || '('\n                || pg_catalog.pg_get_function_identity_arguments(p.oid)\n                || ') OWNER TO ' || p_owner || ';'\n              , E'\\n') AS _sql\n    FROM   pg_catalog.pg_proc p\n    JOIN   pg_catalog.pg_namespace n ON n.oid = p.pronamespace\n    WHERE  n.nspname = p_schema\n    INTO l_functions;\n    IF l_functions IS NULL THEN\n        l_functions := '';\n    END IF;\n\n    SELECT string_agg('ALTER TABLE ' || quote_ident(schemaname) || '.' || quote_ident(tablename) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM pg_tables WHERE schemaname = p_schema\n    INTO l_tables;\n    IF l_tables IS NULL THEN\n        l_tables := '';\n    END IF;\n\n    SELECT string_agg('ALTER SEQUENCE ' || quote_ident(sequence_schema) || '.' || quote_ident(sequence_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.sequences WHERE sequence_schema = p_schema\n    INTO l_sequences;\n    IF l_sequences IS NULL THEN\n        l_sequences := '';\n    END IF;\n\n    SELECT string_agg('ALTER VIEW ' || quote_ident(table_schema) || '.' || quote_ident(table_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.views WHERE table_schema = p_schema\n    INTO l_views;\n    IF l_views IS NULL THEN\n        l_views := '';\n    END IF;\n\n    SELECT string_agg('ALTER DOMAIN ' || quote_ident(domain_schema) || '.' || quote_ident(domain_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.domains WHERE domain_schema = p_schema\n    INTO l_domains;\n    IF l_domains IS NULL THEN\n        l_domains := '';\n    END IF;\n\n    SELECT string_agg('ALTER TRIGGER ' || quote_ident(trigger_schema) || '.' || quote_ident(trigger_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.triggers WHERE trigger_schema = p_schema\n    INTO l_triggers;\n    IF l_triggers IS NULL THEN\n        l_triggers := '';\n    END IF;\n\n    SELECT string_agg('ALTER TYPE ' || quote_ident(user_defined_type_schema) || '.' || quote_ident(user_defined_type_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.user_defined_types WHERE user_defined_type_schema = p_schema\n    INTO l_types;\n    IF l_types IS NULL THEN\n        l_types := '';\n    END IF;\n\n    EXECUTE l_schema || l_functions || l_tables || l_sequences || l_views || l_domains || l_triggers || l_types;\n\nEND;\n$BODY$\nLANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;", '_log_table_evolution.sql': u"CREATE OR REPLACE FUNCTION _log_table_evolution(p_t_evo_file_name TEXT, p_t_evo_package INTEGER)\n    RETURNS VOID AS\n$BODY$\n---\n-- @description\n-- Adds information about executed table evolution script to log table\n--\n-- @param p_t_evo_file_name\n-- File name with executed statements.\n--\n-- @param p_t_evo_package\n-- Related package id\n--\n-- @param p_pkg_old_rev\n-- higher border of version that is applicaple for this migration\n--\n---\nBEGIN\n\n    INSERT INTO table_evolutions_log (t_evo_file_name, t_evo_package)\n        VALUES (p_t_evo_file_name, p_t_evo_package);\nEND;\n$BODY$\nLANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;", '_is_table_ddl_executed.sql': u"CREATE OR REPLACE FUNCTION _is_table_ddl_executed(p_file_name TEXT)\n    RETURNS BOOLEAN AS\n$BODY$\n---\n-- @description\n-- Checks whether file with table ddl has already been executed\n--\n-- @param p_file_name\n-- File name used to check whether statements were executed\n--\n-- @returns\n-- True if executed, False otherwise\n---\nDECLARE\n    return_value BOOLEAN;\nBEGIN\n\n    SELECT EXISTS (SELECT t_evo_id FROM table_evolutions_log WHERE t_evo_file_name=p_file_name) INTO return_value;\n\n    RETURN return_value;\n\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_set_revision_package.sql': u"CREATE OR REPLACE FUNCTION _set_revision_package(p_pkg_name TEXT,\n                                             p_pkg_subclass_name TEXT,\n                                             p_pkg_old_rev INTEGER,\n                                             p_pkg_v_major INTEGER,\n                                             p_pkg_v_minor INTEGER DEFAULT 0,\n                                             p_pkg_v_patch INTEGER DEFAULT 0,\n                                             p_pkg_v_pre TEXT DEFAULT NULL)\n    RETURNS INTEGER AS\n$BODY$\n---\n-- @description\n-- Set package as old revision, info logged in deployment events table\n--\n-- @param p_pkg_name\n-- package name\n--\n-- @param p_pkg_subclass_name\n-- package type: either version (with version suffix at the end of the name) or basic (without)\n--\n-- @param p_pkg_old_rev\n-- Revision name of package. Used in moderate form. When schema is renamed it is given a revision suffix from here\n--\n-- @param p_pkg_v_major\n-- package major part of version (according to semver)\n--\n-- @param p_pkg_v_minor\n-- package minor part of version (according to semver)\n--\n-- @param p_pkg_v_patch\n-- package patch part of version (according to semver)\n--\n-- @param p_pkg_v_pre\n-- package pre part of version (according to semver)\n--\n-- @param p_pkg_v_metadata\n-- package metadata part of version (according to semver)\n--\n-- @param p_pkg_vcs_ref\n-- vcs reference to track the code\n---\nDECLARE\n    l_existing_pkg_id INTEGER;\n    l_pkg_dep_id INTEGER;\n\n\treturn_value INTEGER;\nBEGIN\n\n    SELECT pkg_id INTO l_existing_pkg_id\n    FROM packages\n    WHERE pkg_name = p_pkg_name\n        AND pkg_subclass IN (SELECT pkg_sc_id\n                             FROM package_subclasses\n                             WHERE pkg_sc_name = p_pkg_subclass_name)\n        AND pkg_v_major = p_pkg_v_major\n        AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)\n        AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)\n        AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre);\n\n    IF FOUND THEN\n        UPDATE packages\n        SET pkg_old_rev=p_pkg_old_rev\n        WHERE packages.pkg_id=l_existing_pkg_id;\n\n        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)\n            SELECT pkg_id, txid_current(), dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link\n            FROM packages\n            JOIN deployment_events ON dpl_ev_pkg_id=pkg_id\n            WHERE pkg_id=l_existing_pkg_id AND dpl_ev_time IN (\n                SELECT max(dpl_ev_time) FROM deployment_events WHERE dpl_ev_pkg_id=packages.pkg_id\n            );\n    ELSE\n        RAISE EXCEPTION 'Package % not found in the list of packages. It could happen if schema exists but wasn''t properly deployed with pgpm', p_pkg_name || '_' || p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch;\n    END IF;\n\n    -- Notify external channels of successful deployment event\n    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);\n\n    RETURN return_value;\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n"}
2015-12-10 17:13:19,048 - pgpm.app - DEBUG - Executing query: set search_path TO _pgpm, public;
2015-12-10 17:13:19,049 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _log_ddl_change()
    RETURNS EVENT_TRIGGER AS
$BODY$
---
-- @description
-- Logs any DDL changes to the DB
--
---
DECLARE
    l_current_query TEXT;
    l_txid BIGINT;
BEGIN

    SELECT current_query() INTO l_current_query;
    SELECT txid_current() INTO l_txid;
    INSERT INTO _pgpm.ddl_changes_log (ddl_change)
    SELECT l_current_query
    WHERE
        NOT EXISTS (
            SELECT ddl_change_txid, ddl_change FROM _pgpm.ddl_changes_log
            WHERE ddl_change_txid = l_txid AND ddl_change = l_current_query
        );

    -- Notify external channels of ddl change
    PERFORM pg_notify('ddl_change', "session_user"());

END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;
2015-12-10 17:13:19,049 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _add_migration_info(p_m_low_v TEXT, p_m_high_v TEXT)
    RETURNS VOID AS
$BODY$
---
-- @description
-- Adds migration info migrations log table
--
-- @param p_m_low_v
-- lower border of version that is applicaple for this migration
--
-- @param p_m_high_v
-- package type: either version (with version suffix at the end of the name) or basic (without)
--
-- @param p_pkg_old_rev
-- higher border of version that is applicaple for this migration
--
---
BEGIN

    BEGIN
        INSERT INTO migrations_log (m_low_v, m_high_v)
            VALUES (p_m_low_v, p_m_high_v);
    EXCEPTION
        WHEN SQLSTATE '42P01' THEN
            RAISE WARNING 'Can''t log migration from % to % as migrations_log is not defined yet', p_m_low_v, p_m_high_v;
    END;
END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 17:13:19,050 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION set_search_path(p_schema_name TEXT, p_v_req TEXT)
    RETURNS json AS
$BODY$
---
-- @description
-- Sets search path that includes also all depending
--
-- @param p_schema_name
-- Package (schema) name
--
-- @param p_v_req
-- Package version requirement. Version notation supports:
-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)
-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x
-- - comparison operators like >01_02_03 or <2
-- - x for any latest version of package
-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency
--
-- @returns
-- JSON with schema names and exact versions or exception if not found
---
DECLARE
    l_search_path TEXT;
    l_search_path_deps TEXT;
    l_listen_text TEXT;

    l_pkg_version_wrapped RECORD;
    l_pkg_version RECORD;

    return_value json;
BEGIN

    SET search_path TO _pgpm;
    SELECT _find_schema(p_schema_name, p_v_req) AS version INTO l_pkg_version_wrapped;
    l_pkg_version := l_pkg_version_wrapped.version;

    l_search_path := l_pkg_version.pkg_name || '_' ||
                     l_pkg_version.pkg_v_major::text || '_' ||
                     l_pkg_version.pkg_v_minor::text || '_' ||
                     l_pkg_version.pkg_v_patch::text;

    SELECT string_agg(pkg_name || '_' || pkg_v_major || '_' || pkg_v_minor || '_' || pkg_v_patch, ', ')
    FROM packages
    WHERE pkg_id IN (
        SELECT pkg_link_dep_id from package_dependencies
        JOIN packages ON pkg_id = l_pkg_version.pkg_id
        WHERE pkg_link_core_id = pkg_id
    )
    INTO l_search_path_deps;

    l_search_path := l_search_path || ', ' || l_search_path_deps;

    l_listen_text := 'deployment_events' || '$$' || l_pkg_version.pkg_name;
    EXECUTE 'LISTEN ' || l_listen_text;

    RAISE INFO '%', l_search_path;
    PERFORM set_config('search_path', l_search_path || ', public', false);

    return_value := row_to_json(l_pkg_version);
    RETURN return_value;

END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 17:13:19,050 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _find_schema(p_schema_name TEXT, p_v_req TEXT)
    RETURNS RECORD AS
$BODY$
---
-- @description
-- Searches for existing schema (package) within registered packages in _pgpm schema
--
-- @param p_schema_name
-- Package (schema) name
--
-- @param p_v_req
-- Package version requirement. Version notation supports:
-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)
-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x
-- - comparison operators like >01_02_03 or <2
-- - x for any latest version of package
-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency
--
-- @returns
-- Record containing schema name and exact version or exception if not found in the following format:
-- pkg_name TEXT, pkg_v_major INTEGER, pkg_v_minor INTEGER, pkg_v_patch INTEGER
---
DECLARE
    c_re_version TEXT = '^(<=|>=|<|>{0,2})(\d*|x*)_?(\d*|x*)_?(\d*|x*)';
    l_v_matches TEXT[];

    l_v_major INTEGER;
    l_v_minor INTEGER;
    l_v_patch INTEGER;

    return_value RECORD;
BEGIN

    SELECT regexp_matches(p_v_req, c_re_version, 'gi') INTO l_v_matches;

    IF l_v_matches[2] ~* '^x+|^$' THEN
        SELECT max(pkg_v_major)
        FROM packages
        WHERE pkg_name = p_schema_name
        INTO l_v_major;
    ELSE
        l_v_major := l_v_matches[2]::integer;
    END IF;

    IF l_v_matches[3] ~* '^x+|^$' THEN
        SELECT max(pkg_v_minor)
        FROM packages
        WHERE pkg_name = p_schema_name
              AND pkg_v_major = l_v_major
        INTO l_v_minor;
    ELSE
        l_v_minor := l_v_matches[3]::integer;
    END IF;

    IF l_v_matches[4] ~* '^x+|^$' THEN
        SELECT max(pkg_v_patch)
        FROM packages
        WHERE pkg_name = p_schema_name
              AND pkg_v_major = l_v_major
              AND pkg_v_minor = l_v_minor
        INTO l_v_patch;
    ELSE
        l_v_patch := l_v_matches[4]::integer;
    END IF;

    CASE l_v_matches[1]
        WHEN '=', '' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND pkg_v_major = l_v_major
                  AND pkg_v_minor = l_v_minor
                  AND pkg_v_patch = l_v_patch
            INTO return_value;
        WHEN '<' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major < l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor < l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch < l_v_patch))
            INTO return_value;
        WHEN '>' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major > l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor > l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch > l_v_patch))
            INTO return_value;
        WHEN '<=' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major <= l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor <= l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch <= l_v_patch))
            INTO return_value;
        WHEN '>=' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major >= l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor >= l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch >= l_v_patch))
            INTO return_value;
        ELSE
            RAISE EXCEPTION 'Invalid logical operand. Only <, >, =, <=, >=, = or no operand are allowed.' USING ERRCODE = '20000';
    END CASE;

    RETURN return_value;

END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 17:13:19,051 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _upsert_package_info(p_pkg_name TEXT,
                                             p_pkg_subclass_name TEXT,
                                             p_pkg_v_major INTEGER,
                                             p_pkg_v_minor INTEGER DEFAULT 0,
                                             p_pkg_v_patch INTEGER DEFAULT 0,
                                             p_pkg_v_pre TEXT DEFAULT NULL,
                                             p_pkg_v_metadata TEXT DEFAULT NULL,
                                             p_pkg_description TEXT DEFAULT '',
                                             p_pkg_license TEXT DEFAULT NULL,
                                             p_pkg_deps_ids INTEGER[] DEFAULT '{}',
                                             p_pkg_vcs_ref TEXT DEFAULT NULL,
                                             p_pkg_vcs_link TEXT DEFAULT NULL,
                                             p_pkg_issue_ref TEXT DEFAULT NULL,
                                             p_pkg_issue_link TEXT DEFAULT NULL)
    RETURNS INTEGER AS
$BODY$
---
-- @description
-- Adds package info to pgpm package info table, deployment events table and notifies channels of deployment
--
-- @param p_pkg_name
-- package name
--
-- @param p_pkg_subclass_name
-- package type: either version (with version suffix at the end of the name) or basic (without)
--
-- @param p_pkg_description
-- package description
--
-- @param p_pkg_v_major
-- package major part of version (according to semver)
--
-- @param p_pkg_v_minor
-- package minor part of version (according to semver)
--
-- @param p_pkg_v_patch
-- package patch part of version (according to semver)
--
-- @param p_pkg_v_pre
-- package pre part of version (according to semver)
--
-- @param p_pkg_v_metadata
-- package metadata part of version (according to semver)
--
-- @param p_pkg_license
-- package license name/text
--
-- @param p_pkg_deps_ids
-- IDs of dependent schemas
--
-- @param p_pkg_vcs_ref
-- vcs reference to track the code
--
-- @param p_pkg_vcs_link
-- repository link to track the code
--
-- @param p_pkg_issue_ref
-- issue reference to track the code
--
-- @param p_pkg_issue_link
-- issue tracking system link
---
DECLARE
    l_existing_pkg_id INTEGER;
    l_pkg_dep_id INTEGER;

	return_value INTEGER;
BEGIN

    -- Case 1: unsafe mode, rewrite of the whole schema with the same version or some of the files in it
    -- Case 2: new schema with new version (safe or moderate modes)

    IF p_pkg_subclass_name = 'basic' THEN
        SELECT pkg_id INTO l_existing_pkg_id
        FROM packages
        WHERE pkg_name = p_pkg_name
            AND pkg_subclass IN (SELECT pkg_sc_id
                                 FROM package_subclasses
                                 WHERE pkg_sc_name = p_pkg_subclass_name);
    ELSE
        SELECT pkg_id INTO l_existing_pkg_id
        FROM packages
        WHERE pkg_name = p_pkg_name
            AND pkg_subclass IN (SELECT pkg_sc_id
                                 FROM package_subclasses
                                 WHERE pkg_sc_name = p_pkg_subclass_name)
            AND pkg_v_major = p_pkg_v_major
            AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)
            AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)
            AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre)
            AND pkg_old_rev IS NULL;
    END IF;

    IF FOUND THEN -- Case 1:
        DELETE FROM package_dependencies
            WHERE pkg_link_core_id = l_existing_pkg_id;

        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids
        LOOP
            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (l_existing_pkg_id, l_pkg_dep_id);
        END LOOP;

        UPDATE packages
        SET pkg_name=subquery.p_pkg_name,
            pkg_subclass=subquery.pkg_sc_id,
            pkg_v_major=subquery.p_pkg_v_major,
            pkg_v_minor=subquery.p_pkg_v_minor,
            pkg_v_patch=subquery.p_pkg_v_patch,
            pkg_v_pre=subquery.p_pkg_v_pre,
            pkg_v_metadata=subquery.p_pkg_v_metadata,
            pkg_description=subquery.p_pkg_description,
            pkg_license=subquery.p_pkg_license
        FROM (SELECT
                  p_pkg_name,
                  pkg_sc_id,
                  p_pkg_v_major,
                  p_pkg_v_minor,
                  p_pkg_v_patch,
                  p_pkg_v_pre,
                  p_pkg_v_metadata,
                  p_pkg_description,
                  p_pkg_license
              FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name
        ) as subquery
        WHERE packages.pkg_name=subquery.p_pkg_name;

        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)
            VALUES (l_existing_pkg_id, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);

        return_value := l_existing_pkg_id;
    ELSE -- Case 2:
        INSERT INTO packages (
            pkg_name,
            pkg_description,
            pkg_v_major,
            pkg_v_minor,
            pkg_v_patch,
            pkg_v_pre,
            pkg_v_metadata,
            pkg_subclass,
            pkg_license
        )
        SELECT
            p_pkg_name,
            p_pkg_description,
            p_pkg_v_major,
            p_pkg_v_minor,
            p_pkg_v_patch,
            p_pkg_v_pre,
            p_pkg_v_metadata,
            pkg_sc_id,
            p_pkg_license
        FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name
        RETURNING
            pkg_id
        INTO return_value;

        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids
        LOOP
            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (return_value, l_pkg_dep_id);
        END LOOP;

        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)
            VALUES (return_value, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);

    END IF;

    -- Notify external channels of successful deployment event
    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);

    RETURN return_value;
END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 17:13:19,052 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _alter_schema_owner(p_schema TEXT, p_owner TEXT)
    RETURNS VOID AS
$BODY$
---
-- @description
-- Alters ownership of schema and all its objects to a specified user.
--
-- @param p_schema
-- Schema name
--
-- @param p_owner
-- New owner user name
--
---
DECLARE
    l_schema TEXT;
    l_functions TEXT;
    l_tables TEXT;
    l_sequences TEXT;
    l_views TEXT;
    l_domains TEXT;
    l_triggers TEXT;
    l_types TEXT;

BEGIN

    l_schema := 'ALTER SCHEMA '
                || quote_ident(p_schema)
                || ' OWNER TO '
                || quote_ident(p_owner)
                || ';';

    SELECT string_agg('ALTER FUNCTION '
                || quote_ident(n.nspname) || '.'
                || quote_ident(p.proname) || '('
                || pg_catalog.pg_get_function_identity_arguments(p.oid)
                || ') OWNER TO ' || p_owner || ';'
              , E'\n') AS _sql
    FROM   pg_catalog.pg_proc p
    JOIN   pg_catalog.pg_namespace n ON n.oid = p.pronamespace
    WHERE  n.nspname = p_schema
    INTO l_functions;
    IF l_functions IS NULL THEN
        l_functions := '';
    END IF;

    SELECT string_agg('ALTER TABLE ' || quote_ident(schemaname) || '.' || quote_ident(tablename) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM pg_tables WHERE schemaname = p_schema
    INTO l_tables;
    IF l_tables IS NULL THEN
        l_tables := '';
    END IF;

    SELECT string_agg('ALTER SEQUENCE ' || quote_ident(sequence_schema) || '.' || quote_ident(sequence_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.sequences WHERE sequence_schema = p_schema
    INTO l_sequences;
    IF l_sequences IS NULL THEN
        l_sequences := '';
    END IF;

    SELECT string_agg('ALTER VIEW ' || quote_ident(table_schema) || '.' || quote_ident(table_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.views WHERE table_schema = p_schema
    INTO l_views;
    IF l_views IS NULL THEN
        l_views := '';
    END IF;

    SELECT string_agg('ALTER DOMAIN ' || quote_ident(domain_schema) || '.' || quote_ident(domain_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.domains WHERE domain_schema = p_schema
    INTO l_domains;
    IF l_domains IS NULL THEN
        l_domains := '';
    END IF;

    SELECT string_agg('ALTER TRIGGER ' || quote_ident(trigger_schema) || '.' || quote_ident(trigger_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.triggers WHERE trigger_schema = p_schema
    INTO l_triggers;
    IF l_triggers IS NULL THEN
        l_triggers := '';
    END IF;

    SELECT string_agg('ALTER TYPE ' || quote_ident(user_defined_type_schema) || '.' || quote_ident(user_defined_type_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.user_defined_types WHERE user_defined_type_schema = p_schema
    INTO l_types;
    IF l_types IS NULL THEN
        l_types := '';
    END IF;

    EXECUTE l_schema || l_functions || l_tables || l_sequences || l_views || l_domains || l_triggers || l_types;

END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;
2015-12-10 17:13:19,053 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _log_table_evolution(p_t_evo_file_name TEXT, p_t_evo_package INTEGER)
    RETURNS VOID AS
$BODY$
---
-- @description
-- Adds information about executed table evolution script to log table
--
-- @param p_t_evo_file_name
-- File name with executed statements.
--
-- @param p_t_evo_package
-- Related package id
--
-- @param p_pkg_old_rev
-- higher border of version that is applicaple for this migration
--
---
BEGIN

    INSERT INTO table_evolutions_log (t_evo_file_name, t_evo_package)
        VALUES (p_t_evo_file_name, p_t_evo_package);
END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;
2015-12-10 17:13:19,053 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _is_table_ddl_executed(p_file_name TEXT)
    RETURNS BOOLEAN AS
$BODY$
---
-- @description
-- Checks whether file with table ddl has already been executed
--
-- @param p_file_name
-- File name used to check whether statements were executed
--
-- @returns
-- True if executed, False otherwise
---
DECLARE
    return_value BOOLEAN;
BEGIN

    SELECT EXISTS (SELECT t_evo_id FROM table_evolutions_log WHERE t_evo_file_name=p_file_name) INTO return_value;

    RETURN return_value;

END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 17:13:19,054 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _set_revision_package(p_pkg_name TEXT,
                                             p_pkg_subclass_name TEXT,
                                             p_pkg_old_rev INTEGER,
                                             p_pkg_v_major INTEGER,
                                             p_pkg_v_minor INTEGER DEFAULT 0,
                                             p_pkg_v_patch INTEGER DEFAULT 0,
                                             p_pkg_v_pre TEXT DEFAULT NULL)
    RETURNS INTEGER AS
$BODY$
---
-- @description
-- Set package as old revision, info logged in deployment events table
--
-- @param p_pkg_name
-- package name
--
-- @param p_pkg_subclass_name
-- package type: either version (with version suffix at the end of the name) or basic (without)
--
-- @param p_pkg_old_rev
-- Revision name of package. Used in moderate form. When schema is renamed it is given a revision suffix from here
--
-- @param p_pkg_v_major
-- package major part of version (according to semver)
--
-- @param p_pkg_v_minor
-- package minor part of version (according to semver)
--
-- @param p_pkg_v_patch
-- package patch part of version (according to semver)
--
-- @param p_pkg_v_pre
-- package pre part of version (according to semver)
--
-- @param p_pkg_v_metadata
-- package metadata part of version (according to semver)
--
-- @param p_pkg_vcs_ref
-- vcs reference to track the code
---
DECLARE
    l_existing_pkg_id INTEGER;
    l_pkg_dep_id INTEGER;

	return_value INTEGER;
BEGIN

    SELECT pkg_id INTO l_existing_pkg_id
    FROM packages
    WHERE pkg_name = p_pkg_name
        AND pkg_subclass IN (SELECT pkg_sc_id
                             FROM package_subclasses
                             WHERE pkg_sc_name = p_pkg_subclass_name)
        AND pkg_v_major = p_pkg_v_major
        AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)
        AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)
        AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre);

    IF FOUND THEN
        UPDATE packages
        SET pkg_old_rev=p_pkg_old_rev
        WHERE packages.pkg_id=l_existing_pkg_id;

        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)
            SELECT pkg_id, txid_current(), dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link
            FROM packages
            JOIN deployment_events ON dpl_ev_pkg_id=pkg_id
            WHERE pkg_id=l_existing_pkg_id AND dpl_ev_time IN (
                SELECT max(dpl_ev_time) FROM deployment_events WHERE dpl_ev_pkg_id=packages.pkg_id
            );
    ELSE
        RAISE EXCEPTION 'Package % not found in the list of packages. It could happen if schema exists but wasn''t properly deployed with pgpm', p_pkg_name || '_' || p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch;
    END IF;

    -- Notify external channels of successful deployment event
    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);

    RETURN return_value;
END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-10 17:13:19,054 - pgpm.app - DEBUG - Functions loaded to schema _pgpm
2015-12-10 17:13:19,055 - pgpm.app - DEBUG - Running version upgrade script 0.0.1-0.0.6.tmpl.sql
2015-12-10 17:13:19,055 - pgpm.app - DEBUG - /*
    Migration script from version 0.0.1 to 0.0.6 (or higher if tool doesn't find other migration scripts)
 */
DO
$$BEGIN
    SET search_path TO _pgpm, public;
    GRANT USAGE ON SCHEMA _pgpm TO public;
    COMMENT ON SCHEMA _pgpm IS
        'Schema containing all information about postgres packages (name, version, dependencies, etc.)
         and utility functions';

    -- drop created and last modified in subclasses, add comment and change varchar to text
    ALTER TABLE package_subclasses DROP COLUMN pkg_sc_created;
    ALTER TABLE package_subclasses DROP COLUMN pkg_sc_last_modified;
    ALTER TABLE package_subclasses ALTER COLUMN pkg_sc_name TYPE TEXT;
    COMMENT ON TABLE package_subclasses IS
        'Subclass of package. Can refer either to versioned schema (that adds suffix at the end)
         or non-versioned (basic) one (without suffix at the end)';

    -- remove vcf reference, created and last modified (will be moved to deployment_events table), add comments,
    -- change varchar to text and bump version of pgpm to 0.0.6
    ALTER TABLE packages DROP COLUMN pkg_created;
    ALTER TABLE packages DROP COLUMN pkg_last_modified;
    ALTER TABLE packages DROP COLUMN pkg_vcs_ref;
    ALTER TABLE packages ALTER COLUMN pkg_name TYPE TEXT;
    ALTER TABLE packages ALTER COLUMN pkg_v_pre TYPE TEXT;
    ALTER TABLE packages ALTER COLUMN pkg_v_metadata TYPE TEXT;
    UPDATE packages SET pkg_v_major = 0, pkg_v_minor = 0, pkg_v_patch = 6 WHERE pkg_name = '_pgpm';
    COMMENT ON TABLE packages IS
        'Information about package (schema) tracked with pgpm.';
    COMMENT ON COLUMN packages.pkg_v_major IS
        'Major part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_minor IS
        'Minor part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_patch IS
        'Patch part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_pre IS
        'Pre part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_metadata IS
        'Metadata part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_old_rev IS
        'Incremental number of the revision of the package of the same version.
         Used the following way. If package deployed with the version of already existing package in moderate mode then
         old package is renamed by adding an ending with incremental revision (starting with 0)';
    COMMENT ON COLUMN packages.pkg_license IS
        'Name of license (or a link) of a package';

    -- change Primary key to combination of 2 keys and remove old key
    ALTER TABLE package_dependencies DROP CONSTRAINT package_dependency_pkey;
    ALTER TABLE package_dependencies ADD CONSTRAINT package_dependency_pkey PRIMARY KEY (pkg_link_core_id, pkg_link_dep_id);
    COMMENT ON TABLE package_dependencies IS
        'Many to many relationship between dependant packages. Package cannot depend on itself';

    CREATE TABLE deployment_events
    (
        dpl_ev_pkg_id INTEGER,
        dpl_ev_vcs_ref TEXT,
        dpl_ev_vcs_link TEXT,
        dpl_ev_time TIMESTAMP DEFAULT NOW(),
        dpl_ev_issue_id TEXT,
        dpl_ev_issue_link TEXT,
        CONSTRAINT dpl_ev_pkg_fkey FOREIGN KEY (dpl_ev_pkg_id) REFERENCES packages (pkg_id)
    );
    COMMENT ON TABLE deployment_events IS
        'Table tracks all deployments tracked by pgpm';
    COMMENT ON COLUMN deployment_events.dpl_ev_vcs_ref IS
        'Reference to VCS point that was installed.
         In case of git, best option is to put here a specific commit reference.
         In case of SVN, revision number.';
    COMMENT ON COLUMN deployment_events.dpl_ev_vcs_link IS
        'Link to VCS repository.';
    COMMENT ON COLUMN deployment_events.dpl_ev_time IS
        'Deployment time';
    COMMENT ON COLUMN deployment_events.dpl_ev_issue_id IS
        'ID of an issue in issue tracker. E.g. ABS-111 for JIRA.';
    COMMENT ON COLUMN deployment_events.dpl_ev_issue_link IS
        'Link to an issue related to this deployment in issue tracker.';

END$$;
2015-12-10 17:13:19,065 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.0.1 to 0.0.6 (or higher if tool doesn't find other migration scripts)
 */
DO
$$BEGIN
    SET search_path TO _pgpm, public;
    GRANT USAGE ON SCHEMA _pgpm TO public;
    COMMENT ON SCHEMA _pgpm IS
        'Schema containing all information about postgres packages (name, version, dependencies, etc.)
         and utility functions';

    -- drop created and last modified in subclasses, add comment and change varchar to text
    ALTER TABLE package_subclasses DROP COLUMN pkg_sc_created;
    ALTER TABLE package_subclasses DROP COLUMN pkg_sc_last_modified;
    ALTER TABLE package_subclasses ALTER COLUMN pkg_sc_name TYPE TEXT;
    COMMENT ON TABLE package_subclasses IS
        'Subclass of package. Can refer either to versioned schema (that adds suffix at the end)
         or non-versioned (basic) one (without suffix at the end)';

    -- remove vcf reference, created and last modified (will be moved to deployment_events table), add comments,
    -- change varchar to text and bump version of pgpm to 0.0.6
    ALTER TABLE packages DROP COLUMN pkg_created;
    ALTER TABLE packages DROP COLUMN pkg_last_modified;
    ALTER TABLE packages DROP COLUMN pkg_vcs_ref;
    ALTER TABLE packages ALTER COLUMN pkg_name TYPE TEXT;
    ALTER TABLE packages ALTER COLUMN pkg_v_pre TYPE TEXT;
    ALTER TABLE packages ALTER COLUMN pkg_v_metadata TYPE TEXT;
    UPDATE packages SET pkg_v_major = 0, pkg_v_minor = 0, pkg_v_patch = 6 WHERE pkg_name = '_pgpm';
    COMMENT ON TABLE packages IS
        'Information about package (schema) tracked with pgpm.';
    COMMENT ON COLUMN packages.pkg_v_major IS
        'Major part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_minor IS
        'Minor part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_patch IS
        'Patch part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_pre IS
        'Pre part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_v_metadata IS
        'Metadata part of version of a package as seen in semver';
    COMMENT ON COLUMN packages.pkg_old_rev IS
        'Incremental number of the revision of the package of the same version.
         Used the following way. If package deployed with the version of already existing package in moderate mode then
         old package is renamed by adding an ending with incremental revision (starting with 0)';
    COMMENT ON COLUMN packages.pkg_license IS
        'Name of license (or a link) of a package';

    -- change Primary key to combination of 2 keys and remove old key
    ALTER TABLE package_dependencies DROP CONSTRAINT package_dependency_pkey;
    ALTER TABLE package_dependencies ADD CONSTRAINT package_dependency_pkey PRIMARY KEY (pkg_link_core_id, pkg_link_dep_id);
    COMMENT ON TABLE package_dependencies IS
        'Many to many relationship between dependant packages. Package cannot depend on itself';

    CREATE TABLE deployment_events
    (
        dpl_ev_pkg_id INTEGER,
        dpl_ev_vcs_ref TEXT,
        dpl_ev_vcs_link TEXT,
        dpl_ev_time TIMESTAMP DEFAULT NOW(),
        dpl_ev_issue_id TEXT,
        dpl_ev_issue_link TEXT,
        CONSTRAINT dpl_ev_pkg_fkey FOREIGN KEY (dpl_ev_pkg_id) REFERENCES packages (pkg_id)
    );
    COMMENT ON TABLE deployment_events IS
        'Table tracks all deployments tracked by pgpm';
    COMMENT ON COLUMN deployment_events.dpl_ev_vcs_ref IS
        'Reference to VCS point that was installed.
         In case of git, best option is to put here a specific commit reference.
         In case of SVN, revision number.';
    COMMENT ON COLUMN deployment_events.dpl_ev_vcs_link IS
        'Link to VCS repository.';
    COMMENT ON COLUMN deployment_events.dpl_ev_time IS
        'Deployment time';
    COMMENT ON COLUMN deployment_events.dpl_ev_issue_id IS
        'ID of an issue in issue tracker. E.g. ABS-111 for JIRA.';
    COMMENT ON COLUMN deployment_events.dpl_ev_issue_link IS
        'Link to an issue related to this deployment in issue tracker.';

END$$;
2015-12-10 17:13:19,065 - pgpm.app - DEBUG - Running version upgrade script 0.0.7-0.1.3.tmpl.sql
2015-12-10 17:13:19,065 - pgpm.app - DEBUG - /*
    Migration script from version 0.7.0 to 0.1.3 (or higher if tool doesn't find other migration scripts)
 */
DROP FUNCTION IF EXISTS _pgpm._add_package_info(TEXT, TEXT, INTEGER, INTEGER, INTEGER, INTEGER, TEXT, TEXT, TEXT, TEXT, INTEGER[], TEXT);

CREATE TABLE IF NOT EXISTS _pgpm.migrations_log
(
    m_id SERIAL NOT NULL,
    m_low_v TEXT,
    m_high_v TEXT,
    m_created TIMESTAMP DEFAULT NOW(),
    CONSTRAINT migrations_log_pkey PRIMARY KEY (m_id)
);
INSERT INTO _pgpm.migrations_log (m_low_v, m_high_v)
SELECT '0.0.1', '0.0.6'
WHERE
    NOT EXISTS (
        SELECT m_low_v, m_high_v FROM _pgpm.migrations_log
        WHERE m_low_v = '0.0.1' AND m_high_v = '0.0.6'
    );
COMMENT ON TABLE _pgpm.migrations_log IS
    'Logs each migration of pgpm to newer version. TODO: add statuses';

ALTER TABLE _pgpm.deployment_events DROP CONSTRAINT IF EXISTS dpl_ev_pkey;
ALTER TABLE _pgpm.deployment_events ADD CONSTRAINT dpl_ev_pkey PRIMARY KEY (dpl_ev_pkg_id, dpl_ev_time);
2015-12-10 17:13:19,071 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.7.0 to 0.1.3 (or higher if tool doesn't find other migration scripts)
 */
DROP FUNCTION IF EXISTS _pgpm._add_package_info(TEXT, TEXT, INTEGER, INTEGER, INTEGER, INTEGER, TEXT, TEXT, TEXT, TEXT, INTEGER[], TEXT);

CREATE TABLE IF NOT EXISTS _pgpm.migrations_log
(
    m_id SERIAL NOT NULL,
    m_low_v TEXT,
    m_high_v TEXT,
    m_created TIMESTAMP DEFAULT NOW(),
    CONSTRAINT migrations_log_pkey PRIMARY KEY (m_id)
);
INSERT INTO _pgpm.migrations_log (m_low_v, m_high_v)
SELECT '0.0.1', '0.0.6'
WHERE
    NOT EXISTS (
        SELECT m_low_v, m_high_v FROM _pgpm.migrations_log
        WHERE m_low_v = '0.0.1' AND m_high_v = '0.0.6'
    );
COMMENT ON TABLE _pgpm.migrations_log IS
    'Logs each migration of pgpm to newer version. TODO: add statuses';

ALTER TABLE _pgpm.deployment_events DROP CONSTRAINT IF EXISTS dpl_ev_pkey;
ALTER TABLE _pgpm.deployment_events ADD CONSTRAINT dpl_ev_pkey PRIMARY KEY (dpl_ev_pkg_id, dpl_ev_time);
2015-12-10 17:13:19,071 - pgpm.app - DEBUG - Running version upgrade script 0.1.4-0.1.5.tmpl.sql
2015-12-10 17:13:19,071 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.4 to 0.1.5 (or higher if tool doesn't find other migration scripts)
 */
DO $$
    BEGIN
        BEGIN
            ALTER TABLE _pgpm.deployment_events ADD COLUMN dpl_ev_id SERIAL NOT NULL;
            ALTER TABLE _pgpm.deployment_events DROP CONSTRAINT IF EXISTS dpl_ev_pkey;
            ALTER TABLE _pgpm.deployment_events ADD CONSTRAINT dpl_ev_pkey PRIMARY KEY (dpl_ev_id);
        EXCEPTION
            WHEN duplicate_column THEN RAISE NOTICE 'column dpl_ev_id already exists in _pgpm.deployment_events.';
        END;
    END;
$$

2015-12-10 17:13:19,076 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.4 to 0.1.5 (or higher if tool doesn't find other migration scripts)
 */
DO $$
    BEGIN
        BEGIN
            ALTER TABLE _pgpm.deployment_events ADD COLUMN dpl_ev_id SERIAL NOT NULL;
            ALTER TABLE _pgpm.deployment_events DROP CONSTRAINT IF EXISTS dpl_ev_pkey;
            ALTER TABLE _pgpm.deployment_events ADD CONSTRAINT dpl_ev_pkey PRIMARY KEY (dpl_ev_id);
        EXCEPTION
            WHEN duplicate_column THEN RAISE NOTICE 'column dpl_ev_id already exists in _pgpm.deployment_events.';
        END;
    END;
$$

2015-12-10 17:13:19,076 - pgpm.app - DEBUG - Running version upgrade script 0.1.6-0.1.7.tmpl.sql
2015-12-10 17:13:19,076 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.6 to 0.1.7 (or higher if tool doesn't find other migration scripts)
 */
ALTER TABLE _pgpm.packages DROP CONSTRAINT IF EXISTS pkg_unique;
ALTER TABLE _pgpm.packages ADD CONSTRAINT pkg_unique UNIQUE (pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch, pkg_v_pre, pkg_old_rev);
2015-12-10 17:13:19,078 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.6 to 0.1.7 (or higher if tool doesn't find other migration scripts)
 */
ALTER TABLE _pgpm.packages DROP CONSTRAINT IF EXISTS pkg_unique;
ALTER TABLE _pgpm.packages ADD CONSTRAINT pkg_unique UNIQUE (pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch, pkg_v_pre, pkg_old_rev);
2015-12-10 17:13:19,078 - pgpm.app - DEBUG - Running version upgrade script 0.1.8-0.1.9.tmpl.sql
2015-12-10 17:13:19,078 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.8 to 0.1.9 (or higher if tool doesn't find other migration scripts)
 */
CREATE TABLE IF NOT EXISTS _pgpm.package_statuses
(
    pkg_s_id SERIAL NOT NULL,
    pkg_s_name TEXT,
    CONSTRAINT pkg_s_pkey PRIMARY KEY (pkg_s_id)
);
COMMENT ON TABLE _pgpm.package_statuses IS
    'Package statuses';
INSERT INTO _pgpm.package_statuses (pkg_s_id, pkg_s_name)
SELECT 1, 'ADDED'
WHERE
    NOT EXISTS (
        SELECT pkg_s_id, pkg_s_name FROM _pgpm.package_statuses
        WHERE pkg_s_id = 1
    );

INSERT INTO _pgpm.package_statuses (pkg_s_id, pkg_s_name)
SELECT 2, 'IN PROGRESS'
WHERE
    NOT EXISTS (
        SELECT pkg_s_id, pkg_s_name FROM _pgpm.package_statuses
        WHERE pkg_s_id = 2
    );

INSERT INTO _pgpm.package_statuses (pkg_s_id, pkg_s_name)
SELECT 3, 'DELETED'
WHERE
    NOT EXISTS (
        SELECT pkg_s_id, pkg_s_name FROM _pgpm.package_statuses
        WHERE pkg_s_id = 3
    );

ALTER TABLE _pgpm.packages ADD COLUMN pkg_status INTEGER DEFAULT 1;
ALTER TABLE _pgpm.packages ADD CONSTRAINT pkg_status_fkey FOREIGN KEY (pkg_status) REFERENCES _pgpm.package_statuses (pkg_s_id);
2015-12-10 17:13:19,087 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.8 to 0.1.9 (or higher if tool doesn't find other migration scripts)
 */
CREATE TABLE IF NOT EXISTS _pgpm.package_statuses
(
    pkg_s_id SERIAL NOT NULL,
    pkg_s_name TEXT,
    CONSTRAINT pkg_s_pkey PRIMARY KEY (pkg_s_id)
);
COMMENT ON TABLE _pgpm.package_statuses IS
    'Package statuses';
INSERT INTO _pgpm.package_statuses (pkg_s_id, pkg_s_name)
SELECT 1, 'ADDED'
WHERE
    NOT EXISTS (
        SELECT pkg_s_id, pkg_s_name FROM _pgpm.package_statuses
        WHERE pkg_s_id = 1
    );

INSERT INTO _pgpm.package_statuses (pkg_s_id, pkg_s_name)
SELECT 2, 'IN PROGRESS'
WHERE
    NOT EXISTS (
        SELECT pkg_s_id, pkg_s_name FROM _pgpm.package_statuses
        WHERE pkg_s_id = 2
    );

INSERT INTO _pgpm.package_statuses (pkg_s_id, pkg_s_name)
SELECT 3, 'DELETED'
WHERE
    NOT EXISTS (
        SELECT pkg_s_id, pkg_s_name FROM _pgpm.package_statuses
        WHERE pkg_s_id = 3
    );

ALTER TABLE _pgpm.packages ADD COLUMN pkg_status INTEGER DEFAULT 1;
ALTER TABLE _pgpm.packages ADD CONSTRAINT pkg_status_fkey FOREIGN KEY (pkg_status) REFERENCES _pgpm.package_statuses (pkg_s_id);
2015-12-10 17:13:19,087 - pgpm.app - DEBUG - Running version upgrade script 0.1.10-0.1.10.tmpl.sql
2015-12-10 17:13:19,087 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.10 to 0.1.10 (or higher if tool doesn't find other migration scripts)
 */

CREATE TABLE IF NOT EXISTS _pgpm.ddl_changes_log
(
    ddl_change_id SERIAL NOT NULL,
    dpl_ev_id INTEGER,
    ddl_change_user NAME DEFAULT current_user,
    ddl_change TEXT,
    ddl_change_txid BIGINT DEFAULT txid_current(),
    ddl_change_created TIMESTAMP DEFAULT NOW(),
    CONSTRAINT ddl_change_pkey PRIMARY KEY (ddl_change_id)
);
COMMENT ON TABLE _pgpm.ddl_changes_log IS
    'Log of changes of DDL in database linked to deployment events if happened through deployment';

DROP EVENT TRIGGER IF EXISTS ddl_change_trigger;
CREATE EVENT TRIGGER ddl_change_trigger
ON ddl_command_end
WHEN TAG IN (
'ALTER AGGREGATE',
'ALTER COLLATION',
'ALTER CONVERSION',
'ALTER DOMAIN',
'ALTER EXTENSION',
'ALTER FOREIGN DATA WRAPPER',
'ALTER FOREIGN TABLE',
'ALTER FUNCTION',
'ALTER LANGUAGE',
'ALTER OPERATOR',
'ALTER OPERATOR CLASS',
'ALTER OPERATOR FAMILY',
'ALTER SCHEMA',
'ALTER SEQUENCE',
'ALTER SERVER',
'ALTER TABLE',
'ALTER TEXT SEARCH CONFIGURATION',
'ALTER TEXT SEARCH DICTIONARY',
'ALTER TEXT SEARCH PARSER',
'ALTER TEXT SEARCH TEMPLATE',
'ALTER TRIGGER',
'ALTER TYPE',
'ALTER USER MAPPING',
'ALTER VIEW',
'CREATE AGGREGATE',
'CREATE CAST',
'CREATE COLLATION',
'CREATE CONVERSION',
'CREATE DOMAIN',
'CREATE EXTENSION',
'CREATE FOREIGN DATA WRAPPER',
'CREATE FOREIGN TABLE',
'CREATE FUNCTION',
'CREATE INDEX',
'CREATE LANGUAGE',
'CREATE OPERATOR',
'CREATE OPERATOR CLASS',
'CREATE OPERATOR FAMILY',
'CREATE RULE',
'CREATE SCHEMA',
'CREATE SEQUENCE',
'CREATE SERVER',
'CREATE TABLE',
'CREATE TABLE AS',
'CREATE TEXT SEARCH CONFIGURATION',
'CREATE TEXT SEARCH DICTIONARY',
'CREATE TEXT SEARCH PARSER',
'CREATE TEXT SEARCH TEMPLATE',
'CREATE TRIGGER',
'CREATE TYPE',
'CREATE USER MAPPING',
'CREATE VIEW',
'DROP AGGREGATE',
'DROP CAST',
'DROP COLLATION',
'DROP CONVERSION',
'DROP DOMAIN',
'DROP EXTENSION',
'DROP FOREIGN DATA WRAPPER',
'DROP FOREIGN TABLE',
'DROP FUNCTION',
'DROP INDEX',
'DROP LANGUAGE',
'DROP OPERATOR',
'DROP OPERATOR CLASS',
'DROP OPERATOR FAMILY',
'DROP OWNED',
'DROP RULE',
'DROP SCHEMA',
'DROP SEQUENCE',
'DROP SERVER',
'DROP TABLE',
'DROP TEXT SEARCH CONFIGURATION',
'DROP TEXT SEARCH DICTIONARY',
'DROP TEXT SEARCH PARSER',
'DROP TEXT SEARCH TEMPLATE',
'DROP TRIGGER',
'DROP TYPE',
'DROP USER MAPPING',
'DROP VIEW')
EXECUTE PROCEDURE _pgpm._log_ddl_change();
2015-12-10 17:13:19,091 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.10 to 0.1.10 (or higher if tool doesn't find other migration scripts)
 */

CREATE TABLE IF NOT EXISTS _pgpm.ddl_changes_log
(
    ddl_change_id SERIAL NOT NULL,
    dpl_ev_id INTEGER,
    ddl_change_user NAME DEFAULT current_user,
    ddl_change TEXT,
    ddl_change_txid BIGINT DEFAULT txid_current(),
    ddl_change_created TIMESTAMP DEFAULT NOW(),
    CONSTRAINT ddl_change_pkey PRIMARY KEY (ddl_change_id)
);
COMMENT ON TABLE _pgpm.ddl_changes_log IS
    'Log of changes of DDL in database linked to deployment events if happened through deployment';

DROP EVENT TRIGGER IF EXISTS ddl_change_trigger;
CREATE EVENT TRIGGER ddl_change_trigger
ON ddl_command_end
WHEN TAG IN (
'ALTER AGGREGATE',
'ALTER COLLATION',
'ALTER CONVERSION',
'ALTER DOMAIN',
'ALTER EXTENSION',
'ALTER FOREIGN DATA WRAPPER',
'ALTER FOREIGN TABLE',
'ALTER FUNCTION',
'ALTER LANGUAGE',
'ALTER OPERATOR',
'ALTER OPERATOR CLASS',
'ALTER OPERATOR FAMILY',
'ALTER SCHEMA',
'ALTER SEQUENCE',
'ALTER SERVER',
'ALTER TABLE',
'ALTER TEXT SEARCH CONFIGURATION',
'ALTER TEXT SEARCH DICTIONARY',
'ALTER TEXT SEARCH PARSER',
'ALTER TEXT SEARCH TEMPLATE',
'ALTER TRIGGER',
'ALTER TYPE',
'ALTER USER MAPPING',
'ALTER VIEW',
'CREATE AGGREGATE',
'CREATE CAST',
'CREATE COLLATION',
'CREATE CONVERSION',
'CREATE DOMAIN',
'CREATE EXTENSION',
'CREATE FOREIGN DATA WRAPPER',
'CREATE FOREIGN TABLE',
'CREATE FUNCTION',
'CREATE INDEX',
'CREATE LANGUAGE',
'CREATE OPERATOR',
'CREATE OPERATOR CLASS',
'CREATE OPERATOR FAMILY',
'CREATE RULE',
'CREATE SCHEMA',
'CREATE SEQUENCE',
'CREATE SERVER',
'CREATE TABLE',
'CREATE TABLE AS',
'CREATE TEXT SEARCH CONFIGURATION',
'CREATE TEXT SEARCH DICTIONARY',
'CREATE TEXT SEARCH PARSER',
'CREATE TEXT SEARCH TEMPLATE',
'CREATE TRIGGER',
'CREATE TYPE',
'CREATE USER MAPPING',
'CREATE VIEW',
'DROP AGGREGATE',
'DROP CAST',
'DROP COLLATION',
'DROP CONVERSION',
'DROP DOMAIN',
'DROP EXTENSION',
'DROP FOREIGN DATA WRAPPER',
'DROP FOREIGN TABLE',
'DROP FUNCTION',
'DROP INDEX',
'DROP LANGUAGE',
'DROP OPERATOR',
'DROP OPERATOR CLASS',
'DROP OPERATOR FAMILY',
'DROP OWNED',
'DROP RULE',
'DROP SCHEMA',
'DROP SEQUENCE',
'DROP SERVER',
'DROP TABLE',
'DROP TEXT SEARCH CONFIGURATION',
'DROP TEXT SEARCH DICTIONARY',
'DROP TEXT SEARCH PARSER',
'DROP TEXT SEARCH TEMPLATE',
'DROP TRIGGER',
'DROP TYPE',
'DROP USER MAPPING',
'DROP VIEW')
EXECUTE PROCEDURE _pgpm._log_ddl_change();
2015-12-10 17:13:19,091 - pgpm.app - DEBUG - Running version upgrade script 0.1.11-0.1.11.tmpl.sql
2015-12-10 17:13:19,091 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.11 to 0.1.11 (or higher if tool doesn't find other migration scripts)
 */

ALTER TABLE _pgpm.ddl_changes_log DROP COLUMN dpl_ev_id;
ALTER TABLE _pgpm.deployment_events ADD COLUMN dpl_ev_txid BIGINT;

2015-12-10 17:13:19,093 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.11 to 0.1.11 (or higher if tool doesn't find other migration scripts)
 */

ALTER TABLE _pgpm.ddl_changes_log DROP COLUMN dpl_ev_id;
ALTER TABLE _pgpm.deployment_events ADD COLUMN dpl_ev_txid BIGINT;

2015-12-10 17:13:19,093 - pgpm.app - DEBUG - Running version upgrade script 0.1.12-0.1.12.tmpl.sql
2015-12-10 17:13:19,093 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.12 to 0.1.12 (or higher if tool doesn't find other migration scripts)
 */

CREATE TABLE _pgpm.table_evolutions_log (
    t_evo_id SERIAL NOT NULL,
    t_evo_file_name TEXT,
    t_evo_package INTEGER,
    CONSTRAINT table_evolutions_log_pkey PRIMARY KEY (t_evo_id),
    CONSTRAINT package_fkey FOREIGN KEY (t_evo_package) REFERENCES _pgpm.packages (pkg_id)
);
2015-12-10 17:13:19,097 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.12 to 0.1.12 (or higher if tool doesn't find other migration scripts)
 */

CREATE TABLE _pgpm.table_evolutions_log (
    t_evo_id SERIAL NOT NULL,
    t_evo_file_name TEXT,
    t_evo_package INTEGER,
    CONSTRAINT table_evolutions_log_pkey PRIMARY KEY (t_evo_id),
    CONSTRAINT package_fkey FOREIGN KEY (t_evo_package) REFERENCES _pgpm.packages (pkg_id)
);
2015-12-10 17:13:19,097 - pgpm.app - DEBUG - Running version upgrade script 0.1.13-0.1.17.tmpl.sql
2015-12-10 17:13:19,097 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.13 to 0.1.17 (or higher if tool doesn't find other migration scripts)
 */

ALTER TABLE _pgpm.table_evolutions_log ADD COLUMN t_evo_created TIMESTAMP DEFAULT NOW();

2015-12-10 17:13:19,100 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.13 to 0.1.17 (or higher if tool doesn't find other migration scripts)
 */

ALTER TABLE _pgpm.table_evolutions_log ADD COLUMN t_evo_created TIMESTAMP DEFAULT NOW();

2015-12-10 17:13:19,101 - pgpm.app - DEBUG - Running version upgrade script 0.1.18-0.1.18.tmpl.sql
2015-12-10 17:13:19,101 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.18 to 0.1.18 (or higher if tool doesn't find other migration scripts)
 */
COMMENT ON TABLE _pgpm.table_evolutions_log IS
    'Table tracks all table evolution statements (ALTER TABLE + DML) for pgpm packages';
COMMENT ON COLUMN _pgpm.table_evolutions_log.t_evo_file_name IS
    'File name acts as a key to check whether evolution has already been applied or not';
2015-12-10 17:13:19,101 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.18 to 0.1.18 (or higher if tool doesn't find other migration scripts)
 */
COMMENT ON TABLE _pgpm.table_evolutions_log IS
    'Table tracks all table evolution statements (ALTER TABLE + DML) for pgpm packages';
COMMENT ON COLUMN _pgpm.table_evolutions_log.t_evo_file_name IS
    'File name acts as a key to check whether evolution has already been applied or not';
2015-12-10 17:13:19,101 - pgpm.app - DEBUG - Running version upgrade script 0.1.19-0.1.33.tmpl.sql
2015-12-10 17:13:19,101 - pgpm.app - DEBUG - /*
    Migration script from version 0.1.19 to 0.1.33 (or higher if tool doesn't find other migration scripts)
 */

ALTER TABLE _pgpm.ddl_changes_log ALTER COLUMN ddl_change_user SET DEFAULT session_user;
2015-12-10 17:13:19,102 - pgpm.app - DEBUG - Executing query: /*
    Migration script from version 0.1.19 to 0.1.33 (or higher if tool doesn't find other migration scripts)
 */

ALTER TABLE _pgpm.ddl_changes_log ALTER COLUMN ddl_change_user SET DEFAULT session_user;
2015-12-10 17:13:19,103 - pgpm.app - DEBUG - Calling stored procedure: SELECT * FROM _add_migration_info('0.0.7','0.1.49')
2015-12-10 17:13:19,109 - pgpm.app - DEBUG - No user was specified to have permisions on _pgpm schema. This means only user that installed _pgpm will be able to deploy. We recommend adding more users.
2015-12-10 17:13:19,109 - pgpm.app - DEBUG - Executing query: set search_path TO _pgpm, public;
2015-12-10 17:13:19,114 - pgpm.app - DEBUG - Calling stored procedure: SELECT * FROM _upsert_package_info('_pgpm','basic','0','1','49',NULL,NULL,'Package manager for Postgres','MIT')
2015-12-10 17:13:19,114 - pgpm.app - DEBUG - Closing connection to host=localhost port=5432 dbname=pgpm_test_3 user=apanchoyan...
2015-12-10 17:13:19,115 - pgpm.app - DEBUG - Connection to host=localhost port=5432 dbname=pgpm_test_3 user=apanchoyan closed.
2015-12-10 17:13:19,115 - pgpm.app - INFO - Successfully installed host=localhost port=5432 dbname=pgpm_test_3 user=apanchoyan
2015-12-11 11:57:48,976 - pgpm.app - INFO - Installing... host=devel-db2.affinitas.de port=6223 dbname=de_live_devel_db user=apanchoyan password=snojpoksIb6
2015-12-11 11:57:49,153 - pgpm.app - DEBUG - lib/db_scripts/functions/_add_migration_info.sql
2015-12-11 11:57:49,153 - pgpm.app - DEBUG - lib/db_scripts/functions/_alter_schema_owner.sql
2015-12-11 11:57:49,154 - pgpm.app - DEBUG - lib/db_scripts/functions/_find_schema.sql
2015-12-11 11:57:49,154 - pgpm.app - DEBUG - lib/db_scripts/functions/_is_table_ddl_executed.sql
2015-12-11 11:57:49,154 - pgpm.app - DEBUG - lib/db_scripts/functions/_log_ddl_change.sql
2015-12-11 11:57:49,154 - pgpm.app - DEBUG - lib/db_scripts/functions/_log_table_evolution.sql
2015-12-11 11:57:49,154 - pgpm.app - DEBUG - lib/db_scripts/functions/_set_revision_package.sql
2015-12-11 11:57:49,154 - pgpm.app - DEBUG - lib/db_scripts/functions/_upsert_package_info.sql
2015-12-11 11:57:49,154 - pgpm.app - DEBUG - lib/db_scripts/functions/set_search_path.sql
2015-12-11 11:57:49,168 - pgpm.app - DEBUG - Executing query: select * from CURRENT_USER;
2015-12-11 11:57:49,174 - pgpm.app - DEBUG - Executing query: select usesuper from pg_user where usename = CURRENT_USER;
2015-12-11 11:57:49,179 - pgpm.app - DEBUG - Executing query: SELECT EXISTS (SELECT schema_name FROM information_schema.schemata WHERE schema_name = '_pgpm');
2015-12-11 11:57:49,179 - pgpm.app - INFO - Running functions definitions scripts
2015-12-11 11:57:49,179 - pgpm.app - DEBUG - {'_log_ddl_change.sql': u'CREATE OR REPLACE FUNCTION _log_ddl_change()\n    RETURNS EVENT_TRIGGER AS\n$BODY$\n---\n-- @description\n-- Logs any DDL changes to the DB\n--\n---\nDECLARE\n    l_current_query TEXT;\n    l_txid BIGINT;\nBEGIN\n\n    SELECT current_query() INTO l_current_query;\n    SELECT txid_current() INTO l_txid;\n    INSERT INTO _pgpm.ddl_changes_log (ddl_change)\n    SELECT l_current_query\n    WHERE\n        NOT EXISTS (\n            SELECT ddl_change_txid, ddl_change FROM _pgpm.ddl_changes_log\n            WHERE ddl_change_txid = l_txid AND ddl_change = l_current_query\n        );\n\n    -- Notify external channels of ddl change\n    PERFORM pg_notify(\'ddl_change\', "session_user"());\n\nEND;\n$BODY$\nLANGUAGE \'plpgsql\' VOLATILE SECURITY DEFINER;', '_add_migration_info.sql': u"CREATE OR REPLACE FUNCTION _add_migration_info(p_m_low_v TEXT, p_m_high_v TEXT)\n    RETURNS VOID AS\n$BODY$\n---\n-- @description\n-- Adds migration info migrations log table\n--\n-- @param p_m_low_v\n-- lower border of version that is applicaple for this migration\n--\n-- @param p_m_high_v\n-- package type: either version (with version suffix at the end of the name) or basic (without)\n--\n-- @param p_pkg_old_rev\n-- higher border of version that is applicaple for this migration\n--\n---\nBEGIN\n\n    BEGIN\n        INSERT INTO migrations_log (m_low_v, m_high_v)\n            VALUES (p_m_low_v, p_m_high_v);\n    EXCEPTION\n        WHEN SQLSTATE '42P01' THEN\n            RAISE WARNING 'Can''t log migration from % to % as migrations_log is not defined yet', p_m_low_v, p_m_high_v;\n    END;\nEND;\n$BODY$\nLANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", 'set_search_path.sql': u"CREATE OR REPLACE FUNCTION set_search_path(p_schema_name TEXT, p_v_req TEXT)\n    RETURNS json AS\n$BODY$\n---\n-- @description\n-- Sets search path that includes also all depending\n--\n-- @param p_schema_name\n-- Package (schema) name\n--\n-- @param p_v_req\n-- Package version requirement. Version notation supports:\n-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)\n-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x\n-- - comparison operators like >01_02_03 or <2\n-- - x for any latest version of package\n-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency\n--\n-- @returns\n-- JSON with schema names and exact versions or exception if not found\n---\nDECLARE\n    l_search_path TEXT;\n    l_search_path_deps TEXT;\n    l_listen_text TEXT;\n\n    l_pkg_version_wrapped RECORD;\n    l_pkg_version RECORD;\n\n    return_value json;\nBEGIN\n\n    SET search_path TO _pgpm;\n    SELECT _find_schema(p_schema_name, p_v_req) AS version INTO l_pkg_version_wrapped;\n    l_pkg_version := l_pkg_version_wrapped.version;\n\n    l_search_path := l_pkg_version.pkg_name || '_' ||\n                     l_pkg_version.pkg_v_major::text || '_' ||\n                     l_pkg_version.pkg_v_minor::text || '_' ||\n                     l_pkg_version.pkg_v_patch::text;\n\n    SELECT string_agg(pkg_name || '_' || pkg_v_major || '_' || pkg_v_minor || '_' || pkg_v_patch, ', ')\n    FROM packages\n    WHERE pkg_id IN (\n        SELECT pkg_link_dep_id from package_dependencies\n        JOIN packages ON pkg_id = l_pkg_version.pkg_id\n        WHERE pkg_link_core_id = pkg_id\n    )\n    INTO l_search_path_deps;\n\n    l_search_path := l_search_path || ', ' || l_search_path_deps;\n\n    l_listen_text := 'deployment_events' || '$$' || l_pkg_version.pkg_name;\n    EXECUTE 'LISTEN ' || l_listen_text;\n\n    RAISE INFO '%', l_search_path;\n    PERFORM set_config('search_path', l_search_path || ', public', false);\n\n    return_value := row_to_json(l_pkg_version);\n    RETURN return_value;\n\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_find_schema.sql': u"CREATE OR REPLACE FUNCTION _find_schema(p_schema_name TEXT, p_v_req TEXT)\n    RETURNS RECORD AS\n$BODY$\n---\n-- @description\n-- Searches for existing schema (package) within registered packages in _pgpm schema\n--\n-- @param p_schema_name\n-- Package (schema) name\n--\n-- @param p_v_req\n-- Package version requirement. Version notation supports:\n-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)\n-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x\n-- - comparison operators like >01_02_03 or <2\n-- - x for any latest version of package\n-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency\n--\n-- @returns\n-- Record containing schema name and exact version or exception if not found in the following format:\n-- pkg_name TEXT, pkg_v_major INTEGER, pkg_v_minor INTEGER, pkg_v_patch INTEGER\n---\nDECLARE\n    c_re_version TEXT = '^(<=|>=|<|>{0,2})(\\d*|x*)_?(\\d*|x*)_?(\\d*|x*)';\n    l_v_matches TEXT[];\n\n    l_v_major INTEGER;\n    l_v_minor INTEGER;\n    l_v_patch INTEGER;\n\n    return_value RECORD;\nBEGIN\n\n    SELECT regexp_matches(p_v_req, c_re_version, 'gi') INTO l_v_matches;\n\n    IF l_v_matches[2] ~* '^x+|^$' THEN\n        SELECT max(pkg_v_major)\n        FROM packages\n        WHERE pkg_name = p_schema_name\n        INTO l_v_major;\n    ELSE\n        l_v_major := l_v_matches[2]::integer;\n    END IF;\n\n    IF l_v_matches[3] ~* '^x+|^$' THEN\n        SELECT max(pkg_v_minor)\n        FROM packages\n        WHERE pkg_name = p_schema_name\n              AND pkg_v_major = l_v_major\n        INTO l_v_minor;\n    ELSE\n        l_v_minor := l_v_matches[3]::integer;\n    END IF;\n\n    IF l_v_matches[4] ~* '^x+|^$' THEN\n        SELECT max(pkg_v_patch)\n        FROM packages\n        WHERE pkg_name = p_schema_name\n              AND pkg_v_major = l_v_major\n              AND pkg_v_minor = l_v_minor\n        INTO l_v_patch;\n    ELSE\n        l_v_patch := l_v_matches[4]::integer;\n    END IF;\n\n    CASE l_v_matches[1]\n        WHEN '=', '' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND pkg_v_major = l_v_major\n                  AND pkg_v_minor = l_v_minor\n                  AND pkg_v_patch = l_v_patch\n            INTO return_value;\n        WHEN '<' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major < l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor < l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch < l_v_patch))\n            INTO return_value;\n        WHEN '>' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major > l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor > l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch > l_v_patch))\n            INTO return_value;\n        WHEN '<=' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major <= l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor <= l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch <= l_v_patch))\n            INTO return_value;\n        WHEN '>=' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major >= l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor >= l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch >= l_v_patch))\n            INTO return_value;\n        ELSE\n            RAISE EXCEPTION 'Invalid logical operand. Only <, >, =, <=, >=, = or no operand are allowed.' USING ERRCODE = '20000';\n    END CASE;\n\n    RETURN return_value;\n\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_upsert_package_info.sql': u"CREATE OR REPLACE FUNCTION _upsert_package_info(p_pkg_name TEXT,\n                                             p_pkg_subclass_name TEXT,\n                                             p_pkg_v_major INTEGER,\n                                             p_pkg_v_minor INTEGER DEFAULT 0,\n                                             p_pkg_v_patch INTEGER DEFAULT 0,\n                                             p_pkg_v_pre TEXT DEFAULT NULL,\n                                             p_pkg_v_metadata TEXT DEFAULT NULL,\n                                             p_pkg_description TEXT DEFAULT '',\n                                             p_pkg_license TEXT DEFAULT NULL,\n                                             p_pkg_deps_ids INTEGER[] DEFAULT '{}',\n                                             p_pkg_vcs_ref TEXT DEFAULT NULL,\n                                             p_pkg_vcs_link TEXT DEFAULT NULL,\n                                             p_pkg_issue_ref TEXT DEFAULT NULL,\n                                             p_pkg_issue_link TEXT DEFAULT NULL)\n    RETURNS INTEGER AS\n$BODY$\n---\n-- @description\n-- Adds package info to pgpm package info table, deployment events table and notifies channels of deployment\n--\n-- @param p_pkg_name\n-- package name\n--\n-- @param p_pkg_subclass_name\n-- package type: either version (with version suffix at the end of the name) or basic (without)\n--\n-- @param p_pkg_description\n-- package description\n--\n-- @param p_pkg_v_major\n-- package major part of version (according to semver)\n--\n-- @param p_pkg_v_minor\n-- package minor part of version (according to semver)\n--\n-- @param p_pkg_v_patch\n-- package patch part of version (according to semver)\n--\n-- @param p_pkg_v_pre\n-- package pre part of version (according to semver)\n--\n-- @param p_pkg_v_metadata\n-- package metadata part of version (according to semver)\n--\n-- @param p_pkg_license\n-- package license name/text\n--\n-- @param p_pkg_deps_ids\n-- IDs of dependent schemas\n--\n-- @param p_pkg_vcs_ref\n-- vcs reference to track the code\n--\n-- @param p_pkg_vcs_link\n-- repository link to track the code\n--\n-- @param p_pkg_issue_ref\n-- issue reference to track the code\n--\n-- @param p_pkg_issue_link\n-- issue tracking system link\n---\nDECLARE\n    l_existing_pkg_id INTEGER;\n    l_pkg_dep_id INTEGER;\n\n\treturn_value INTEGER;\nBEGIN\n\n    -- Case 1: unsafe mode, rewrite of the whole schema with the same version or some of the files in it\n    -- Case 2: new schema with new version (safe or moderate modes)\n\n    IF p_pkg_subclass_name = 'basic' THEN\n        SELECT pkg_id INTO l_existing_pkg_id\n        FROM packages\n        WHERE pkg_name = p_pkg_name\n            AND pkg_subclass IN (SELECT pkg_sc_id\n                                 FROM package_subclasses\n                                 WHERE pkg_sc_name = p_pkg_subclass_name);\n    ELSE\n        SELECT pkg_id INTO l_existing_pkg_id\n        FROM packages\n        WHERE pkg_name = p_pkg_name\n            AND pkg_subclass IN (SELECT pkg_sc_id\n                                 FROM package_subclasses\n                                 WHERE pkg_sc_name = p_pkg_subclass_name)\n            AND pkg_v_major = p_pkg_v_major\n            AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)\n            AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)\n            AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre)\n            AND pkg_old_rev IS NULL;\n    END IF;\n\n    IF FOUND THEN -- Case 1:\n        DELETE FROM package_dependencies\n            WHERE pkg_link_core_id = l_existing_pkg_id;\n\n        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids\n        LOOP\n            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (l_existing_pkg_id, l_pkg_dep_id);\n        END LOOP;\n\n        UPDATE packages\n        SET pkg_name=subquery.p_pkg_name,\n            pkg_subclass=subquery.pkg_sc_id,\n            pkg_v_major=subquery.p_pkg_v_major,\n            pkg_v_minor=subquery.p_pkg_v_minor,\n            pkg_v_patch=subquery.p_pkg_v_patch,\n            pkg_v_pre=subquery.p_pkg_v_pre,\n            pkg_v_metadata=subquery.p_pkg_v_metadata,\n            pkg_description=subquery.p_pkg_description,\n            pkg_license=subquery.p_pkg_license\n        FROM (SELECT\n                  p_pkg_name,\n                  pkg_sc_id,\n                  p_pkg_v_major,\n                  p_pkg_v_minor,\n                  p_pkg_v_patch,\n                  p_pkg_v_pre,\n                  p_pkg_v_metadata,\n                  p_pkg_description,\n                  p_pkg_license\n              FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name\n        ) as subquery\n        WHERE packages.pkg_name=subquery.p_pkg_name;\n\n        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)\n            VALUES (l_existing_pkg_id, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);\n\n        return_value := l_existing_pkg_id;\n    ELSE -- Case 2:\n        INSERT INTO packages (\n            pkg_name,\n            pkg_description,\n            pkg_v_major,\n            pkg_v_minor,\n            pkg_v_patch,\n            pkg_v_pre,\n            pkg_v_metadata,\n            pkg_subclass,\n            pkg_license\n        )\n        SELECT\n            p_pkg_name,\n            p_pkg_description,\n            p_pkg_v_major,\n            p_pkg_v_minor,\n            p_pkg_v_patch,\n            p_pkg_v_pre,\n            p_pkg_v_metadata,\n            pkg_sc_id,\n            p_pkg_license\n        FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name\n        RETURNING\n            pkg_id\n        INTO return_value;\n\n        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids\n        LOOP\n            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (return_value, l_pkg_dep_id);\n        END LOOP;\n\n        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)\n            VALUES (return_value, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);\n\n    END IF;\n\n    -- Notify external channels of successful deployment event\n    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);\n\n    RETURN return_value;\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_alter_schema_owner.sql': u"CREATE OR REPLACE FUNCTION _alter_schema_owner(p_schema TEXT, p_owner TEXT)\n    RETURNS VOID AS\n$BODY$\n---\n-- @description\n-- Alters ownership of schema and all its objects to a specified user.\n--\n-- @param p_schema\n-- Schema name\n--\n-- @param p_owner\n-- New owner user name\n--\n---\nDECLARE\n    l_schema TEXT;\n    l_functions TEXT;\n    l_tables TEXT;\n    l_sequences TEXT;\n    l_views TEXT;\n    l_domains TEXT;\n    l_triggers TEXT;\n    l_types TEXT;\n\nBEGIN\n\n    l_schema := 'ALTER SCHEMA '\n                || quote_ident(p_schema)\n                || ' OWNER TO '\n                || quote_ident(p_owner)\n                || ';';\n\n    SELECT string_agg('ALTER FUNCTION '\n                || quote_ident(n.nspname) || '.'\n                || quote_ident(p.proname) || '('\n                || pg_catalog.pg_get_function_identity_arguments(p.oid)\n                || ') OWNER TO ' || p_owner || ';'\n              , E'\\n') AS _sql\n    FROM   pg_catalog.pg_proc p\n    JOIN   pg_catalog.pg_namespace n ON n.oid = p.pronamespace\n    WHERE  n.nspname = p_schema\n    INTO l_functions;\n    IF l_functions IS NULL THEN\n        l_functions := '';\n    END IF;\n\n    SELECT string_agg('ALTER TABLE ' || quote_ident(schemaname) || '.' || quote_ident(tablename) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM pg_tables WHERE schemaname = p_schema\n    INTO l_tables;\n    IF l_tables IS NULL THEN\n        l_tables := '';\n    END IF;\n\n    SELECT string_agg('ALTER SEQUENCE ' || quote_ident(sequence_schema) || '.' || quote_ident(sequence_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.sequences WHERE sequence_schema = p_schema\n    INTO l_sequences;\n    IF l_sequences IS NULL THEN\n        l_sequences := '';\n    END IF;\n\n    SELECT string_agg('ALTER VIEW ' || quote_ident(table_schema) || '.' || quote_ident(table_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.views WHERE table_schema = p_schema\n    INTO l_views;\n    IF l_views IS NULL THEN\n        l_views := '';\n    END IF;\n\n    SELECT string_agg('ALTER DOMAIN ' || quote_ident(domain_schema) || '.' || quote_ident(domain_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.domains WHERE domain_schema = p_schema\n    INTO l_domains;\n    IF l_domains IS NULL THEN\n        l_domains := '';\n    END IF;\n\n    SELECT string_agg('ALTER TRIGGER ' || quote_ident(trigger_schema) || '.' || quote_ident(trigger_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.triggers WHERE trigger_schema = p_schema\n    INTO l_triggers;\n    IF l_triggers IS NULL THEN\n        l_triggers := '';\n    END IF;\n\n    SELECT string_agg('ALTER TYPE ' || quote_ident(user_defined_type_schema) || '.' || quote_ident(user_defined_type_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.user_defined_types WHERE user_defined_type_schema = p_schema\n    INTO l_types;\n    IF l_types IS NULL THEN\n        l_types := '';\n    END IF;\n\n    EXECUTE l_schema || l_functions || l_tables || l_sequences || l_views || l_domains || l_triggers || l_types;\n\nEND;\n$BODY$\nLANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;", '_log_table_evolution.sql': u"CREATE OR REPLACE FUNCTION _log_table_evolution(p_t_evo_file_name TEXT, p_t_evo_package INTEGER)\n    RETURNS VOID AS\n$BODY$\n---\n-- @description\n-- Adds information about executed table evolution script to log table\n--\n-- @param p_t_evo_file_name\n-- File name with executed statements.\n--\n-- @param p_t_evo_package\n-- Related package id\n--\n-- @param p_pkg_old_rev\n-- higher border of version that is applicaple for this migration\n--\n---\nBEGIN\n\n    INSERT INTO table_evolutions_log (t_evo_file_name, t_evo_package)\n        VALUES (p_t_evo_file_name, p_t_evo_package);\nEND;\n$BODY$\nLANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;", '_is_table_ddl_executed.sql': u"CREATE OR REPLACE FUNCTION _is_table_ddl_executed(p_file_name TEXT)\n    RETURNS BOOLEAN AS\n$BODY$\n---\n-- @description\n-- Checks whether file with table ddl has already been executed\n--\n-- @param p_file_name\n-- File name used to check whether statements were executed\n--\n-- @returns\n-- True if executed, False otherwise\n---\nDECLARE\n    return_value BOOLEAN;\nBEGIN\n\n    SELECT EXISTS (SELECT t_evo_id FROM table_evolutions_log WHERE t_evo_file_name=p_file_name) INTO return_value;\n\n    RETURN return_value;\n\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_set_revision_package.sql': u"CREATE OR REPLACE FUNCTION _set_revision_package(p_pkg_name TEXT,\n                                             p_pkg_subclass_name TEXT,\n                                             p_pkg_old_rev INTEGER,\n                                             p_pkg_v_major INTEGER,\n                                             p_pkg_v_minor INTEGER DEFAULT 0,\n                                             p_pkg_v_patch INTEGER DEFAULT 0,\n                                             p_pkg_v_pre TEXT DEFAULT NULL)\n    RETURNS INTEGER AS\n$BODY$\n---\n-- @description\n-- Set package as old revision, info logged in deployment events table\n--\n-- @param p_pkg_name\n-- package name\n--\n-- @param p_pkg_subclass_name\n-- package type: either version (with version suffix at the end of the name) or basic (without)\n--\n-- @param p_pkg_old_rev\n-- Revision name of package. Used in moderate form. When schema is renamed it is given a revision suffix from here\n--\n-- @param p_pkg_v_major\n-- package major part of version (according to semver)\n--\n-- @param p_pkg_v_minor\n-- package minor part of version (according to semver)\n--\n-- @param p_pkg_v_patch\n-- package patch part of version (according to semver)\n--\n-- @param p_pkg_v_pre\n-- package pre part of version (according to semver)\n--\n-- @param p_pkg_v_metadata\n-- package metadata part of version (according to semver)\n--\n-- @param p_pkg_vcs_ref\n-- vcs reference to track the code\n---\nDECLARE\n    l_existing_pkg_id INTEGER;\n    l_pkg_dep_id INTEGER;\n\n\treturn_value INTEGER;\nBEGIN\n\n    SELECT pkg_id INTO l_existing_pkg_id\n    FROM packages\n    WHERE pkg_name = p_pkg_name\n        AND pkg_subclass IN (SELECT pkg_sc_id\n                             FROM package_subclasses\n                             WHERE pkg_sc_name = p_pkg_subclass_name)\n        AND pkg_v_major = p_pkg_v_major\n        AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)\n        AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)\n        AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre);\n\n    IF FOUND THEN\n        UPDATE packages\n        SET pkg_old_rev=p_pkg_old_rev\n        WHERE packages.pkg_id=l_existing_pkg_id;\n\n        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)\n            SELECT pkg_id, txid_current(), dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link\n            FROM packages\n            JOIN deployment_events ON dpl_ev_pkg_id=pkg_id\n            WHERE pkg_id=l_existing_pkg_id AND dpl_ev_time IN (\n                SELECT max(dpl_ev_time) FROM deployment_events WHERE dpl_ev_pkg_id=packages.pkg_id\n            );\n    ELSE\n        RAISE EXCEPTION 'Package % not found in the list of packages. It could happen if schema exists but wasn''t properly deployed with pgpm', p_pkg_name || '_' || p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch;\n    END IF;\n\n    -- Notify external channels of successful deployment event\n    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);\n\n    RETURN return_value;\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n"}
2015-12-11 11:57:49,182 - pgpm.app - DEBUG - Executing query: set search_path TO _pgpm, public;
2015-12-11 11:57:49,213 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _log_ddl_change()
    RETURNS EVENT_TRIGGER AS
$BODY$
---
-- @description
-- Logs any DDL changes to the DB
--
---
DECLARE
    l_current_query TEXT;
    l_txid BIGINT;
BEGIN

    SELECT current_query() INTO l_current_query;
    SELECT txid_current() INTO l_txid;
    INSERT INTO _pgpm.ddl_changes_log (ddl_change)
    SELECT l_current_query
    WHERE
        NOT EXISTS (
            SELECT ddl_change_txid, ddl_change FROM _pgpm.ddl_changes_log
            WHERE ddl_change_txid = l_txid AND ddl_change = l_current_query
        );

    -- Notify external channels of ddl change
    PERFORM pg_notify('ddl_change', "session_user"());

END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;
2015-12-11 11:57:49,222 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _add_migration_info(p_m_low_v TEXT, p_m_high_v TEXT)
    RETURNS VOID AS
$BODY$
---
-- @description
-- Adds migration info migrations log table
--
-- @param p_m_low_v
-- lower border of version that is applicaple for this migration
--
-- @param p_m_high_v
-- package type: either version (with version suffix at the end of the name) or basic (without)
--
-- @param p_pkg_old_rev
-- higher border of version that is applicaple for this migration
--
---
BEGIN

    BEGIN
        INSERT INTO migrations_log (m_low_v, m_high_v)
            VALUES (p_m_low_v, p_m_high_v);
    EXCEPTION
        WHEN SQLSTATE '42P01' THEN
            RAISE WARNING 'Can''t log migration from % to % as migrations_log is not defined yet', p_m_low_v, p_m_high_v;
    END;
END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-11 11:57:49,235 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION set_search_path(p_schema_name TEXT, p_v_req TEXT)
    RETURNS json AS
$BODY$
---
-- @description
-- Sets search path that includes also all depending
--
-- @param p_schema_name
-- Package (schema) name
--
-- @param p_v_req
-- Package version requirement. Version notation supports:
-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)
-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x
-- - comparison operators like >01_02_03 or <2
-- - x for any latest version of package
-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency
--
-- @returns
-- JSON with schema names and exact versions or exception if not found
---
DECLARE
    l_search_path TEXT;
    l_search_path_deps TEXT;
    l_listen_text TEXT;

    l_pkg_version_wrapped RECORD;
    l_pkg_version RECORD;

    return_value json;
BEGIN

    SET search_path TO _pgpm;
    SELECT _find_schema(p_schema_name, p_v_req) AS version INTO l_pkg_version_wrapped;
    l_pkg_version := l_pkg_version_wrapped.version;

    l_search_path := l_pkg_version.pkg_name || '_' ||
                     l_pkg_version.pkg_v_major::text || '_' ||
                     l_pkg_version.pkg_v_minor::text || '_' ||
                     l_pkg_version.pkg_v_patch::text;

    SELECT string_agg(pkg_name || '_' || pkg_v_major || '_' || pkg_v_minor || '_' || pkg_v_patch, ', ')
    FROM packages
    WHERE pkg_id IN (
        SELECT pkg_link_dep_id from package_dependencies
        JOIN packages ON pkg_id = l_pkg_version.pkg_id
        WHERE pkg_link_core_id = pkg_id
    )
    INTO l_search_path_deps;

    l_search_path := l_search_path || ', ' || l_search_path_deps;

    l_listen_text := 'deployment_events' || '$$' || l_pkg_version.pkg_name;
    EXECUTE 'LISTEN ' || l_listen_text;

    RAISE INFO '%', l_search_path;
    PERFORM set_config('search_path', l_search_path || ', public', false);

    return_value := row_to_json(l_pkg_version);
    RETURN return_value;

END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-11 11:57:49,250 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _find_schema(p_schema_name TEXT, p_v_req TEXT)
    RETURNS RECORD AS
$BODY$
---
-- @description
-- Searches for existing schema (package) within registered packages in _pgpm schema
--
-- @param p_schema_name
-- Package (schema) name
--
-- @param p_v_req
-- Package version requirement. Version notation supports:
-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)
-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x
-- - comparison operators like >01_02_03 or <2
-- - x for any latest version of package
-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency
--
-- @returns
-- Record containing schema name and exact version or exception if not found in the following format:
-- pkg_name TEXT, pkg_v_major INTEGER, pkg_v_minor INTEGER, pkg_v_patch INTEGER
---
DECLARE
    c_re_version TEXT = '^(<=|>=|<|>{0,2})(\d*|x*)_?(\d*|x*)_?(\d*|x*)';
    l_v_matches TEXT[];

    l_v_major INTEGER;
    l_v_minor INTEGER;
    l_v_patch INTEGER;

    return_value RECORD;
BEGIN

    SELECT regexp_matches(p_v_req, c_re_version, 'gi') INTO l_v_matches;

    IF l_v_matches[2] ~* '^x+|^$' THEN
        SELECT max(pkg_v_major)
        FROM packages
        WHERE pkg_name = p_schema_name
        INTO l_v_major;
    ELSE
        l_v_major := l_v_matches[2]::integer;
    END IF;

    IF l_v_matches[3] ~* '^x+|^$' THEN
        SELECT max(pkg_v_minor)
        FROM packages
        WHERE pkg_name = p_schema_name
              AND pkg_v_major = l_v_major
        INTO l_v_minor;
    ELSE
        l_v_minor := l_v_matches[3]::integer;
    END IF;

    IF l_v_matches[4] ~* '^x+|^$' THEN
        SELECT max(pkg_v_patch)
        FROM packages
        WHERE pkg_name = p_schema_name
              AND pkg_v_major = l_v_major
              AND pkg_v_minor = l_v_minor
        INTO l_v_patch;
    ELSE
        l_v_patch := l_v_matches[4]::integer;
    END IF;

    CASE l_v_matches[1]
        WHEN '=', '' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND pkg_v_major = l_v_major
                  AND pkg_v_minor = l_v_minor
                  AND pkg_v_patch = l_v_patch
            INTO return_value;
        WHEN '<' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major < l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor < l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch < l_v_patch))
            INTO return_value;
        WHEN '>' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major > l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor > l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch > l_v_patch))
            INTO return_value;
        WHEN '<=' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major <= l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor <= l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch <= l_v_patch))
            INTO return_value;
        WHEN '>=' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major >= l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor >= l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch >= l_v_patch))
            INTO return_value;
        ELSE
            RAISE EXCEPTION 'Invalid logical operand. Only <, >, =, <=, >=, = or no operand are allowed.' USING ERRCODE = '20000';
    END CASE;

    RETURN return_value;

END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-11 11:57:49,260 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _upsert_package_info(p_pkg_name TEXT,
                                             p_pkg_subclass_name TEXT,
                                             p_pkg_v_major INTEGER,
                                             p_pkg_v_minor INTEGER DEFAULT 0,
                                             p_pkg_v_patch INTEGER DEFAULT 0,
                                             p_pkg_v_pre TEXT DEFAULT NULL,
                                             p_pkg_v_metadata TEXT DEFAULT NULL,
                                             p_pkg_description TEXT DEFAULT '',
                                             p_pkg_license TEXT DEFAULT NULL,
                                             p_pkg_deps_ids INTEGER[] DEFAULT '{}',
                                             p_pkg_vcs_ref TEXT DEFAULT NULL,
                                             p_pkg_vcs_link TEXT DEFAULT NULL,
                                             p_pkg_issue_ref TEXT DEFAULT NULL,
                                             p_pkg_issue_link TEXT DEFAULT NULL)
    RETURNS INTEGER AS
$BODY$
---
-- @description
-- Adds package info to pgpm package info table, deployment events table and notifies channels of deployment
--
-- @param p_pkg_name
-- package name
--
-- @param p_pkg_subclass_name
-- package type: either version (with version suffix at the end of the name) or basic (without)
--
-- @param p_pkg_description
-- package description
--
-- @param p_pkg_v_major
-- package major part of version (according to semver)
--
-- @param p_pkg_v_minor
-- package minor part of version (according to semver)
--
-- @param p_pkg_v_patch
-- package patch part of version (according to semver)
--
-- @param p_pkg_v_pre
-- package pre part of version (according to semver)
--
-- @param p_pkg_v_metadata
-- package metadata part of version (according to semver)
--
-- @param p_pkg_license
-- package license name/text
--
-- @param p_pkg_deps_ids
-- IDs of dependent schemas
--
-- @param p_pkg_vcs_ref
-- vcs reference to track the code
--
-- @param p_pkg_vcs_link
-- repository link to track the code
--
-- @param p_pkg_issue_ref
-- issue reference to track the code
--
-- @param p_pkg_issue_link
-- issue tracking system link
---
DECLARE
    l_existing_pkg_id INTEGER;
    l_pkg_dep_id INTEGER;

	return_value INTEGER;
BEGIN

    -- Case 1: unsafe mode, rewrite of the whole schema with the same version or some of the files in it
    -- Case 2: new schema with new version (safe or moderate modes)

    IF p_pkg_subclass_name = 'basic' THEN
        SELECT pkg_id INTO l_existing_pkg_id
        FROM packages
        WHERE pkg_name = p_pkg_name
            AND pkg_subclass IN (SELECT pkg_sc_id
                                 FROM package_subclasses
                                 WHERE pkg_sc_name = p_pkg_subclass_name);
    ELSE
        SELECT pkg_id INTO l_existing_pkg_id
        FROM packages
        WHERE pkg_name = p_pkg_name
            AND pkg_subclass IN (SELECT pkg_sc_id
                                 FROM package_subclasses
                                 WHERE pkg_sc_name = p_pkg_subclass_name)
            AND pkg_v_major = p_pkg_v_major
            AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)
            AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)
            AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre)
            AND pkg_old_rev IS NULL;
    END IF;

    IF FOUND THEN -- Case 1:
        DELETE FROM package_dependencies
            WHERE pkg_link_core_id = l_existing_pkg_id;

        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids
        LOOP
            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (l_existing_pkg_id, l_pkg_dep_id);
        END LOOP;

        UPDATE packages
        SET pkg_name=subquery.p_pkg_name,
            pkg_subclass=subquery.pkg_sc_id,
            pkg_v_major=subquery.p_pkg_v_major,
            pkg_v_minor=subquery.p_pkg_v_minor,
            pkg_v_patch=subquery.p_pkg_v_patch,
            pkg_v_pre=subquery.p_pkg_v_pre,
            pkg_v_metadata=subquery.p_pkg_v_metadata,
            pkg_description=subquery.p_pkg_description,
            pkg_license=subquery.p_pkg_license
        FROM (SELECT
                  p_pkg_name,
                  pkg_sc_id,
                  p_pkg_v_major,
                  p_pkg_v_minor,
                  p_pkg_v_patch,
                  p_pkg_v_pre,
                  p_pkg_v_metadata,
                  p_pkg_description,
                  p_pkg_license
              FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name
        ) as subquery
        WHERE packages.pkg_name=subquery.p_pkg_name;

        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)
            VALUES (l_existing_pkg_id, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);

        return_value := l_existing_pkg_id;
    ELSE -- Case 2:
        INSERT INTO packages (
            pkg_name,
            pkg_description,
            pkg_v_major,
            pkg_v_minor,
            pkg_v_patch,
            pkg_v_pre,
            pkg_v_metadata,
            pkg_subclass,
            pkg_license
        )
        SELECT
            p_pkg_name,
            p_pkg_description,
            p_pkg_v_major,
            p_pkg_v_minor,
            p_pkg_v_patch,
            p_pkg_v_pre,
            p_pkg_v_metadata,
            pkg_sc_id,
            p_pkg_license
        FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name
        RETURNING
            pkg_id
        INTO return_value;

        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids
        LOOP
            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (return_value, l_pkg_dep_id);
        END LOOP;

        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)
            VALUES (return_value, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);

    END IF;

    -- Notify external channels of successful deployment event
    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);

    RETURN return_value;
END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-11 11:57:49,274 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _alter_schema_owner(p_schema TEXT, p_owner TEXT)
    RETURNS VOID AS
$BODY$
---
-- @description
-- Alters ownership of schema and all its objects to a specified user.
--
-- @param p_schema
-- Schema name
--
-- @param p_owner
-- New owner user name
--
---
DECLARE
    l_schema TEXT;
    l_functions TEXT;
    l_tables TEXT;
    l_sequences TEXT;
    l_views TEXT;
    l_domains TEXT;
    l_triggers TEXT;
    l_types TEXT;

BEGIN

    l_schema := 'ALTER SCHEMA '
                || quote_ident(p_schema)
                || ' OWNER TO '
                || quote_ident(p_owner)
                || ';';

    SELECT string_agg('ALTER FUNCTION '
                || quote_ident(n.nspname) || '.'
                || quote_ident(p.proname) || '('
                || pg_catalog.pg_get_function_identity_arguments(p.oid)
                || ') OWNER TO ' || p_owner || ';'
              , E'\n') AS _sql
    FROM   pg_catalog.pg_proc p
    JOIN   pg_catalog.pg_namespace n ON n.oid = p.pronamespace
    WHERE  n.nspname = p_schema
    INTO l_functions;
    IF l_functions IS NULL THEN
        l_functions := '';
    END IF;

    SELECT string_agg('ALTER TABLE ' || quote_ident(schemaname) || '.' || quote_ident(tablename) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM pg_tables WHERE schemaname = p_schema
    INTO l_tables;
    IF l_tables IS NULL THEN
        l_tables := '';
    END IF;

    SELECT string_agg('ALTER SEQUENCE ' || quote_ident(sequence_schema) || '.' || quote_ident(sequence_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.sequences WHERE sequence_schema = p_schema
    INTO l_sequences;
    IF l_sequences IS NULL THEN
        l_sequences := '';
    END IF;

    SELECT string_agg('ALTER VIEW ' || quote_ident(table_schema) || '.' || quote_ident(table_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.views WHERE table_schema = p_schema
    INTO l_views;
    IF l_views IS NULL THEN
        l_views := '';
    END IF;

    SELECT string_agg('ALTER DOMAIN ' || quote_ident(domain_schema) || '.' || quote_ident(domain_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.domains WHERE domain_schema = p_schema
    INTO l_domains;
    IF l_domains IS NULL THEN
        l_domains := '';
    END IF;

    SELECT string_agg('ALTER TRIGGER ' || quote_ident(trigger_schema) || '.' || quote_ident(trigger_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.triggers WHERE trigger_schema = p_schema
    INTO l_triggers;
    IF l_triggers IS NULL THEN
        l_triggers := '';
    END IF;

    SELECT string_agg('ALTER TYPE ' || quote_ident(user_defined_type_schema) || '.' || quote_ident(user_defined_type_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.user_defined_types WHERE user_defined_type_schema = p_schema
    INTO l_types;
    IF l_types IS NULL THEN
        l_types := '';
    END IF;

    EXECUTE l_schema || l_functions || l_tables || l_sequences || l_views || l_domains || l_triggers || l_types;

END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;
2015-12-11 11:57:49,286 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _log_table_evolution(p_t_evo_file_name TEXT, p_t_evo_package INTEGER)
    RETURNS VOID AS
$BODY$
---
-- @description
-- Adds information about executed table evolution script to log table
--
-- @param p_t_evo_file_name
-- File name with executed statements.
--
-- @param p_t_evo_package
-- Related package id
--
-- @param p_pkg_old_rev
-- higher border of version that is applicaple for this migration
--
---
BEGIN

    INSERT INTO table_evolutions_log (t_evo_file_name, t_evo_package)
        VALUES (p_t_evo_file_name, p_t_evo_package);
END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;
2015-12-11 11:57:49,299 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _is_table_ddl_executed(p_file_name TEXT)
    RETURNS BOOLEAN AS
$BODY$
---
-- @description
-- Checks whether file with table ddl has already been executed
--
-- @param p_file_name
-- File name used to check whether statements were executed
--
-- @returns
-- True if executed, False otherwise
---
DECLARE
    return_value BOOLEAN;
BEGIN

    SELECT EXISTS (SELECT t_evo_id FROM table_evolutions_log WHERE t_evo_file_name=p_file_name) INTO return_value;

    RETURN return_value;

END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-11 11:57:49,314 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _set_revision_package(p_pkg_name TEXT,
                                             p_pkg_subclass_name TEXT,
                                             p_pkg_old_rev INTEGER,
                                             p_pkg_v_major INTEGER,
                                             p_pkg_v_minor INTEGER DEFAULT 0,
                                             p_pkg_v_patch INTEGER DEFAULT 0,
                                             p_pkg_v_pre TEXT DEFAULT NULL)
    RETURNS INTEGER AS
$BODY$
---
-- @description
-- Set package as old revision, info logged in deployment events table
--
-- @param p_pkg_name
-- package name
--
-- @param p_pkg_subclass_name
-- package type: either version (with version suffix at the end of the name) or basic (without)
--
-- @param p_pkg_old_rev
-- Revision name of package. Used in moderate form. When schema is renamed it is given a revision suffix from here
--
-- @param p_pkg_v_major
-- package major part of version (according to semver)
--
-- @param p_pkg_v_minor
-- package minor part of version (according to semver)
--
-- @param p_pkg_v_patch
-- package patch part of version (according to semver)
--
-- @param p_pkg_v_pre
-- package pre part of version (according to semver)
--
-- @param p_pkg_v_metadata
-- package metadata part of version (according to semver)
--
-- @param p_pkg_vcs_ref
-- vcs reference to track the code
---
DECLARE
    l_existing_pkg_id INTEGER;
    l_pkg_dep_id INTEGER;

	return_value INTEGER;
BEGIN

    SELECT pkg_id INTO l_existing_pkg_id
    FROM packages
    WHERE pkg_name = p_pkg_name
        AND pkg_subclass IN (SELECT pkg_sc_id
                             FROM package_subclasses
                             WHERE pkg_sc_name = p_pkg_subclass_name)
        AND pkg_v_major = p_pkg_v_major
        AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)
        AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)
        AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre);

    IF FOUND THEN
        UPDATE packages
        SET pkg_old_rev=p_pkg_old_rev
        WHERE packages.pkg_id=l_existing_pkg_id;

        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)
            SELECT pkg_id, txid_current(), dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link
            FROM packages
            JOIN deployment_events ON dpl_ev_pkg_id=pkg_id
            WHERE pkg_id=l_existing_pkg_id AND dpl_ev_time IN (
                SELECT max(dpl_ev_time) FROM deployment_events WHERE dpl_ev_pkg_id=packages.pkg_id
            );
    ELSE
        RAISE EXCEPTION 'Package % not found in the list of packages. It could happen if schema exists but wasn''t properly deployed with pgpm', p_pkg_name || '_' || p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch;
    END IF;

    -- Notify external channels of successful deployment event
    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);

    RETURN return_value;
END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-11 11:57:49,314 - pgpm.app - DEBUG - Functions loaded to schema _pgpm
2015-12-11 11:57:49,325 - pgpm.app - DEBUG - Executing query: set search_path TO _pgpm, public;
2015-12-11 11:57:49,334 - pgpm.app - DEBUG - Executing query: SELECT _find_schema('_pgpm', 'x')
2015-12-11 11:57:49,335 - pgpm.app - DEBUG - No user was specified to have permisions on _pgpm schema. This means only user that installed _pgpm will be able to deploy. We recommend adding more users.
2015-12-11 11:57:49,337 - pgpm.app - DEBUG - Executing query: set search_path TO _pgpm, public;
2015-12-11 11:57:49,346 - pgpm.app - DEBUG - Calling stored procedure: SELECT * FROM _upsert_package_info('_pgpm','basic','0','1','48',NULL,NULL,'Package manager for Postgres','MIT')
2015-12-11 11:57:49,349 - pgpm.app - DEBUG - Closing connection to host=devel-db2.affinitas.de port=6223 dbname=de_live_devel_db user=apanchoyan password=xxxxxxxxxxx...
2015-12-11 11:57:49,349 - pgpm.app - DEBUG - Connection to host=devel-db2.affinitas.de port=6223 dbname=de_live_devel_db user=apanchoyan password=xxxxxxxxxxx closed.
2015-12-11 11:57:49,349 - pgpm.app - INFO - Successfully installed host=devel-db2.affinitas.de port=6223 dbname=de_live_devel_db user=apanchoyan password=snojpoksIb6
2015-12-11 11:58:57,080 - pgpm.app - INFO - Installing... host=devel-db2.affinitas.de port=6223 dbname=de_live_devel_db user=apanchoyan password=snojpoksIb6
2015-12-11 11:58:57,155 - pgpm.app - DEBUG - lib/db_scripts/functions/_add_migration_info.sql
2015-12-11 11:58:57,155 - pgpm.app - DEBUG - lib/db_scripts/functions/_alter_schema_owner.sql
2015-12-11 11:58:57,155 - pgpm.app - DEBUG - lib/db_scripts/functions/_find_schema.sql
2015-12-11 11:58:57,155 - pgpm.app - DEBUG - lib/db_scripts/functions/_is_table_ddl_executed.sql
2015-12-11 11:58:57,156 - pgpm.app - DEBUG - lib/db_scripts/functions/_log_ddl_change.sql
2015-12-11 11:58:57,156 - pgpm.app - DEBUG - lib/db_scripts/functions/_log_table_evolution.sql
2015-12-11 11:58:57,156 - pgpm.app - DEBUG - lib/db_scripts/functions/_set_revision_package.sql
2015-12-11 11:58:57,156 - pgpm.app - DEBUG - lib/db_scripts/functions/_upsert_package_info.sql
2015-12-11 11:58:57,156 - pgpm.app - DEBUG - lib/db_scripts/functions/set_search_path.sql
2015-12-11 11:58:57,199 - pgpm.app - DEBUG - Executing query: select * from CURRENT_USER;
2015-12-11 11:58:57,223 - pgpm.app - DEBUG - Executing query: select usesuper from pg_user where usename = CURRENT_USER;
2015-12-11 11:58:57,244 - pgpm.app - DEBUG - Executing query: SELECT EXISTS (SELECT schema_name FROM information_schema.schemata WHERE schema_name = '_pgpm');
2015-12-11 11:58:57,245 - pgpm.app - INFO - Running functions definitions scripts
2015-12-11 11:58:57,245 - pgpm.app - DEBUG - {'_log_ddl_change.sql': u'CREATE OR REPLACE FUNCTION _log_ddl_change()\n    RETURNS EVENT_TRIGGER AS\n$BODY$\n---\n-- @description\n-- Logs any DDL changes to the DB\n--\n---\nDECLARE\n    l_current_query TEXT;\n    l_txid BIGINT;\nBEGIN\n\n    SELECT current_query() INTO l_current_query;\n    SELECT txid_current() INTO l_txid;\n    INSERT INTO _pgpm.ddl_changes_log (ddl_change)\n    SELECT l_current_query\n    WHERE\n        NOT EXISTS (\n            SELECT ddl_change_txid, ddl_change FROM _pgpm.ddl_changes_log\n            WHERE ddl_change_txid = l_txid AND ddl_change = l_current_query\n        );\n\n    -- Notify external channels of ddl change\n    PERFORM pg_notify(\'ddl_change\', "session_user"());\n\nEND;\n$BODY$\nLANGUAGE \'plpgsql\' VOLATILE SECURITY DEFINER;', '_add_migration_info.sql': u"CREATE OR REPLACE FUNCTION _add_migration_info(p_m_low_v TEXT, p_m_high_v TEXT)\n    RETURNS VOID AS\n$BODY$\n---\n-- @description\n-- Adds migration info migrations log table\n--\n-- @param p_m_low_v\n-- lower border of version that is applicaple for this migration\n--\n-- @param p_m_high_v\n-- package type: either version (with version suffix at the end of the name) or basic (without)\n--\n-- @param p_pkg_old_rev\n-- higher border of version that is applicaple for this migration\n--\n---\nBEGIN\n\n    BEGIN\n        INSERT INTO migrations_log (m_low_v, m_high_v)\n            VALUES (p_m_low_v, p_m_high_v);\n    EXCEPTION\n        WHEN SQLSTATE '42P01' THEN\n            RAISE WARNING 'Can''t log migration from % to % as migrations_log is not defined yet', p_m_low_v, p_m_high_v;\n    END;\nEND;\n$BODY$\nLANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", 'set_search_path.sql': u"CREATE OR REPLACE FUNCTION set_search_path(p_schema_name TEXT, p_v_req TEXT)\n    RETURNS json AS\n$BODY$\n---\n-- @description\n-- Sets search path that includes also all depending\n--\n-- @param p_schema_name\n-- Package (schema) name\n--\n-- @param p_v_req\n-- Package version requirement. Version notation supports:\n-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)\n-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x\n-- - comparison operators like >01_02_03 or <2\n-- - x for any latest version of package\n-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency\n--\n-- @returns\n-- JSON with schema names and exact versions or exception if not found\n---\nDECLARE\n    l_search_path TEXT;\n    l_search_path_deps TEXT;\n    l_listen_text TEXT;\n\n    l_pkg_version_wrapped RECORD;\n    l_pkg_version RECORD;\n\n    return_value json;\nBEGIN\n\n    SET search_path TO _pgpm;\n    SELECT _find_schema(p_schema_name, p_v_req) AS version INTO l_pkg_version_wrapped;\n    l_pkg_version := l_pkg_version_wrapped.version;\n\n    l_search_path := l_pkg_version.pkg_name || '_' ||\n                     l_pkg_version.pkg_v_major::text || '_' ||\n                     l_pkg_version.pkg_v_minor::text || '_' ||\n                     l_pkg_version.pkg_v_patch::text;\n\n    SELECT string_agg(pkg_name || '_' || pkg_v_major || '_' || pkg_v_minor || '_' || pkg_v_patch, ', ')\n    FROM packages\n    WHERE pkg_id IN (\n        SELECT pkg_link_dep_id from package_dependencies\n        JOIN packages ON pkg_id = l_pkg_version.pkg_id\n        WHERE pkg_link_core_id = pkg_id\n    )\n    INTO l_search_path_deps;\n\n    l_search_path := l_search_path || ', ' || l_search_path_deps;\n\n    l_listen_text := 'deployment_events' || '$$' || l_pkg_version.pkg_name;\n    EXECUTE 'LISTEN ' || l_listen_text;\n\n    RAISE INFO '%', l_search_path;\n    PERFORM set_config('search_path', l_search_path || ', public', false);\n\n    return_value := row_to_json(l_pkg_version);\n    RETURN return_value;\n\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_find_schema.sql': u"CREATE OR REPLACE FUNCTION _find_schema(p_schema_name TEXT, p_v_req TEXT)\n    RETURNS RECORD AS\n$BODY$\n---\n-- @description\n-- Searches for existing schema (package) within registered packages in _pgpm schema\n--\n-- @param p_schema_name\n-- Package (schema) name\n--\n-- @param p_v_req\n-- Package version requirement. Version notation supports:\n-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)\n-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x\n-- - comparison operators like >01_02_03 or <2\n-- - x for any latest version of package\n-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency\n--\n-- @returns\n-- Record containing schema name and exact version or exception if not found in the following format:\n-- pkg_name TEXT, pkg_v_major INTEGER, pkg_v_minor INTEGER, pkg_v_patch INTEGER\n---\nDECLARE\n    c_re_version TEXT = '^(<=|>=|<|>{0,2})(\\d*|x*)_?(\\d*|x*)_?(\\d*|x*)';\n    l_v_matches TEXT[];\n\n    l_v_major INTEGER;\n    l_v_minor INTEGER;\n    l_v_patch INTEGER;\n\n    return_value RECORD;\nBEGIN\n\n    SELECT regexp_matches(p_v_req, c_re_version, 'gi') INTO l_v_matches;\n\n    IF l_v_matches[2] ~* '^x+|^$' THEN\n        SELECT max(pkg_v_major)\n        FROM packages\n        WHERE pkg_name = p_schema_name\n        INTO l_v_major;\n    ELSE\n        l_v_major := l_v_matches[2]::integer;\n    END IF;\n\n    IF l_v_matches[3] ~* '^x+|^$' THEN\n        SELECT max(pkg_v_minor)\n        FROM packages\n        WHERE pkg_name = p_schema_name\n              AND pkg_v_major = l_v_major\n        INTO l_v_minor;\n    ELSE\n        l_v_minor := l_v_matches[3]::integer;\n    END IF;\n\n    IF l_v_matches[4] ~* '^x+|^$' THEN\n        SELECT max(pkg_v_patch)\n        FROM packages\n        WHERE pkg_name = p_schema_name\n              AND pkg_v_major = l_v_major\n              AND pkg_v_minor = l_v_minor\n        INTO l_v_patch;\n    ELSE\n        l_v_patch := l_v_matches[4]::integer;\n    END IF;\n\n    CASE l_v_matches[1]\n        WHEN '=', '' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND pkg_v_major = l_v_major\n                  AND pkg_v_minor = l_v_minor\n                  AND pkg_v_patch = l_v_patch\n            INTO return_value;\n        WHEN '<' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major < l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor < l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch < l_v_patch))\n            INTO return_value;\n        WHEN '>' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major > l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor > l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch > l_v_patch))\n            INTO return_value;\n        WHEN '<=' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major <= l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor <= l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch <= l_v_patch))\n            INTO return_value;\n        WHEN '>=' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major >= l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor >= l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch >= l_v_patch))\n            INTO return_value;\n        ELSE\n            RAISE EXCEPTION 'Invalid logical operand. Only <, >, =, <=, >=, = or no operand are allowed.' USING ERRCODE = '20000';\n    END CASE;\n\n    RETURN return_value;\n\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_upsert_package_info.sql': u"CREATE OR REPLACE FUNCTION _upsert_package_info(p_pkg_name TEXT,\n                                             p_pkg_subclass_name TEXT,\n                                             p_pkg_v_major INTEGER,\n                                             p_pkg_v_minor INTEGER DEFAULT 0,\n                                             p_pkg_v_patch INTEGER DEFAULT 0,\n                                             p_pkg_v_pre TEXT DEFAULT NULL,\n                                             p_pkg_v_metadata TEXT DEFAULT NULL,\n                                             p_pkg_description TEXT DEFAULT '',\n                                             p_pkg_license TEXT DEFAULT NULL,\n                                             p_pkg_deps_ids INTEGER[] DEFAULT '{}',\n                                             p_pkg_vcs_ref TEXT DEFAULT NULL,\n                                             p_pkg_vcs_link TEXT DEFAULT NULL,\n                                             p_pkg_issue_ref TEXT DEFAULT NULL,\n                                             p_pkg_issue_link TEXT DEFAULT NULL)\n    RETURNS INTEGER AS\n$BODY$\n---\n-- @description\n-- Adds package info to pgpm package info table, deployment events table and notifies channels of deployment\n--\n-- @param p_pkg_name\n-- package name\n--\n-- @param p_pkg_subclass_name\n-- package type: either version (with version suffix at the end of the name) or basic (without)\n--\n-- @param p_pkg_description\n-- package description\n--\n-- @param p_pkg_v_major\n-- package major part of version (according to semver)\n--\n-- @param p_pkg_v_minor\n-- package minor part of version (according to semver)\n--\n-- @param p_pkg_v_patch\n-- package patch part of version (according to semver)\n--\n-- @param p_pkg_v_pre\n-- package pre part of version (according to semver)\n--\n-- @param p_pkg_v_metadata\n-- package metadata part of version (according to semver)\n--\n-- @param p_pkg_license\n-- package license name/text\n--\n-- @param p_pkg_deps_ids\n-- IDs of dependent schemas\n--\n-- @param p_pkg_vcs_ref\n-- vcs reference to track the code\n--\n-- @param p_pkg_vcs_link\n-- repository link to track the code\n--\n-- @param p_pkg_issue_ref\n-- issue reference to track the code\n--\n-- @param p_pkg_issue_link\n-- issue tracking system link\n---\nDECLARE\n    l_existing_pkg_id INTEGER;\n    l_pkg_dep_id INTEGER;\n\n\treturn_value INTEGER;\nBEGIN\n\n    -- Case 1: unsafe mode, rewrite of the whole schema with the same version or some of the files in it\n    -- Case 2: new schema with new version (safe or moderate modes)\n\n    IF p_pkg_subclass_name = 'basic' THEN\n        SELECT pkg_id INTO l_existing_pkg_id\n        FROM packages\n        WHERE pkg_name = p_pkg_name\n            AND pkg_subclass IN (SELECT pkg_sc_id\n                                 FROM package_subclasses\n                                 WHERE pkg_sc_name = p_pkg_subclass_name);\n    ELSE\n        SELECT pkg_id INTO l_existing_pkg_id\n        FROM packages\n        WHERE pkg_name = p_pkg_name\n            AND pkg_subclass IN (SELECT pkg_sc_id\n                                 FROM package_subclasses\n                                 WHERE pkg_sc_name = p_pkg_subclass_name)\n            AND pkg_v_major = p_pkg_v_major\n            AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)\n            AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)\n            AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre)\n            AND pkg_old_rev IS NULL;\n    END IF;\n\n    IF FOUND THEN -- Case 1:\n        DELETE FROM package_dependencies\n            WHERE pkg_link_core_id = l_existing_pkg_id;\n\n        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids\n        LOOP\n            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (l_existing_pkg_id, l_pkg_dep_id);\n        END LOOP;\n\n        UPDATE packages\n        SET pkg_name=subquery.p_pkg_name,\n            pkg_subclass=subquery.pkg_sc_id,\n            pkg_v_major=subquery.p_pkg_v_major,\n            pkg_v_minor=subquery.p_pkg_v_minor,\n            pkg_v_patch=subquery.p_pkg_v_patch,\n            pkg_v_pre=subquery.p_pkg_v_pre,\n            pkg_v_metadata=subquery.p_pkg_v_metadata,\n            pkg_description=subquery.p_pkg_description,\n            pkg_license=subquery.p_pkg_license\n        FROM (SELECT\n                  p_pkg_name,\n                  pkg_sc_id,\n                  p_pkg_v_major,\n                  p_pkg_v_minor,\n                  p_pkg_v_patch,\n                  p_pkg_v_pre,\n                  p_pkg_v_metadata,\n                  p_pkg_description,\n                  p_pkg_license\n              FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name\n        ) as subquery\n        WHERE packages.pkg_name=subquery.p_pkg_name;\n\n        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)\n            VALUES (l_existing_pkg_id, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);\n\n        return_value := l_existing_pkg_id;\n    ELSE -- Case 2:\n        INSERT INTO packages (\n            pkg_name,\n            pkg_description,\n            pkg_v_major,\n            pkg_v_minor,\n            pkg_v_patch,\n            pkg_v_pre,\n            pkg_v_metadata,\n            pkg_subclass,\n            pkg_license\n        )\n        SELECT\n            p_pkg_name,\n            p_pkg_description,\n            p_pkg_v_major,\n            p_pkg_v_minor,\n            p_pkg_v_patch,\n            p_pkg_v_pre,\n            p_pkg_v_metadata,\n            pkg_sc_id,\n            p_pkg_license\n        FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name\n        RETURNING\n            pkg_id\n        INTO return_value;\n\n        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids\n        LOOP\n            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (return_value, l_pkg_dep_id);\n        END LOOP;\n\n        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)\n            VALUES (return_value, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);\n\n    END IF;\n\n    -- Notify external channels of successful deployment event\n    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);\n\n    RETURN return_value;\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_alter_schema_owner.sql': u"CREATE OR REPLACE FUNCTION _alter_schema_owner(p_schema TEXT, p_owner TEXT)\n    RETURNS VOID AS\n$BODY$\n---\n-- @description\n-- Alters ownership of schema and all its objects to a specified user.\n--\n-- @param p_schema\n-- Schema name\n--\n-- @param p_owner\n-- New owner user name\n--\n---\nDECLARE\n    l_schema TEXT;\n    l_functions TEXT;\n    l_tables TEXT;\n    l_sequences TEXT;\n    l_views TEXT;\n    l_domains TEXT;\n    l_triggers TEXT;\n    l_types TEXT;\n\nBEGIN\n\n    l_schema := 'ALTER SCHEMA '\n                || quote_ident(p_schema)\n                || ' OWNER TO '\n                || quote_ident(p_owner)\n                || ';';\n\n    SELECT string_agg('ALTER FUNCTION '\n                || quote_ident(n.nspname) || '.'\n                || quote_ident(p.proname) || '('\n                || pg_catalog.pg_get_function_identity_arguments(p.oid)\n                || ') OWNER TO ' || p_owner || ';'\n              , E'\\n') AS _sql\n    FROM   pg_catalog.pg_proc p\n    JOIN   pg_catalog.pg_namespace n ON n.oid = p.pronamespace\n    WHERE  n.nspname = p_schema\n    INTO l_functions;\n    IF l_functions IS NULL THEN\n        l_functions := '';\n    END IF;\n\n    SELECT string_agg('ALTER TABLE ' || quote_ident(schemaname) || '.' || quote_ident(tablename) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM pg_tables WHERE schemaname = p_schema\n    INTO l_tables;\n    IF l_tables IS NULL THEN\n        l_tables := '';\n    END IF;\n\n    SELECT string_agg('ALTER SEQUENCE ' || quote_ident(sequence_schema) || '.' || quote_ident(sequence_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.sequences WHERE sequence_schema = p_schema\n    INTO l_sequences;\n    IF l_sequences IS NULL THEN\n        l_sequences := '';\n    END IF;\n\n    SELECT string_agg('ALTER VIEW ' || quote_ident(table_schema) || '.' || quote_ident(table_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.views WHERE table_schema = p_schema\n    INTO l_views;\n    IF l_views IS NULL THEN\n        l_views := '';\n    END IF;\n\n    SELECT string_agg('ALTER DOMAIN ' || quote_ident(domain_schema) || '.' || quote_ident(domain_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.domains WHERE domain_schema = p_schema\n    INTO l_domains;\n    IF l_domains IS NULL THEN\n        l_domains := '';\n    END IF;\n\n    SELECT string_agg('ALTER TRIGGER ' || quote_ident(trigger_schema) || '.' || quote_ident(trigger_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.triggers WHERE trigger_schema = p_schema\n    INTO l_triggers;\n    IF l_triggers IS NULL THEN\n        l_triggers := '';\n    END IF;\n\n    SELECT string_agg('ALTER TYPE ' || quote_ident(user_defined_type_schema) || '.' || quote_ident(user_defined_type_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.user_defined_types WHERE user_defined_type_schema = p_schema\n    INTO l_types;\n    IF l_types IS NULL THEN\n        l_types := '';\n    END IF;\n\n    EXECUTE l_schema || l_functions || l_tables || l_sequences || l_views || l_domains || l_triggers || l_types;\n\nEND;\n$BODY$\nLANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;", '_log_table_evolution.sql': u"CREATE OR REPLACE FUNCTION _log_table_evolution(p_t_evo_file_name TEXT, p_t_evo_package INTEGER)\n    RETURNS VOID AS\n$BODY$\n---\n-- @description\n-- Adds information about executed table evolution script to log table\n--\n-- @param p_t_evo_file_name\n-- File name with executed statements.\n--\n-- @param p_t_evo_package\n-- Related package id\n--\n-- @param p_pkg_old_rev\n-- higher border of version that is applicaple for this migration\n--\n---\nBEGIN\n\n    INSERT INTO table_evolutions_log (t_evo_file_name, t_evo_package)\n        VALUES (p_t_evo_file_name, p_t_evo_package);\nEND;\n$BODY$\nLANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;", '_is_table_ddl_executed.sql': u"CREATE OR REPLACE FUNCTION _is_table_ddl_executed(p_file_name TEXT)\n    RETURNS BOOLEAN AS\n$BODY$\n---\n-- @description\n-- Checks whether file with table ddl has already been executed\n--\n-- @param p_file_name\n-- File name used to check whether statements were executed\n--\n-- @returns\n-- True if executed, False otherwise\n---\nDECLARE\n    return_value BOOLEAN;\nBEGIN\n\n    SELECT EXISTS (SELECT t_evo_id FROM table_evolutions_log WHERE t_evo_file_name=p_file_name) INTO return_value;\n\n    RETURN return_value;\n\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_set_revision_package.sql': u"CREATE OR REPLACE FUNCTION _set_revision_package(p_pkg_name TEXT,\n                                             p_pkg_subclass_name TEXT,\n                                             p_pkg_old_rev INTEGER,\n                                             p_pkg_v_major INTEGER,\n                                             p_pkg_v_minor INTEGER DEFAULT 0,\n                                             p_pkg_v_patch INTEGER DEFAULT 0,\n                                             p_pkg_v_pre TEXT DEFAULT NULL)\n    RETURNS INTEGER AS\n$BODY$\n---\n-- @description\n-- Set package as old revision, info logged in deployment events table\n--\n-- @param p_pkg_name\n-- package name\n--\n-- @param p_pkg_subclass_name\n-- package type: either version (with version suffix at the end of the name) or basic (without)\n--\n-- @param p_pkg_old_rev\n-- Revision name of package. Used in moderate form. When schema is renamed it is given a revision suffix from here\n--\n-- @param p_pkg_v_major\n-- package major part of version (according to semver)\n--\n-- @param p_pkg_v_minor\n-- package minor part of version (according to semver)\n--\n-- @param p_pkg_v_patch\n-- package patch part of version (according to semver)\n--\n-- @param p_pkg_v_pre\n-- package pre part of version (according to semver)\n--\n-- @param p_pkg_v_metadata\n-- package metadata part of version (according to semver)\n--\n-- @param p_pkg_vcs_ref\n-- vcs reference to track the code\n---\nDECLARE\n    l_existing_pkg_id INTEGER;\n    l_pkg_dep_id INTEGER;\n\n\treturn_value INTEGER;\nBEGIN\n\n    SELECT pkg_id INTO l_existing_pkg_id\n    FROM packages\n    WHERE pkg_name = p_pkg_name\n        AND pkg_subclass IN (SELECT pkg_sc_id\n                             FROM package_subclasses\n                             WHERE pkg_sc_name = p_pkg_subclass_name)\n        AND pkg_v_major = p_pkg_v_major\n        AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)\n        AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)\n        AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre);\n\n    IF FOUND THEN\n        UPDATE packages\n        SET pkg_old_rev=p_pkg_old_rev\n        WHERE packages.pkg_id=l_existing_pkg_id;\n\n        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)\n            SELECT pkg_id, txid_current(), dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link\n            FROM packages\n            JOIN deployment_events ON dpl_ev_pkg_id=pkg_id\n            WHERE pkg_id=l_existing_pkg_id AND dpl_ev_time IN (\n                SELECT max(dpl_ev_time) FROM deployment_events WHERE dpl_ev_pkg_id=packages.pkg_id\n            );\n    ELSE\n        RAISE EXCEPTION 'Package % not found in the list of packages. It could happen if schema exists but wasn''t properly deployed with pgpm', p_pkg_name || '_' || p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch;\n    END IF;\n\n    -- Notify external channels of successful deployment event\n    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);\n\n    RETURN return_value;\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n"}
2015-12-11 11:58:57,264 - pgpm.app - DEBUG - Executing query: set search_path TO _pgpm, public;
2015-12-11 11:58:57,297 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _log_ddl_change()
    RETURNS EVENT_TRIGGER AS
$BODY$
---
-- @description
-- Logs any DDL changes to the DB
--
---
DECLARE
    l_current_query TEXT;
    l_txid BIGINT;
BEGIN

    SELECT current_query() INTO l_current_query;
    SELECT txid_current() INTO l_txid;
    INSERT INTO _pgpm.ddl_changes_log (ddl_change)
    SELECT l_current_query
    WHERE
        NOT EXISTS (
            SELECT ddl_change_txid, ddl_change FROM _pgpm.ddl_changes_log
            WHERE ddl_change_txid = l_txid AND ddl_change = l_current_query
        );

    -- Notify external channels of ddl change
    PERFORM pg_notify('ddl_change', "session_user"());

END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;
2015-12-11 11:58:57,309 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _add_migration_info(p_m_low_v TEXT, p_m_high_v TEXT)
    RETURNS VOID AS
$BODY$
---
-- @description
-- Adds migration info migrations log table
--
-- @param p_m_low_v
-- lower border of version that is applicaple for this migration
--
-- @param p_m_high_v
-- package type: either version (with version suffix at the end of the name) or basic (without)
--
-- @param p_pkg_old_rev
-- higher border of version that is applicaple for this migration
--
---
BEGIN

    BEGIN
        INSERT INTO migrations_log (m_low_v, m_high_v)
            VALUES (p_m_low_v, p_m_high_v);
    EXCEPTION
        WHEN SQLSTATE '42P01' THEN
            RAISE WARNING 'Can''t log migration from % to % as migrations_log is not defined yet', p_m_low_v, p_m_high_v;
    END;
END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-11 11:58:57,324 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION set_search_path(p_schema_name TEXT, p_v_req TEXT)
    RETURNS json AS
$BODY$
---
-- @description
-- Sets search path that includes also all depending
--
-- @param p_schema_name
-- Package (schema) name
--
-- @param p_v_req
-- Package version requirement. Version notation supports:
-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)
-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x
-- - comparison operators like >01_02_03 or <2
-- - x for any latest version of package
-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency
--
-- @returns
-- JSON with schema names and exact versions or exception if not found
---
DECLARE
    l_search_path TEXT;
    l_search_path_deps TEXT;
    l_listen_text TEXT;

    l_pkg_version_wrapped RECORD;
    l_pkg_version RECORD;

    return_value json;
BEGIN

    SET search_path TO _pgpm;
    SELECT _find_schema(p_schema_name, p_v_req) AS version INTO l_pkg_version_wrapped;
    l_pkg_version := l_pkg_version_wrapped.version;

    l_search_path := l_pkg_version.pkg_name || '_' ||
                     l_pkg_version.pkg_v_major::text || '_' ||
                     l_pkg_version.pkg_v_minor::text || '_' ||
                     l_pkg_version.pkg_v_patch::text;

    SELECT string_agg(pkg_name || '_' || pkg_v_major || '_' || pkg_v_minor || '_' || pkg_v_patch, ', ')
    FROM packages
    WHERE pkg_id IN (
        SELECT pkg_link_dep_id from package_dependencies
        JOIN packages ON pkg_id = l_pkg_version.pkg_id
        WHERE pkg_link_core_id = pkg_id
    )
    INTO l_search_path_deps;

    l_search_path := l_search_path || ', ' || l_search_path_deps;

    l_listen_text := 'deployment_events' || '$$' || l_pkg_version.pkg_name;
    EXECUTE 'LISTEN ' || l_listen_text;

    RAISE INFO '%', l_search_path;
    PERFORM set_config('search_path', l_search_path || ', public', false);

    return_value := row_to_json(l_pkg_version);
    RETURN return_value;

END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-11 11:58:57,339 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _find_schema(p_schema_name TEXT, p_v_req TEXT)
    RETURNS RECORD AS
$BODY$
---
-- @description
-- Searches for existing schema (package) within registered packages in _pgpm schema
--
-- @param p_schema_name
-- Package (schema) name
--
-- @param p_v_req
-- Package version requirement. Version notation supports:
-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)
-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x
-- - comparison operators like >01_02_03 or <2
-- - x for any latest version of package
-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency
--
-- @returns
-- Record containing schema name and exact version or exception if not found in the following format:
-- pkg_name TEXT, pkg_v_major INTEGER, pkg_v_minor INTEGER, pkg_v_patch INTEGER
---
DECLARE
    c_re_version TEXT = '^(<=|>=|<|>{0,2})(\d*|x*)_?(\d*|x*)_?(\d*|x*)';
    l_v_matches TEXT[];

    l_v_major INTEGER;
    l_v_minor INTEGER;
    l_v_patch INTEGER;

    return_value RECORD;
BEGIN

    SELECT regexp_matches(p_v_req, c_re_version, 'gi') INTO l_v_matches;

    IF l_v_matches[2] ~* '^x+|^$' THEN
        SELECT max(pkg_v_major)
        FROM packages
        WHERE pkg_name = p_schema_name
        INTO l_v_major;
    ELSE
        l_v_major := l_v_matches[2]::integer;
    END IF;

    IF l_v_matches[3] ~* '^x+|^$' THEN
        SELECT max(pkg_v_minor)
        FROM packages
        WHERE pkg_name = p_schema_name
              AND pkg_v_major = l_v_major
        INTO l_v_minor;
    ELSE
        l_v_minor := l_v_matches[3]::integer;
    END IF;

    IF l_v_matches[4] ~* '^x+|^$' THEN
        SELECT max(pkg_v_patch)
        FROM packages
        WHERE pkg_name = p_schema_name
              AND pkg_v_major = l_v_major
              AND pkg_v_minor = l_v_minor
        INTO l_v_patch;
    ELSE
        l_v_patch := l_v_matches[4]::integer;
    END IF;

    CASE l_v_matches[1]
        WHEN '=', '' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND pkg_v_major = l_v_major
                  AND pkg_v_minor = l_v_minor
                  AND pkg_v_patch = l_v_patch
            INTO return_value;
        WHEN '<' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major < l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor < l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch < l_v_patch))
            INTO return_value;
        WHEN '>' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major > l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor > l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch > l_v_patch))
            INTO return_value;
        WHEN '<=' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major <= l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor <= l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch <= l_v_patch))
            INTO return_value;
        WHEN '>=' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major >= l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor >= l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch >= l_v_patch))
            INTO return_value;
        ELSE
            RAISE EXCEPTION 'Invalid logical operand. Only <, >, =, <=, >=, = or no operand are allowed.' USING ERRCODE = '20000';
    END CASE;

    RETURN return_value;

END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-11 11:58:57,350 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _upsert_package_info(p_pkg_name TEXT,
                                             p_pkg_subclass_name TEXT,
                                             p_pkg_v_major INTEGER,
                                             p_pkg_v_minor INTEGER DEFAULT 0,
                                             p_pkg_v_patch INTEGER DEFAULT 0,
                                             p_pkg_v_pre TEXT DEFAULT NULL,
                                             p_pkg_v_metadata TEXT DEFAULT NULL,
                                             p_pkg_description TEXT DEFAULT '',
                                             p_pkg_license TEXT DEFAULT NULL,
                                             p_pkg_deps_ids INTEGER[] DEFAULT '{}',
                                             p_pkg_vcs_ref TEXT DEFAULT NULL,
                                             p_pkg_vcs_link TEXT DEFAULT NULL,
                                             p_pkg_issue_ref TEXT DEFAULT NULL,
                                             p_pkg_issue_link TEXT DEFAULT NULL)
    RETURNS INTEGER AS
$BODY$
---
-- @description
-- Adds package info to pgpm package info table, deployment events table and notifies channels of deployment
--
-- @param p_pkg_name
-- package name
--
-- @param p_pkg_subclass_name
-- package type: either version (with version suffix at the end of the name) or basic (without)
--
-- @param p_pkg_description
-- package description
--
-- @param p_pkg_v_major
-- package major part of version (according to semver)
--
-- @param p_pkg_v_minor
-- package minor part of version (according to semver)
--
-- @param p_pkg_v_patch
-- package patch part of version (according to semver)
--
-- @param p_pkg_v_pre
-- package pre part of version (according to semver)
--
-- @param p_pkg_v_metadata
-- package metadata part of version (according to semver)
--
-- @param p_pkg_license
-- package license name/text
--
-- @param p_pkg_deps_ids
-- IDs of dependent schemas
--
-- @param p_pkg_vcs_ref
-- vcs reference to track the code
--
-- @param p_pkg_vcs_link
-- repository link to track the code
--
-- @param p_pkg_issue_ref
-- issue reference to track the code
--
-- @param p_pkg_issue_link
-- issue tracking system link
---
DECLARE
    l_existing_pkg_id INTEGER;
    l_pkg_dep_id INTEGER;

	return_value INTEGER;
BEGIN

    -- Case 1: unsafe mode, rewrite of the whole schema with the same version or some of the files in it
    -- Case 2: new schema with new version (safe or moderate modes)

    IF p_pkg_subclass_name = 'basic' THEN
        SELECT pkg_id INTO l_existing_pkg_id
        FROM packages
        WHERE pkg_name = p_pkg_name
            AND pkg_subclass IN (SELECT pkg_sc_id
                                 FROM package_subclasses
                                 WHERE pkg_sc_name = p_pkg_subclass_name);
    ELSE
        SELECT pkg_id INTO l_existing_pkg_id
        FROM packages
        WHERE pkg_name = p_pkg_name
            AND pkg_subclass IN (SELECT pkg_sc_id
                                 FROM package_subclasses
                                 WHERE pkg_sc_name = p_pkg_subclass_name)
            AND pkg_v_major = p_pkg_v_major
            AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)
            AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)
            AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre)
            AND pkg_old_rev IS NULL;
    END IF;

    IF FOUND THEN -- Case 1:
        DELETE FROM package_dependencies
            WHERE pkg_link_core_id = l_existing_pkg_id;

        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids
        LOOP
            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (l_existing_pkg_id, l_pkg_dep_id);
        END LOOP;

        UPDATE packages
        SET pkg_name=subquery.p_pkg_name,
            pkg_subclass=subquery.pkg_sc_id,
            pkg_v_major=subquery.p_pkg_v_major,
            pkg_v_minor=subquery.p_pkg_v_minor,
            pkg_v_patch=subquery.p_pkg_v_patch,
            pkg_v_pre=subquery.p_pkg_v_pre,
            pkg_v_metadata=subquery.p_pkg_v_metadata,
            pkg_description=subquery.p_pkg_description,
            pkg_license=subquery.p_pkg_license
        FROM (SELECT
                  p_pkg_name,
                  pkg_sc_id,
                  p_pkg_v_major,
                  p_pkg_v_minor,
                  p_pkg_v_patch,
                  p_pkg_v_pre,
                  p_pkg_v_metadata,
                  p_pkg_description,
                  p_pkg_license
              FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name
        ) as subquery
        WHERE packages.pkg_name=subquery.p_pkg_name;

        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)
            VALUES (l_existing_pkg_id, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);

        return_value := l_existing_pkg_id;
    ELSE -- Case 2:
        INSERT INTO packages (
            pkg_name,
            pkg_description,
            pkg_v_major,
            pkg_v_minor,
            pkg_v_patch,
            pkg_v_pre,
            pkg_v_metadata,
            pkg_subclass,
            pkg_license
        )
        SELECT
            p_pkg_name,
            p_pkg_description,
            p_pkg_v_major,
            p_pkg_v_minor,
            p_pkg_v_patch,
            p_pkg_v_pre,
            p_pkg_v_metadata,
            pkg_sc_id,
            p_pkg_license
        FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name
        RETURNING
            pkg_id
        INTO return_value;

        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids
        LOOP
            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (return_value, l_pkg_dep_id);
        END LOOP;

        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)
            VALUES (return_value, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);

    END IF;

    -- Notify external channels of successful deployment event
    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);

    RETURN return_value;
END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-11 11:58:57,364 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _alter_schema_owner(p_schema TEXT, p_owner TEXT)
    RETURNS VOID AS
$BODY$
---
-- @description
-- Alters ownership of schema and all its objects to a specified user.
--
-- @param p_schema
-- Schema name
--
-- @param p_owner
-- New owner user name
--
---
DECLARE
    l_schema TEXT;
    l_functions TEXT;
    l_tables TEXT;
    l_sequences TEXT;
    l_views TEXT;
    l_domains TEXT;
    l_triggers TEXT;
    l_types TEXT;

BEGIN

    l_schema := 'ALTER SCHEMA '
                || quote_ident(p_schema)
                || ' OWNER TO '
                || quote_ident(p_owner)
                || ';';

    SELECT string_agg('ALTER FUNCTION '
                || quote_ident(n.nspname) || '.'
                || quote_ident(p.proname) || '('
                || pg_catalog.pg_get_function_identity_arguments(p.oid)
                || ') OWNER TO ' || p_owner || ';'
              , E'\n') AS _sql
    FROM   pg_catalog.pg_proc p
    JOIN   pg_catalog.pg_namespace n ON n.oid = p.pronamespace
    WHERE  n.nspname = p_schema
    INTO l_functions;
    IF l_functions IS NULL THEN
        l_functions := '';
    END IF;

    SELECT string_agg('ALTER TABLE ' || quote_ident(schemaname) || '.' || quote_ident(tablename) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM pg_tables WHERE schemaname = p_schema
    INTO l_tables;
    IF l_tables IS NULL THEN
        l_tables := '';
    END IF;

    SELECT string_agg('ALTER SEQUENCE ' || quote_ident(sequence_schema) || '.' || quote_ident(sequence_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.sequences WHERE sequence_schema = p_schema
    INTO l_sequences;
    IF l_sequences IS NULL THEN
        l_sequences := '';
    END IF;

    SELECT string_agg('ALTER VIEW ' || quote_ident(table_schema) || '.' || quote_ident(table_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.views WHERE table_schema = p_schema
    INTO l_views;
    IF l_views IS NULL THEN
        l_views := '';
    END IF;

    SELECT string_agg('ALTER DOMAIN ' || quote_ident(domain_schema) || '.' || quote_ident(domain_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.domains WHERE domain_schema = p_schema
    INTO l_domains;
    IF l_domains IS NULL THEN
        l_domains := '';
    END IF;

    SELECT string_agg('ALTER TRIGGER ' || quote_ident(trigger_schema) || '.' || quote_ident(trigger_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.triggers WHERE trigger_schema = p_schema
    INTO l_triggers;
    IF l_triggers IS NULL THEN
        l_triggers := '';
    END IF;

    SELECT string_agg('ALTER TYPE ' || quote_ident(user_defined_type_schema) || '.' || quote_ident(user_defined_type_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.user_defined_types WHERE user_defined_type_schema = p_schema
    INTO l_types;
    IF l_types IS NULL THEN
        l_types := '';
    END IF;

    EXECUTE l_schema || l_functions || l_tables || l_sequences || l_views || l_domains || l_triggers || l_types;

END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;
2015-12-11 11:58:57,372 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _log_table_evolution(p_t_evo_file_name TEXT, p_t_evo_package INTEGER)
    RETURNS VOID AS
$BODY$
---
-- @description
-- Adds information about executed table evolution script to log table
--
-- @param p_t_evo_file_name
-- File name with executed statements.
--
-- @param p_t_evo_package
-- Related package id
--
-- @param p_pkg_old_rev
-- higher border of version that is applicaple for this migration
--
---
BEGIN

    INSERT INTO table_evolutions_log (t_evo_file_name, t_evo_package)
        VALUES (p_t_evo_file_name, p_t_evo_package);
END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;
2015-12-11 11:58:57,381 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _is_table_ddl_executed(p_file_name TEXT)
    RETURNS BOOLEAN AS
$BODY$
---
-- @description
-- Checks whether file with table ddl has already been executed
--
-- @param p_file_name
-- File name used to check whether statements were executed
--
-- @returns
-- True if executed, False otherwise
---
DECLARE
    return_value BOOLEAN;
BEGIN

    SELECT EXISTS (SELECT t_evo_id FROM table_evolutions_log WHERE t_evo_file_name=p_file_name) INTO return_value;

    RETURN return_value;

END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-11 11:58:57,395 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _set_revision_package(p_pkg_name TEXT,
                                             p_pkg_subclass_name TEXT,
                                             p_pkg_old_rev INTEGER,
                                             p_pkg_v_major INTEGER,
                                             p_pkg_v_minor INTEGER DEFAULT 0,
                                             p_pkg_v_patch INTEGER DEFAULT 0,
                                             p_pkg_v_pre TEXT DEFAULT NULL)
    RETURNS INTEGER AS
$BODY$
---
-- @description
-- Set package as old revision, info logged in deployment events table
--
-- @param p_pkg_name
-- package name
--
-- @param p_pkg_subclass_name
-- package type: either version (with version suffix at the end of the name) or basic (without)
--
-- @param p_pkg_old_rev
-- Revision name of package. Used in moderate form. When schema is renamed it is given a revision suffix from here
--
-- @param p_pkg_v_major
-- package major part of version (according to semver)
--
-- @param p_pkg_v_minor
-- package minor part of version (according to semver)
--
-- @param p_pkg_v_patch
-- package patch part of version (according to semver)
--
-- @param p_pkg_v_pre
-- package pre part of version (according to semver)
--
-- @param p_pkg_v_metadata
-- package metadata part of version (according to semver)
--
-- @param p_pkg_vcs_ref
-- vcs reference to track the code
---
DECLARE
    l_existing_pkg_id INTEGER;
    l_pkg_dep_id INTEGER;

	return_value INTEGER;
BEGIN

    SELECT pkg_id INTO l_existing_pkg_id
    FROM packages
    WHERE pkg_name = p_pkg_name
        AND pkg_subclass IN (SELECT pkg_sc_id
                             FROM package_subclasses
                             WHERE pkg_sc_name = p_pkg_subclass_name)
        AND pkg_v_major = p_pkg_v_major
        AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)
        AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)
        AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre);

    IF FOUND THEN
        UPDATE packages
        SET pkg_old_rev=p_pkg_old_rev
        WHERE packages.pkg_id=l_existing_pkg_id;

        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)
            SELECT pkg_id, txid_current(), dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link
            FROM packages
            JOIN deployment_events ON dpl_ev_pkg_id=pkg_id
            WHERE pkg_id=l_existing_pkg_id AND dpl_ev_time IN (
                SELECT max(dpl_ev_time) FROM deployment_events WHERE dpl_ev_pkg_id=packages.pkg_id
            );
    ELSE
        RAISE EXCEPTION 'Package % not found in the list of packages. It could happen if schema exists but wasn''t properly deployed with pgpm', p_pkg_name || '_' || p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch;
    END IF;

    -- Notify external channels of successful deployment event
    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);

    RETURN return_value;
END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-11 11:58:57,395 - pgpm.app - DEBUG - Functions loaded to schema _pgpm
2015-12-11 11:58:57,404 - pgpm.app - DEBUG - Executing query: set search_path TO _pgpm, public;
2015-12-11 11:58:57,414 - pgpm.app - DEBUG - Executing query: SELECT _find_schema('_pgpm', 'x')
2015-12-11 11:58:57,414 - pgpm.app - ERROR - Can't install pgpm as schema _pgpm already exists
2015-12-11 11:58:57,414 - pgpm.app - DEBUG - Closing connection to host=devel-db2.affinitas.de port=6223 dbname=de_live_devel_db user=apanchoyan password=xxxxxxxxxxx...
2015-12-11 11:58:57,414 - pgpm.app - DEBUG - Connection to host=devel-db2.affinitas.de port=6223 dbname=de_live_devel_db user=apanchoyan password=xxxxxxxxxxx closed.
2015-12-11 12:00:30,918 - pgpm.app - INFO - Installing... host=devel-db2.affinitas.de port=6223 dbname=de_live_devel_db user=apanchoyan password=snojpoksIb6
2015-12-11 12:00:30,957 - pgpm.app - DEBUG - lib/db_scripts/functions/_add_migration_info.sql
2015-12-11 12:00:30,957 - pgpm.app - DEBUG - lib/db_scripts/functions/_alter_schema_owner.sql
2015-12-11 12:00:30,957 - pgpm.app - DEBUG - lib/db_scripts/functions/_find_schema.sql
2015-12-11 12:00:30,957 - pgpm.app - DEBUG - lib/db_scripts/functions/_is_table_ddl_executed.sql
2015-12-11 12:00:30,958 - pgpm.app - DEBUG - lib/db_scripts/functions/_log_ddl_change.sql
2015-12-11 12:00:30,958 - pgpm.app - DEBUG - lib/db_scripts/functions/_log_table_evolution.sql
2015-12-11 12:00:30,958 - pgpm.app - DEBUG - lib/db_scripts/functions/_set_revision_package.sql
2015-12-11 12:00:30,958 - pgpm.app - DEBUG - lib/db_scripts/functions/_upsert_package_info.sql
2015-12-11 12:00:30,958 - pgpm.app - DEBUG - lib/db_scripts/functions/set_search_path.sql
2015-12-11 12:00:30,994 - pgpm.app - DEBUG - Executing query: select * from CURRENT_USER;
2015-12-11 12:00:31,020 - pgpm.app - DEBUG - Executing query: select usesuper from pg_user where usename = CURRENT_USER;
2015-12-11 12:00:31,029 - pgpm.app - DEBUG - Executing query: SELECT EXISTS (SELECT schema_name FROM information_schema.schemata WHERE schema_name = '_pgpm');
2015-12-11 12:00:31,029 - pgpm.app - INFO - Running functions definitions scripts
2015-12-11 12:00:31,029 - pgpm.app - DEBUG - {'_log_ddl_change.sql': u'CREATE OR REPLACE FUNCTION _log_ddl_change()\n    RETURNS EVENT_TRIGGER AS\n$BODY$\n---\n-- @description\n-- Logs any DDL changes to the DB\n--\n---\nDECLARE\n    l_current_query TEXT;\n    l_txid BIGINT;\nBEGIN\n\n    SELECT current_query() INTO l_current_query;\n    SELECT txid_current() INTO l_txid;\n    INSERT INTO _pgpm.ddl_changes_log (ddl_change)\n    SELECT l_current_query\n    WHERE\n        NOT EXISTS (\n            SELECT ddl_change_txid, ddl_change FROM _pgpm.ddl_changes_log\n            WHERE ddl_change_txid = l_txid AND ddl_change = l_current_query\n        );\n\n    -- Notify external channels of ddl change\n    PERFORM pg_notify(\'ddl_change\', "session_user"());\n\nEND;\n$BODY$\nLANGUAGE \'plpgsql\' VOLATILE SECURITY DEFINER;', '_add_migration_info.sql': u"CREATE OR REPLACE FUNCTION _add_migration_info(p_m_low_v TEXT, p_m_high_v TEXT)\n    RETURNS VOID AS\n$BODY$\n---\n-- @description\n-- Adds migration info migrations log table\n--\n-- @param p_m_low_v\n-- lower border of version that is applicaple for this migration\n--\n-- @param p_m_high_v\n-- package type: either version (with version suffix at the end of the name) or basic (without)\n--\n-- @param p_pkg_old_rev\n-- higher border of version that is applicaple for this migration\n--\n---\nBEGIN\n\n    BEGIN\n        INSERT INTO migrations_log (m_low_v, m_high_v)\n            VALUES (p_m_low_v, p_m_high_v);\n    EXCEPTION\n        WHEN SQLSTATE '42P01' THEN\n            RAISE WARNING 'Can''t log migration from % to % as migrations_log is not defined yet', p_m_low_v, p_m_high_v;\n    END;\nEND;\n$BODY$\nLANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", 'set_search_path.sql': u"CREATE OR REPLACE FUNCTION set_search_path(p_schema_name TEXT, p_v_req TEXT)\n    RETURNS json AS\n$BODY$\n---\n-- @description\n-- Sets search path that includes also all depending\n--\n-- @param p_schema_name\n-- Package (schema) name\n--\n-- @param p_v_req\n-- Package version requirement. Version notation supports:\n-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)\n-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x\n-- - comparison operators like >01_02_03 or <2\n-- - x for any latest version of package\n-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency\n--\n-- @returns\n-- JSON with schema names and exact versions or exception if not found\n---\nDECLARE\n    l_search_path TEXT;\n    l_search_path_deps TEXT;\n    l_listen_text TEXT;\n\n    l_pkg_version_wrapped RECORD;\n    l_pkg_version RECORD;\n\n    return_value json;\nBEGIN\n\n    SET search_path TO _pgpm;\n    SELECT _find_schema(p_schema_name, p_v_req) AS version INTO l_pkg_version_wrapped;\n    l_pkg_version := l_pkg_version_wrapped.version;\n\n    l_search_path := l_pkg_version.pkg_name || '_' ||\n                     l_pkg_version.pkg_v_major::text || '_' ||\n                     l_pkg_version.pkg_v_minor::text || '_' ||\n                     l_pkg_version.pkg_v_patch::text;\n\n    SELECT string_agg(pkg_name || '_' || pkg_v_major || '_' || pkg_v_minor || '_' || pkg_v_patch, ', ')\n    FROM packages\n    WHERE pkg_id IN (\n        SELECT pkg_link_dep_id from package_dependencies\n        JOIN packages ON pkg_id = l_pkg_version.pkg_id\n        WHERE pkg_link_core_id = pkg_id\n    )\n    INTO l_search_path_deps;\n\n    l_search_path := l_search_path || ', ' || l_search_path_deps;\n\n    l_listen_text := 'deployment_events' || '$$' || l_pkg_version.pkg_name;\n    EXECUTE 'LISTEN ' || l_listen_text;\n\n    RAISE INFO '%', l_search_path;\n    PERFORM set_config('search_path', l_search_path || ', public', false);\n\n    return_value := row_to_json(l_pkg_version);\n    RETURN return_value;\n\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_find_schema.sql': u"CREATE OR REPLACE FUNCTION _find_schema(p_schema_name TEXT, p_v_req TEXT)\n    RETURNS RECORD AS\n$BODY$\n---\n-- @description\n-- Searches for existing schema (package) within registered packages in _pgpm schema\n--\n-- @param p_schema_name\n-- Package (schema) name\n--\n-- @param p_v_req\n-- Package version requirement. Version notation supports:\n-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)\n-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x\n-- - comparison operators like >01_02_03 or <2\n-- - x for any latest version of package\n-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency\n--\n-- @returns\n-- Record containing schema name and exact version or exception if not found in the following format:\n-- pkg_name TEXT, pkg_v_major INTEGER, pkg_v_minor INTEGER, pkg_v_patch INTEGER\n---\nDECLARE\n    c_re_version TEXT = '^(<=|>=|<|>{0,2})(\\d*|x*)_?(\\d*|x*)_?(\\d*|x*)';\n    l_v_matches TEXT[];\n\n    l_v_major INTEGER;\n    l_v_minor INTEGER;\n    l_v_patch INTEGER;\n\n    return_value RECORD;\nBEGIN\n\n    SELECT regexp_matches(p_v_req, c_re_version, 'gi') INTO l_v_matches;\n\n    IF l_v_matches[2] ~* '^x+|^$' THEN\n        SELECT max(pkg_v_major)\n        FROM packages\n        WHERE pkg_name = p_schema_name\n        INTO l_v_major;\n    ELSE\n        l_v_major := l_v_matches[2]::integer;\n    END IF;\n\n    IF l_v_matches[3] ~* '^x+|^$' THEN\n        SELECT max(pkg_v_minor)\n        FROM packages\n        WHERE pkg_name = p_schema_name\n              AND pkg_v_major = l_v_major\n        INTO l_v_minor;\n    ELSE\n        l_v_minor := l_v_matches[3]::integer;\n    END IF;\n\n    IF l_v_matches[4] ~* '^x+|^$' THEN\n        SELECT max(pkg_v_patch)\n        FROM packages\n        WHERE pkg_name = p_schema_name\n              AND pkg_v_major = l_v_major\n              AND pkg_v_minor = l_v_minor\n        INTO l_v_patch;\n    ELSE\n        l_v_patch := l_v_matches[4]::integer;\n    END IF;\n\n    CASE l_v_matches[1]\n        WHEN '=', '' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND pkg_v_major = l_v_major\n                  AND pkg_v_minor = l_v_minor\n                  AND pkg_v_patch = l_v_patch\n            INTO return_value;\n        WHEN '<' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major < l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor < l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch < l_v_patch))\n            INTO return_value;\n        WHEN '>' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major > l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor > l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch > l_v_patch))\n            INTO return_value;\n        WHEN '<=' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major <= l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor <= l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch <= l_v_patch))\n            INTO return_value;\n        WHEN '>=' THEN\n            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch\n            FROM packages\n            WHERE pkg_name = p_schema_name\n                  AND (pkg_v_major >= l_v_major\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor >= l_v_minor)\n                       OR (pkg_v_major = l_v_major\n                           AND pkg_v_minor = l_v_minor\n                           AND pkg_v_patch >= l_v_patch))\n            INTO return_value;\n        ELSE\n            RAISE EXCEPTION 'Invalid logical operand. Only <, >, =, <=, >=, = or no operand are allowed.' USING ERRCODE = '20000';\n    END CASE;\n\n    RETURN return_value;\n\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_upsert_package_info.sql': u"CREATE OR REPLACE FUNCTION _upsert_package_info(p_pkg_name TEXT,\n                                             p_pkg_subclass_name TEXT,\n                                             p_pkg_v_major INTEGER,\n                                             p_pkg_v_minor INTEGER DEFAULT 0,\n                                             p_pkg_v_patch INTEGER DEFAULT 0,\n                                             p_pkg_v_pre TEXT DEFAULT NULL,\n                                             p_pkg_v_metadata TEXT DEFAULT NULL,\n                                             p_pkg_description TEXT DEFAULT '',\n                                             p_pkg_license TEXT DEFAULT NULL,\n                                             p_pkg_deps_ids INTEGER[] DEFAULT '{}',\n                                             p_pkg_vcs_ref TEXT DEFAULT NULL,\n                                             p_pkg_vcs_link TEXT DEFAULT NULL,\n                                             p_pkg_issue_ref TEXT DEFAULT NULL,\n                                             p_pkg_issue_link TEXT DEFAULT NULL)\n    RETURNS INTEGER AS\n$BODY$\n---\n-- @description\n-- Adds package info to pgpm package info table, deployment events table and notifies channels of deployment\n--\n-- @param p_pkg_name\n-- package name\n--\n-- @param p_pkg_subclass_name\n-- package type: either version (with version suffix at the end of the name) or basic (without)\n--\n-- @param p_pkg_description\n-- package description\n--\n-- @param p_pkg_v_major\n-- package major part of version (according to semver)\n--\n-- @param p_pkg_v_minor\n-- package minor part of version (according to semver)\n--\n-- @param p_pkg_v_patch\n-- package patch part of version (according to semver)\n--\n-- @param p_pkg_v_pre\n-- package pre part of version (according to semver)\n--\n-- @param p_pkg_v_metadata\n-- package metadata part of version (according to semver)\n--\n-- @param p_pkg_license\n-- package license name/text\n--\n-- @param p_pkg_deps_ids\n-- IDs of dependent schemas\n--\n-- @param p_pkg_vcs_ref\n-- vcs reference to track the code\n--\n-- @param p_pkg_vcs_link\n-- repository link to track the code\n--\n-- @param p_pkg_issue_ref\n-- issue reference to track the code\n--\n-- @param p_pkg_issue_link\n-- issue tracking system link\n---\nDECLARE\n    l_existing_pkg_id INTEGER;\n    l_pkg_dep_id INTEGER;\n\n\treturn_value INTEGER;\nBEGIN\n\n    -- Case 1: unsafe mode, rewrite of the whole schema with the same version or some of the files in it\n    -- Case 2: new schema with new version (safe or moderate modes)\n\n    IF p_pkg_subclass_name = 'basic' THEN\n        SELECT pkg_id INTO l_existing_pkg_id\n        FROM packages\n        WHERE pkg_name = p_pkg_name\n            AND pkg_subclass IN (SELECT pkg_sc_id\n                                 FROM package_subclasses\n                                 WHERE pkg_sc_name = p_pkg_subclass_name);\n    ELSE\n        SELECT pkg_id INTO l_existing_pkg_id\n        FROM packages\n        WHERE pkg_name = p_pkg_name\n            AND pkg_subclass IN (SELECT pkg_sc_id\n                                 FROM package_subclasses\n                                 WHERE pkg_sc_name = p_pkg_subclass_name)\n            AND pkg_v_major = p_pkg_v_major\n            AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)\n            AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)\n            AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre)\n            AND pkg_old_rev IS NULL;\n    END IF;\n\n    IF FOUND THEN -- Case 1:\n        DELETE FROM package_dependencies\n            WHERE pkg_link_core_id = l_existing_pkg_id;\n\n        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids\n        LOOP\n            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (l_existing_pkg_id, l_pkg_dep_id);\n        END LOOP;\n\n        UPDATE packages\n        SET pkg_name=subquery.p_pkg_name,\n            pkg_subclass=subquery.pkg_sc_id,\n            pkg_v_major=subquery.p_pkg_v_major,\n            pkg_v_minor=subquery.p_pkg_v_minor,\n            pkg_v_patch=subquery.p_pkg_v_patch,\n            pkg_v_pre=subquery.p_pkg_v_pre,\n            pkg_v_metadata=subquery.p_pkg_v_metadata,\n            pkg_description=subquery.p_pkg_description,\n            pkg_license=subquery.p_pkg_license\n        FROM (SELECT\n                  p_pkg_name,\n                  pkg_sc_id,\n                  p_pkg_v_major,\n                  p_pkg_v_minor,\n                  p_pkg_v_patch,\n                  p_pkg_v_pre,\n                  p_pkg_v_metadata,\n                  p_pkg_description,\n                  p_pkg_license\n              FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name\n        ) as subquery\n        WHERE packages.pkg_name=subquery.p_pkg_name;\n\n        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)\n            VALUES (l_existing_pkg_id, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);\n\n        return_value := l_existing_pkg_id;\n    ELSE -- Case 2:\n        INSERT INTO packages (\n            pkg_name,\n            pkg_description,\n            pkg_v_major,\n            pkg_v_minor,\n            pkg_v_patch,\n            pkg_v_pre,\n            pkg_v_metadata,\n            pkg_subclass,\n            pkg_license\n        )\n        SELECT\n            p_pkg_name,\n            p_pkg_description,\n            p_pkg_v_major,\n            p_pkg_v_minor,\n            p_pkg_v_patch,\n            p_pkg_v_pre,\n            p_pkg_v_metadata,\n            pkg_sc_id,\n            p_pkg_license\n        FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name\n        RETURNING\n            pkg_id\n        INTO return_value;\n\n        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids\n        LOOP\n            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (return_value, l_pkg_dep_id);\n        END LOOP;\n\n        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)\n            VALUES (return_value, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);\n\n    END IF;\n\n    -- Notify external channels of successful deployment event\n    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);\n\n    RETURN return_value;\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_alter_schema_owner.sql': u"CREATE OR REPLACE FUNCTION _alter_schema_owner(p_schema TEXT, p_owner TEXT)\n    RETURNS VOID AS\n$BODY$\n---\n-- @description\n-- Alters ownership of schema and all its objects to a specified user.\n--\n-- @param p_schema\n-- Schema name\n--\n-- @param p_owner\n-- New owner user name\n--\n---\nDECLARE\n    l_schema TEXT;\n    l_functions TEXT;\n    l_tables TEXT;\n    l_sequences TEXT;\n    l_views TEXT;\n    l_domains TEXT;\n    l_triggers TEXT;\n    l_types TEXT;\n\nBEGIN\n\n    l_schema := 'ALTER SCHEMA '\n                || quote_ident(p_schema)\n                || ' OWNER TO '\n                || quote_ident(p_owner)\n                || ';';\n\n    SELECT string_agg('ALTER FUNCTION '\n                || quote_ident(n.nspname) || '.'\n                || quote_ident(p.proname) || '('\n                || pg_catalog.pg_get_function_identity_arguments(p.oid)\n                || ') OWNER TO ' || p_owner || ';'\n              , E'\\n') AS _sql\n    FROM   pg_catalog.pg_proc p\n    JOIN   pg_catalog.pg_namespace n ON n.oid = p.pronamespace\n    WHERE  n.nspname = p_schema\n    INTO l_functions;\n    IF l_functions IS NULL THEN\n        l_functions := '';\n    END IF;\n\n    SELECT string_agg('ALTER TABLE ' || quote_ident(schemaname) || '.' || quote_ident(tablename) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM pg_tables WHERE schemaname = p_schema\n    INTO l_tables;\n    IF l_tables IS NULL THEN\n        l_tables := '';\n    END IF;\n\n    SELECT string_agg('ALTER SEQUENCE ' || quote_ident(sequence_schema) || '.' || quote_ident(sequence_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.sequences WHERE sequence_schema = p_schema\n    INTO l_sequences;\n    IF l_sequences IS NULL THEN\n        l_sequences := '';\n    END IF;\n\n    SELECT string_agg('ALTER VIEW ' || quote_ident(table_schema) || '.' || quote_ident(table_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.views WHERE table_schema = p_schema\n    INTO l_views;\n    IF l_views IS NULL THEN\n        l_views := '';\n    END IF;\n\n    SELECT string_agg('ALTER DOMAIN ' || quote_ident(domain_schema) || '.' || quote_ident(domain_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.domains WHERE domain_schema = p_schema\n    INTO l_domains;\n    IF l_domains IS NULL THEN\n        l_domains := '';\n    END IF;\n\n    SELECT string_agg('ALTER TRIGGER ' || quote_ident(trigger_schema) || '.' || quote_ident(trigger_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.triggers WHERE trigger_schema = p_schema\n    INTO l_triggers;\n    IF l_triggers IS NULL THEN\n        l_triggers := '';\n    END IF;\n\n    SELECT string_agg('ALTER TYPE ' || quote_ident(user_defined_type_schema) || '.' || quote_ident(user_defined_type_name) ||' OWNER TO ' || p_owner || ';', E'\\n')\n    FROM information_schema.user_defined_types WHERE user_defined_type_schema = p_schema\n    INTO l_types;\n    IF l_types IS NULL THEN\n        l_types := '';\n    END IF;\n\n    EXECUTE l_schema || l_functions || l_tables || l_sequences || l_views || l_domains || l_triggers || l_types;\n\nEND;\n$BODY$\nLANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;", '_log_table_evolution.sql': u"CREATE OR REPLACE FUNCTION _log_table_evolution(p_t_evo_file_name TEXT, p_t_evo_package INTEGER)\n    RETURNS VOID AS\n$BODY$\n---\n-- @description\n-- Adds information about executed table evolution script to log table\n--\n-- @param p_t_evo_file_name\n-- File name with executed statements.\n--\n-- @param p_t_evo_package\n-- Related package id\n--\n-- @param p_pkg_old_rev\n-- higher border of version that is applicaple for this migration\n--\n---\nBEGIN\n\n    INSERT INTO table_evolutions_log (t_evo_file_name, t_evo_package)\n        VALUES (p_t_evo_file_name, p_t_evo_package);\nEND;\n$BODY$\nLANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;", '_is_table_ddl_executed.sql': u"CREATE OR REPLACE FUNCTION _is_table_ddl_executed(p_file_name TEXT)\n    RETURNS BOOLEAN AS\n$BODY$\n---\n-- @description\n-- Checks whether file with table ddl has already been executed\n--\n-- @param p_file_name\n-- File name used to check whether statements were executed\n--\n-- @returns\n-- True if executed, False otherwise\n---\nDECLARE\n    return_value BOOLEAN;\nBEGIN\n\n    SELECT EXISTS (SELECT t_evo_id FROM table_evolutions_log WHERE t_evo_file_name=p_file_name) INTO return_value;\n\n    RETURN return_value;\n\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n", '_set_revision_package.sql': u"CREATE OR REPLACE FUNCTION _set_revision_package(p_pkg_name TEXT,\n                                             p_pkg_subclass_name TEXT,\n                                             p_pkg_old_rev INTEGER,\n                                             p_pkg_v_major INTEGER,\n                                             p_pkg_v_minor INTEGER DEFAULT 0,\n                                             p_pkg_v_patch INTEGER DEFAULT 0,\n                                             p_pkg_v_pre TEXT DEFAULT NULL)\n    RETURNS INTEGER AS\n$BODY$\n---\n-- @description\n-- Set package as old revision, info logged in deployment events table\n--\n-- @param p_pkg_name\n-- package name\n--\n-- @param p_pkg_subclass_name\n-- package type: either version (with version suffix at the end of the name) or basic (without)\n--\n-- @param p_pkg_old_rev\n-- Revision name of package. Used in moderate form. When schema is renamed it is given a revision suffix from here\n--\n-- @param p_pkg_v_major\n-- package major part of version (according to semver)\n--\n-- @param p_pkg_v_minor\n-- package minor part of version (according to semver)\n--\n-- @param p_pkg_v_patch\n-- package patch part of version (according to semver)\n--\n-- @param p_pkg_v_pre\n-- package pre part of version (according to semver)\n--\n-- @param p_pkg_v_metadata\n-- package metadata part of version (according to semver)\n--\n-- @param p_pkg_vcs_ref\n-- vcs reference to track the code\n---\nDECLARE\n    l_existing_pkg_id INTEGER;\n    l_pkg_dep_id INTEGER;\n\n\treturn_value INTEGER;\nBEGIN\n\n    SELECT pkg_id INTO l_existing_pkg_id\n    FROM packages\n    WHERE pkg_name = p_pkg_name\n        AND pkg_subclass IN (SELECT pkg_sc_id\n                             FROM package_subclasses\n                             WHERE pkg_sc_name = p_pkg_subclass_name)\n        AND pkg_v_major = p_pkg_v_major\n        AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)\n        AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)\n        AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre);\n\n    IF FOUND THEN\n        UPDATE packages\n        SET pkg_old_rev=p_pkg_old_rev\n        WHERE packages.pkg_id=l_existing_pkg_id;\n\n        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)\n            SELECT pkg_id, txid_current(), dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link\n            FROM packages\n            JOIN deployment_events ON dpl_ev_pkg_id=pkg_id\n            WHERE pkg_id=l_existing_pkg_id AND dpl_ev_time IN (\n                SELECT max(dpl_ev_time) FROM deployment_events WHERE dpl_ev_pkg_id=packages.pkg_id\n            );\n    ELSE\n        RAISE EXCEPTION 'Package % not found in the list of packages. It could happen if schema exists but wasn''t properly deployed with pgpm', p_pkg_name || '_' || p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch;\n    END IF;\n\n    -- Notify external channels of successful deployment event\n    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);\n\n    RETURN return_value;\nEND;\n$BODY$\n    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;\n"}
2015-12-11 12:00:31,035 - pgpm.app - DEBUG - Executing query: set search_path TO _pgpm, public;
2015-12-11 12:00:31,064 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _log_ddl_change()
    RETURNS EVENT_TRIGGER AS
$BODY$
---
-- @description
-- Logs any DDL changes to the DB
--
---
DECLARE
    l_current_query TEXT;
    l_txid BIGINT;
BEGIN

    SELECT current_query() INTO l_current_query;
    SELECT txid_current() INTO l_txid;
    INSERT INTO _pgpm.ddl_changes_log (ddl_change)
    SELECT l_current_query
    WHERE
        NOT EXISTS (
            SELECT ddl_change_txid, ddl_change FROM _pgpm.ddl_changes_log
            WHERE ddl_change_txid = l_txid AND ddl_change = l_current_query
        );

    -- Notify external channels of ddl change
    PERFORM pg_notify('ddl_change', "session_user"());

END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;
2015-12-11 12:00:31,074 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _add_migration_info(p_m_low_v TEXT, p_m_high_v TEXT)
    RETURNS VOID AS
$BODY$
---
-- @description
-- Adds migration info migrations log table
--
-- @param p_m_low_v
-- lower border of version that is applicaple for this migration
--
-- @param p_m_high_v
-- package type: either version (with version suffix at the end of the name) or basic (without)
--
-- @param p_pkg_old_rev
-- higher border of version that is applicaple for this migration
--
---
BEGIN

    BEGIN
        INSERT INTO migrations_log (m_low_v, m_high_v)
            VALUES (p_m_low_v, p_m_high_v);
    EXCEPTION
        WHEN SQLSTATE '42P01' THEN
            RAISE WARNING 'Can''t log migration from % to % as migrations_log is not defined yet', p_m_low_v, p_m_high_v;
    END;
END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-11 12:00:31,087 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION set_search_path(p_schema_name TEXT, p_v_req TEXT)
    RETURNS json AS
$BODY$
---
-- @description
-- Sets search path that includes also all depending
--
-- @param p_schema_name
-- Package (schema) name
--
-- @param p_v_req
-- Package version requirement. Version notation supports:
-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)
-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x
-- - comparison operators like >01_02_03 or <2
-- - x for any latest version of package
-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency
--
-- @returns
-- JSON with schema names and exact versions or exception if not found
---
DECLARE
    l_search_path TEXT;
    l_search_path_deps TEXT;
    l_listen_text TEXT;

    l_pkg_version_wrapped RECORD;
    l_pkg_version RECORD;

    return_value json;
BEGIN

    SET search_path TO _pgpm;
    SELECT _find_schema(p_schema_name, p_v_req) AS version INTO l_pkg_version_wrapped;
    l_pkg_version := l_pkg_version_wrapped.version;

    l_search_path := l_pkg_version.pkg_name || '_' ||
                     l_pkg_version.pkg_v_major::text || '_' ||
                     l_pkg_version.pkg_v_minor::text || '_' ||
                     l_pkg_version.pkg_v_patch::text;

    SELECT string_agg(pkg_name || '_' || pkg_v_major || '_' || pkg_v_minor || '_' || pkg_v_patch, ', ')
    FROM packages
    WHERE pkg_id IN (
        SELECT pkg_link_dep_id from package_dependencies
        JOIN packages ON pkg_id = l_pkg_version.pkg_id
        WHERE pkg_link_core_id = pkg_id
    )
    INTO l_search_path_deps;

    l_search_path := l_search_path || ', ' || l_search_path_deps;

    l_listen_text := 'deployment_events' || '$$' || l_pkg_version.pkg_name;
    EXECUTE 'LISTEN ' || l_listen_text;

    RAISE INFO '%', l_search_path;
    PERFORM set_config('search_path', l_search_path || ', public', false);

    return_value := row_to_json(l_pkg_version);
    RETURN return_value;

END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-11 12:00:31,102 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _find_schema(p_schema_name TEXT, p_v_req TEXT)
    RETURNS RECORD AS
$BODY$
---
-- @description
-- Searches for existing schema (package) within registered packages in _pgpm schema
--
-- @param p_schema_name
-- Package (schema) name
--
-- @param p_v_req
-- Package version requirement. Version notation supports:
-- - exact version number either in a format 1_2_3 or 01_02_03 (latter format is for formatting purposes)
-- - x notation like 01_02_XX or 01_02_xx or 1_2_X or 1_2_x
-- - comparison operators like >01_02_03 or <2
-- - x for any latest version of package
-- Package name must comply with naming conventions of postgres, exist as schema and be trackable by pgpm in order to satisfy dependency
--
-- @returns
-- Record containing schema name and exact version or exception if not found in the following format:
-- pkg_name TEXT, pkg_v_major INTEGER, pkg_v_minor INTEGER, pkg_v_patch INTEGER
---
DECLARE
    c_re_version TEXT = '^(<=|>=|<|>{0,2})(\d*|x*)_?(\d*|x*)_?(\d*|x*)';
    l_v_matches TEXT[];

    l_v_major INTEGER;
    l_v_minor INTEGER;
    l_v_patch INTEGER;

    return_value RECORD;
BEGIN

    SELECT regexp_matches(p_v_req, c_re_version, 'gi') INTO l_v_matches;

    IF l_v_matches[2] ~* '^x+|^$' THEN
        SELECT max(pkg_v_major)
        FROM packages
        WHERE pkg_name = p_schema_name
        INTO l_v_major;
    ELSE
        l_v_major := l_v_matches[2]::integer;
    END IF;

    IF l_v_matches[3] ~* '^x+|^$' THEN
        SELECT max(pkg_v_minor)
        FROM packages
        WHERE pkg_name = p_schema_name
              AND pkg_v_major = l_v_major
        INTO l_v_minor;
    ELSE
        l_v_minor := l_v_matches[3]::integer;
    END IF;

    IF l_v_matches[4] ~* '^x+|^$' THEN
        SELECT max(pkg_v_patch)
        FROM packages
        WHERE pkg_name = p_schema_name
              AND pkg_v_major = l_v_major
              AND pkg_v_minor = l_v_minor
        INTO l_v_patch;
    ELSE
        l_v_patch := l_v_matches[4]::integer;
    END IF;

    CASE l_v_matches[1]
        WHEN '=', '' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND pkg_v_major = l_v_major
                  AND pkg_v_minor = l_v_minor
                  AND pkg_v_patch = l_v_patch
            INTO return_value;
        WHEN '<' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major < l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor < l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch < l_v_patch))
            INTO return_value;
        WHEN '>' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major > l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor > l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch > l_v_patch))
            INTO return_value;
        WHEN '<=' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major <= l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor <= l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch <= l_v_patch))
            INTO return_value;
        WHEN '>=' THEN
            SELECT DISTINCT pkg_id, pkg_name, pkg_v_major, pkg_v_minor, pkg_v_patch
            FROM packages
            WHERE pkg_name = p_schema_name
                  AND (pkg_v_major >= l_v_major
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor >= l_v_minor)
                       OR (pkg_v_major = l_v_major
                           AND pkg_v_minor = l_v_minor
                           AND pkg_v_patch >= l_v_patch))
            INTO return_value;
        ELSE
            RAISE EXCEPTION 'Invalid logical operand. Only <, >, =, <=, >=, = or no operand are allowed.' USING ERRCODE = '20000';
    END CASE;

    RETURN return_value;

END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-11 12:00:31,120 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _upsert_package_info(p_pkg_name TEXT,
                                             p_pkg_subclass_name TEXT,
                                             p_pkg_v_major INTEGER,
                                             p_pkg_v_minor INTEGER DEFAULT 0,
                                             p_pkg_v_patch INTEGER DEFAULT 0,
                                             p_pkg_v_pre TEXT DEFAULT NULL,
                                             p_pkg_v_metadata TEXT DEFAULT NULL,
                                             p_pkg_description TEXT DEFAULT '',
                                             p_pkg_license TEXT DEFAULT NULL,
                                             p_pkg_deps_ids INTEGER[] DEFAULT '{}',
                                             p_pkg_vcs_ref TEXT DEFAULT NULL,
                                             p_pkg_vcs_link TEXT DEFAULT NULL,
                                             p_pkg_issue_ref TEXT DEFAULT NULL,
                                             p_pkg_issue_link TEXT DEFAULT NULL)
    RETURNS INTEGER AS
$BODY$
---
-- @description
-- Adds package info to pgpm package info table, deployment events table and notifies channels of deployment
--
-- @param p_pkg_name
-- package name
--
-- @param p_pkg_subclass_name
-- package type: either version (with version suffix at the end of the name) or basic (without)
--
-- @param p_pkg_description
-- package description
--
-- @param p_pkg_v_major
-- package major part of version (according to semver)
--
-- @param p_pkg_v_minor
-- package minor part of version (according to semver)
--
-- @param p_pkg_v_patch
-- package patch part of version (according to semver)
--
-- @param p_pkg_v_pre
-- package pre part of version (according to semver)
--
-- @param p_pkg_v_metadata
-- package metadata part of version (according to semver)
--
-- @param p_pkg_license
-- package license name/text
--
-- @param p_pkg_deps_ids
-- IDs of dependent schemas
--
-- @param p_pkg_vcs_ref
-- vcs reference to track the code
--
-- @param p_pkg_vcs_link
-- repository link to track the code
--
-- @param p_pkg_issue_ref
-- issue reference to track the code
--
-- @param p_pkg_issue_link
-- issue tracking system link
---
DECLARE
    l_existing_pkg_id INTEGER;
    l_pkg_dep_id INTEGER;

	return_value INTEGER;
BEGIN

    -- Case 1: unsafe mode, rewrite of the whole schema with the same version or some of the files in it
    -- Case 2: new schema with new version (safe or moderate modes)

    IF p_pkg_subclass_name = 'basic' THEN
        SELECT pkg_id INTO l_existing_pkg_id
        FROM packages
        WHERE pkg_name = p_pkg_name
            AND pkg_subclass IN (SELECT pkg_sc_id
                                 FROM package_subclasses
                                 WHERE pkg_sc_name = p_pkg_subclass_name);
    ELSE
        SELECT pkg_id INTO l_existing_pkg_id
        FROM packages
        WHERE pkg_name = p_pkg_name
            AND pkg_subclass IN (SELECT pkg_sc_id
                                 FROM package_subclasses
                                 WHERE pkg_sc_name = p_pkg_subclass_name)
            AND pkg_v_major = p_pkg_v_major
            AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)
            AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)
            AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre)
            AND pkg_old_rev IS NULL;
    END IF;

    IF FOUND THEN -- Case 1:
        DELETE FROM package_dependencies
            WHERE pkg_link_core_id = l_existing_pkg_id;

        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids
        LOOP
            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (l_existing_pkg_id, l_pkg_dep_id);
        END LOOP;

        UPDATE packages
        SET pkg_name=subquery.p_pkg_name,
            pkg_subclass=subquery.pkg_sc_id,
            pkg_v_major=subquery.p_pkg_v_major,
            pkg_v_minor=subquery.p_pkg_v_minor,
            pkg_v_patch=subquery.p_pkg_v_patch,
            pkg_v_pre=subquery.p_pkg_v_pre,
            pkg_v_metadata=subquery.p_pkg_v_metadata,
            pkg_description=subquery.p_pkg_description,
            pkg_license=subquery.p_pkg_license
        FROM (SELECT
                  p_pkg_name,
                  pkg_sc_id,
                  p_pkg_v_major,
                  p_pkg_v_minor,
                  p_pkg_v_patch,
                  p_pkg_v_pre,
                  p_pkg_v_metadata,
                  p_pkg_description,
                  p_pkg_license
              FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name
        ) as subquery
        WHERE packages.pkg_name=subquery.p_pkg_name;

        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)
            VALUES (l_existing_pkg_id, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);

        return_value := l_existing_pkg_id;
    ELSE -- Case 2:
        INSERT INTO packages (
            pkg_name,
            pkg_description,
            pkg_v_major,
            pkg_v_minor,
            pkg_v_patch,
            pkg_v_pre,
            pkg_v_metadata,
            pkg_subclass,
            pkg_license
        )
        SELECT
            p_pkg_name,
            p_pkg_description,
            p_pkg_v_major,
            p_pkg_v_minor,
            p_pkg_v_patch,
            p_pkg_v_pre,
            p_pkg_v_metadata,
            pkg_sc_id,
            p_pkg_license
        FROM package_subclasses WHERE pkg_sc_name = p_pkg_subclass_name
        RETURNING
            pkg_id
        INTO return_value;

        FOREACH l_pkg_dep_id IN ARRAY p_pkg_deps_ids
        LOOP
            INSERT INTO package_dependencies (pkg_link_core_id, pkg_link_dep_id) VALUES (return_value, l_pkg_dep_id);
        END LOOP;

        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)
            VALUES (return_value, txid_current(), p_pkg_vcs_ref, p_pkg_vcs_link, p_pkg_issue_ref, p_pkg_issue_link);

    END IF;

    -- Notify external channels of successful deployment event
    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);

    RETURN return_value;
END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-11 12:00:31,128 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _alter_schema_owner(p_schema TEXT, p_owner TEXT)
    RETURNS VOID AS
$BODY$
---
-- @description
-- Alters ownership of schema and all its objects to a specified user.
--
-- @param p_schema
-- Schema name
--
-- @param p_owner
-- New owner user name
--
---
DECLARE
    l_schema TEXT;
    l_functions TEXT;
    l_tables TEXT;
    l_sequences TEXT;
    l_views TEXT;
    l_domains TEXT;
    l_triggers TEXT;
    l_types TEXT;

BEGIN

    l_schema := 'ALTER SCHEMA '
                || quote_ident(p_schema)
                || ' OWNER TO '
                || quote_ident(p_owner)
                || ';';

    SELECT string_agg('ALTER FUNCTION '
                || quote_ident(n.nspname) || '.'
                || quote_ident(p.proname) || '('
                || pg_catalog.pg_get_function_identity_arguments(p.oid)
                || ') OWNER TO ' || p_owner || ';'
              , E'\n') AS _sql
    FROM   pg_catalog.pg_proc p
    JOIN   pg_catalog.pg_namespace n ON n.oid = p.pronamespace
    WHERE  n.nspname = p_schema
    INTO l_functions;
    IF l_functions IS NULL THEN
        l_functions := '';
    END IF;

    SELECT string_agg('ALTER TABLE ' || quote_ident(schemaname) || '.' || quote_ident(tablename) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM pg_tables WHERE schemaname = p_schema
    INTO l_tables;
    IF l_tables IS NULL THEN
        l_tables := '';
    END IF;

    SELECT string_agg('ALTER SEQUENCE ' || quote_ident(sequence_schema) || '.' || quote_ident(sequence_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.sequences WHERE sequence_schema = p_schema
    INTO l_sequences;
    IF l_sequences IS NULL THEN
        l_sequences := '';
    END IF;

    SELECT string_agg('ALTER VIEW ' || quote_ident(table_schema) || '.' || quote_ident(table_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.views WHERE table_schema = p_schema
    INTO l_views;
    IF l_views IS NULL THEN
        l_views := '';
    END IF;

    SELECT string_agg('ALTER DOMAIN ' || quote_ident(domain_schema) || '.' || quote_ident(domain_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.domains WHERE domain_schema = p_schema
    INTO l_domains;
    IF l_domains IS NULL THEN
        l_domains := '';
    END IF;

    SELECT string_agg('ALTER TRIGGER ' || quote_ident(trigger_schema) || '.' || quote_ident(trigger_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.triggers WHERE trigger_schema = p_schema
    INTO l_triggers;
    IF l_triggers IS NULL THEN
        l_triggers := '';
    END IF;

    SELECT string_agg('ALTER TYPE ' || quote_ident(user_defined_type_schema) || '.' || quote_ident(user_defined_type_name) ||' OWNER TO ' || p_owner || ';', E'\n')
    FROM information_schema.user_defined_types WHERE user_defined_type_schema = p_schema
    INTO l_types;
    IF l_types IS NULL THEN
        l_types := '';
    END IF;

    EXECUTE l_schema || l_functions || l_tables || l_sequences || l_views || l_domains || l_triggers || l_types;

END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;
2015-12-11 12:00:31,138 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _log_table_evolution(p_t_evo_file_name TEXT, p_t_evo_package INTEGER)
    RETURNS VOID AS
$BODY$
---
-- @description
-- Adds information about executed table evolution script to log table
--
-- @param p_t_evo_file_name
-- File name with executed statements.
--
-- @param p_t_evo_package
-- Related package id
--
-- @param p_pkg_old_rev
-- higher border of version that is applicaple for this migration
--
---
BEGIN

    INSERT INTO table_evolutions_log (t_evo_file_name, t_evo_package)
        VALUES (p_t_evo_file_name, p_t_evo_package);
END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;
2015-12-11 12:00:31,151 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _is_table_ddl_executed(p_file_name TEXT)
    RETURNS BOOLEAN AS
$BODY$
---
-- @description
-- Checks whether file with table ddl has already been executed
--
-- @param p_file_name
-- File name used to check whether statements were executed
--
-- @returns
-- True if executed, False otherwise
---
DECLARE
    return_value BOOLEAN;
BEGIN

    SELECT EXISTS (SELECT t_evo_id FROM table_evolutions_log WHERE t_evo_file_name=p_file_name) INTO return_value;

    RETURN return_value;

END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-11 12:00:31,167 - pgpm.app - DEBUG - Executing query: CREATE OR REPLACE FUNCTION _set_revision_package(p_pkg_name TEXT,
                                             p_pkg_subclass_name TEXT,
                                             p_pkg_old_rev INTEGER,
                                             p_pkg_v_major INTEGER,
                                             p_pkg_v_minor INTEGER DEFAULT 0,
                                             p_pkg_v_patch INTEGER DEFAULT 0,
                                             p_pkg_v_pre TEXT DEFAULT NULL)
    RETURNS INTEGER AS
$BODY$
---
-- @description
-- Set package as old revision, info logged in deployment events table
--
-- @param p_pkg_name
-- package name
--
-- @param p_pkg_subclass_name
-- package type: either version (with version suffix at the end of the name) or basic (without)
--
-- @param p_pkg_old_rev
-- Revision name of package. Used in moderate form. When schema is renamed it is given a revision suffix from here
--
-- @param p_pkg_v_major
-- package major part of version (according to semver)
--
-- @param p_pkg_v_minor
-- package minor part of version (according to semver)
--
-- @param p_pkg_v_patch
-- package patch part of version (according to semver)
--
-- @param p_pkg_v_pre
-- package pre part of version (according to semver)
--
-- @param p_pkg_v_metadata
-- package metadata part of version (according to semver)
--
-- @param p_pkg_vcs_ref
-- vcs reference to track the code
---
DECLARE
    l_existing_pkg_id INTEGER;
    l_pkg_dep_id INTEGER;

	return_value INTEGER;
BEGIN

    SELECT pkg_id INTO l_existing_pkg_id
    FROM packages
    WHERE pkg_name = p_pkg_name
        AND pkg_subclass IN (SELECT pkg_sc_id
                             FROM package_subclasses
                             WHERE pkg_sc_name = p_pkg_subclass_name)
        AND pkg_v_major = p_pkg_v_major
        AND (pkg_v_minor IS NULL OR pkg_v_minor = p_pkg_v_minor)
        AND (pkg_v_patch IS NULL OR pkg_v_patch = p_pkg_v_patch)
        AND (pkg_v_pre IS NULL OR pkg_v_pre = p_pkg_v_pre);

    IF FOUND THEN
        UPDATE packages
        SET pkg_old_rev=p_pkg_old_rev
        WHERE packages.pkg_id=l_existing_pkg_id;

        INSERT INTO deployment_events (dpl_ev_pkg_id, dpl_ev_txid, dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link)
            SELECT pkg_id, txid_current(), dpl_ev_vcs_ref, dpl_ev_vcs_link, dpl_ev_issue_id, dpl_ev_issue_link
            FROM packages
            JOIN deployment_events ON dpl_ev_pkg_id=pkg_id
            WHERE pkg_id=l_existing_pkg_id AND dpl_ev_time IN (
                SELECT max(dpl_ev_time) FROM deployment_events WHERE dpl_ev_pkg_id=packages.pkg_id
            );
    ELSE
        RAISE EXCEPTION 'Package % not found in the list of packages. It could happen if schema exists but wasn''t properly deployed with pgpm', p_pkg_name || '_' || p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch;
    END IF;

    -- Notify external channels of successful deployment event
    PERFORM pg_notify('deployment_events' || '$$' || p_pkg_name, p_pkg_v_major || '_' || p_pkg_v_minor || '_' || p_pkg_v_patch);

    RETURN return_value;
END;
$BODY$
    LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER;

2015-12-11 12:00:31,167 - pgpm.app - DEBUG - Functions loaded to schema _pgpm
2015-12-11 12:00:31,179 - pgpm.app - DEBUG - Executing query: set search_path TO _pgpm, public;
2015-12-11 12:00:31,189 - pgpm.app - DEBUG - Executing query: SELECT _find_schema('_pgpm', 'x')
2015-12-11 12:00:31,205 - pgpm.app - DEBUG - Executing query: ALTER DEFAULT PRIVILEGES IN SCHEMA _pgpm GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO edarling;ALTER DEFAULT PRIVILEGES IN SCHEMA _pgpm GRANT EXECUTE ON FUNCTIONS TO edarling;ALTER DEFAULT PRIVILEGES IN SCHEMA _pgpm GRANT USAGE, SELECT ON SEQUENCES TO edarling;
2015-12-11 12:00:31,221 - pgpm.app - DEBUG - Executing query: GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA _pgpm TO edarling;GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA _pgpm TO edarling;GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA _pgpm TO edarling;
2015-12-11 12:00:31,224 - pgpm.app - DEBUG - Executing query: set search_path TO _pgpm, public;
2015-12-11 12:00:31,232 - pgpm.app - DEBUG - Calling stored procedure: SELECT * FROM _upsert_package_info('_pgpm','basic','0','1','48',NULL,NULL,'Package manager for Postgres','MIT')
2015-12-11 12:00:31,235 - pgpm.app - DEBUG - Closing connection to host=devel-db2.affinitas.de port=6223 dbname=de_live_devel_db user=apanchoyan password=xxxxxxxxxxx...
2015-12-11 12:00:31,235 - pgpm.app - DEBUG - Connection to host=devel-db2.affinitas.de port=6223 dbname=de_live_devel_db user=apanchoyan password=xxxxxxxxxxx closed.
2015-12-11 12:00:31,236 - pgpm.app - INFO - Successfully installed host=devel-db2.affinitas.de port=6223 dbname=de_live_devel_db user=apanchoyan password=snojpoksIb6
